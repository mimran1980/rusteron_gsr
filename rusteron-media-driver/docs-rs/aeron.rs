type aeron_client_registering_resource_t = aeron_client_registering_resource_stct;
#[derive(Clone)]
pub struct DarwinPthreadHandlerRec {
    inner: CResource<__darwin_pthread_handler_rec>,
}
impl core::fmt::Debug for DarwinPthreadHandlerRec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(DarwinPthreadHandlerRec))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(DarwinPthreadHandlerRec))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl DarwinPthreadHandlerRec {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(__darwin_pthread_handler_rec)
                );
                let inst: __darwin_pthread_handler_rec = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut __darwin_pthread_handler_rec = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(__darwin_pthread_handler_rec)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut __darwin_pthread_handler_rec {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut __darwin_pthread_handler_rec {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &__darwin_pthread_handler_rec {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for DarwinPthreadHandlerRec {
    type Target = __darwin_pthread_handler_rec;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut __darwin_pthread_handler_rec> for DarwinPthreadHandlerRec {
    #[inline]
    fn from(value: *mut __darwin_pthread_handler_rec) -> Self {
        DarwinPthreadHandlerRec {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<DarwinPthreadHandlerRec> for *mut __darwin_pthread_handler_rec {
    #[inline]
    fn from(value: DarwinPthreadHandlerRec) -> Self {
        value.get_inner()
    }
}
impl From<&DarwinPthreadHandlerRec> for *mut __darwin_pthread_handler_rec {
    #[inline]
    fn from(value: &DarwinPthreadHandlerRec) -> Self {
        value.get_inner()
    }
}
impl From<DarwinPthreadHandlerRec> for __darwin_pthread_handler_rec {
    #[inline]
    fn from(value: DarwinPthreadHandlerRec) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const __darwin_pthread_handler_rec> for DarwinPthreadHandlerRec {
    #[inline]
    fn from(value: *const __darwin_pthread_handler_rec) -> Self {
        DarwinPthreadHandlerRec {
            inner: CResource::Borrowed(value as *mut __darwin_pthread_handler_rec),
        }
    }
}
impl From<__darwin_pthread_handler_rec> for DarwinPthreadHandlerRec {
    #[inline]
    fn from(value: __darwin_pthread_handler_rec) -> Self {
        DarwinPthreadHandlerRec {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
use crate::AeronErrorType::Unknown;
#[cfg(feature = "backtrace")]
use std::backtrace::Backtrace;
use std::cell::UnsafeCell;
use std::fmt::Formatter;
use std::mem::MaybeUninit;
use std::ops::{Deref, DerefMut};
pub enum CResource<T> {
    OwnedOnHeap(std::rc::Rc<ManagedCResource<T>>),
    #[doc = " stored on stack, unsafe, use with care"]
    OwnedOnStack(std::mem::MaybeUninit<T>),
    Borrowed(*mut T),
}
impl<T: Clone> Clone for CResource<T> {
    fn clone(&self) -> Self {
        unsafe {
            match self {
                CResource::OwnedOnHeap(r) => CResource::OwnedOnHeap(r.clone()),
                CResource::OwnedOnStack(r) => {
                    CResource::OwnedOnStack(MaybeUninit::new(r.assume_init_ref().clone()))
                }
                CResource::Borrowed(r) => CResource::Borrowed(r.clone()),
            }
        }
    }
}
impl<T> CResource<T> {
    #[inline]
    pub fn get(&self) -> *mut T {
        match self {
            CResource::OwnedOnHeap(r) => r.get(),
            CResource::OwnedOnStack(r) => r.as_ptr() as *mut T,
            CResource::Borrowed(r) => *r,
        }
    }
    #[inline]
    pub fn add_dependency<D: std::any::Any>(&self, dep: D) {
        match self {
            CResource::OwnedOnHeap(r) => r.add_dependency(dep),
            CResource::OwnedOnStack(_) | CResource::Borrowed(_) => {
                unreachable!("only owned on heap")
            }
        }
    }
    #[inline]
    pub fn get_dependency<V: Clone + 'static>(&self) -> Option<V> {
        match self {
            CResource::OwnedOnHeap(r) => r.get_dependency(),
            CResource::OwnedOnStack(_) | CResource::Borrowed(_) => None,
        }
    }
    #[inline]
    pub fn as_owned(&self) -> Option<&std::rc::Rc<ManagedCResource<T>>> {
        match self {
            CResource::OwnedOnHeap(r) => Some(r),
            CResource::OwnedOnStack(_) | CResource::Borrowed(_) => None,
        }
    }
}
impl<T> std::fmt::Debug for CResource<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let name = std::any::type_name::<T>();
        match self {
            CResource::OwnedOnHeap(r) => {
                write!(f, "{name} heap({:?})", r)
            }
            CResource::OwnedOnStack(r) => {
                write!(f, "{name} stack({:?})", *r)
            }
            CResource::Borrowed(r) => {
                write!(f, "{name} borrowed ({:?})", r)
            }
        }
    }
}
#[doc = " A custom struct for managing C resources with automatic cleanup."]
#[doc = ""]
#[doc = " It handles initialisation and clean-up of the resource and ensures that resources"]
#[doc = " are properly released when they go out of scope."]
#[allow(dead_code)]
pub struct ManagedCResource<T> {
    resource: *mut T,
    cleanup: Option<Box<dyn FnMut(*mut *mut T) -> i32>>,
    cleanup_struct: bool,
    #[doc = " if someone externally rusteron calls close"]
    close_already_called: std::cell::Cell<bool>,
    #[doc = " if there is a c method to verify it someone has closed it, only few structs have this functionality"]
    check_for_is_closed: Option<fn(*mut T) -> bool>,
    #[doc = " this will be called if closed hasn't already happened even if its borrowed"]
    auto_close: std::cell::Cell<bool>,
    #[doc = " to prevent the dependencies from being dropped as you have a copy here,"]
    #[doc = " for example, you want to have a dependency to aeron for any async jobs so aeron doesnt get dropped first"]
    #[doc = " when you have a publication/subscription"]
    #[doc = " Note empty vec does not allocate on heap"]
    dependencies: UnsafeCell<Vec<std::rc::Rc<dyn std::any::Any>>>,
}
impl<T> std::fmt::Debug for ManagedCResource<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedCResource");
        if !self.close_already_called.get()
            && !self.resource.is_null()
            && !self
                .check_for_is_closed
                .as_ref()
                .map_or(false, |f| f(self.resource))
        {
            debug_struct.field("resource", &self.resource);
        }
        debug_struct
            .field("type", &std::any::type_name::<T>())
            .finish()
    }
}
impl<T> ManagedCResource<T> {
    #[doc = " Creates a new ManagedCResource with a given initializer and cleanup function."]
    #[doc = ""]
    #[doc = " The initializer is a closure that attempts to initialize the resource."]
    #[doc = " If initialization fails, the initializer should return an error code."]
    #[doc = " The cleanup function is used to release the resource when it's no longer needed."]
    #[doc = " `cleanup_struct` where it should clean up the struct in rust"]
    pub fn new(
        init: impl FnOnce(*mut *mut T) -> i32,
        cleanup: Option<Box<dyn FnMut(*mut *mut T) -> i32>>,
        cleanup_struct: bool,
        check_for_is_closed: Option<fn(*mut T) -> bool>,
    ) -> Result<Self, AeronCError> {
        let resource = Self::initialise(init)?;
        let result = Self {
            resource,
            cleanup,
            cleanup_struct,
            close_already_called: std::cell::Cell::new(false),
            check_for_is_closed,
            auto_close: std::cell::Cell::new(false),
            dependencies: UnsafeCell::new(vec![]),
        };
        #[cfg(feature = "extra-logging")]
        log::info!("created c resource: {:?}", result);
        Ok(result)
    }
    pub fn initialise(
        init: impl FnOnce(*mut *mut T) -> i32 + Sized,
    ) -> Result<*mut T, AeronCError> {
        let mut resource: *mut T = std::ptr::null_mut();
        let result = init(&mut resource);
        if result < 0 || resource.is_null() {
            return Err(AeronCError::from_code(result));
        }
        Ok(resource)
    }
    pub fn is_closed_already_called(&self) -> bool {
        self.close_already_called.get()
            || self.resource.is_null()
            || self
                .check_for_is_closed
                .as_ref()
                .map_or(false, |f| f(self.resource))
    }
    #[doc = " Gets a raw pointer to the resource."]
    #[inline(always)]
    pub fn get(&self) -> *mut T {
        self.resource
    }
    #[inline(always)]
    pub fn get_mut(&self) -> &mut T {
        unsafe { &mut *self.resource }
    }
    #[inline]
    pub fn add_dependency<D: std::any::Any>(&self, dep: D) {
        if let Some(dep) =
            (&dep as &dyn std::any::Any).downcast_ref::<std::rc::Rc<dyn std::any::Any>>()
        {
            unsafe {
                (*self.dependencies.get()).push(dep.clone());
            }
        } else {
            unsafe {
                (*self.dependencies.get()).push(std::rc::Rc::new(dep));
            }
        }
    }
    #[inline]
    pub fn get_dependency<V: Clone + 'static>(&self) -> Option<V> {
        unsafe {
            (*self.dependencies.get())
                .iter()
                .filter_map(|x| x.as_ref().downcast_ref::<V>().cloned())
                .next()
        }
    }
    #[doc = " Closes the resource by calling the cleanup function."]
    #[doc = ""]
    #[doc = " If cleanup fails, it returns an `AeronError`."]
    pub fn close(&mut self) -> Result<(), AeronCError> {
        if self.close_already_called.get() {
            return Ok(());
        }
        self.close_already_called.set(true);
        let already_closed = self
            .check_for_is_closed
            .as_ref()
            .map_or(false, |f| f(self.resource));
        if let Some(mut cleanup) = self.cleanup.take() {
            if !self.resource.is_null() {
                if !already_closed {
                    let result = cleanup(&mut self.resource);
                    if result < 0 {
                        return Err(AeronCError::from_code(result));
                    }
                }
                self.resource = std::ptr::null_mut();
            }
        }
        Ok(())
    }
}
impl<T> Drop for ManagedCResource<T> {
    fn drop(&mut self) {
        if !self.resource.is_null() {
            let already_closed = self.close_already_called.get()
                || self
                    .check_for_is_closed
                    .as_ref()
                    .map_or(false, |f| f(self.resource));
            let resource = if already_closed {
                self.resource
            } else {
                self.resource.clone()
            };
            if !already_closed {
                #[cfg(feature = "extra-logging")]
                log::info!("closing c resource: {:?}", self);
                let _ = self.close();
            }
            self.close_already_called.set(true);
            if self.cleanup_struct {
                #[cfg(feature = "extra-logging")]
                log::info!("closing rust struct resource: {:?}", resource);
                unsafe {
                    let _ = Box::from_raw(resource);
                }
            }
        }
    }
}
#[derive(Debug, PartialOrd, Eq, PartialEq, Clone)]
pub enum AeronErrorType {
    GenericError,
    ClientErrorDriverTimeout,
    ClientErrorClientTimeout,
    ClientErrorConductorServiceTimeout,
    ClientErrorBufferFull,
    PublicationBackPressured,
    PublicationAdminAction,
    PublicationClosed,
    PublicationMaxPositionExceeded,
    PublicationError,
    TimedOut,
    Unknown(i32),
}
impl From<AeronErrorType> for AeronCError {
    fn from(value: AeronErrorType) -> Self {
        AeronCError::from_code(value.code())
    }
}
impl AeronErrorType {
    pub fn code(&self) -> i32 {
        match self {
            AeronErrorType::GenericError => -1,
            AeronErrorType::ClientErrorDriverTimeout => -1000,
            AeronErrorType::ClientErrorClientTimeout => -1001,
            AeronErrorType::ClientErrorConductorServiceTimeout => -1002,
            AeronErrorType::ClientErrorBufferFull => -1003,
            AeronErrorType::PublicationBackPressured => -2,
            AeronErrorType::PublicationAdminAction => -3,
            AeronErrorType::PublicationClosed => -4,
            AeronErrorType::PublicationMaxPositionExceeded => -5,
            AeronErrorType::PublicationError => -6,
            AeronErrorType::TimedOut => -234324,
            AeronErrorType::Unknown(code) => *code,
        }
    }
    pub fn is_back_pressured(&self) -> bool {
        self == &AeronErrorType::PublicationBackPressured
    }
    pub fn is_admin_action(&self) -> bool {
        self == &AeronErrorType::PublicationAdminAction
    }
    pub fn is_back_pressured_or_admin_action(&self) -> bool {
        self.is_back_pressured() || self.is_admin_action()
    }
    pub fn from_code(code: i32) -> Self {
        match code {
            -1 => AeronErrorType::GenericError,
            -1000 => AeronErrorType::ClientErrorDriverTimeout,
            -1001 => AeronErrorType::ClientErrorClientTimeout,
            -1002 => AeronErrorType::ClientErrorConductorServiceTimeout,
            -1003 => AeronErrorType::ClientErrorBufferFull,
            -2 => AeronErrorType::PublicationBackPressured,
            -3 => AeronErrorType::PublicationAdminAction,
            -4 => AeronErrorType::PublicationClosed,
            -5 => AeronErrorType::PublicationMaxPositionExceeded,
            -6 => AeronErrorType::PublicationError,
            -234324 => AeronErrorType::TimedOut,
            _ => Unknown(code),
        }
    }
    pub fn to_string(&self) -> &'static str {
        match self {
            AeronErrorType::GenericError => "Generic Error",
            AeronErrorType::ClientErrorDriverTimeout => "Client Error Driver Timeout",
            AeronErrorType::ClientErrorClientTimeout => "Client Error Client Timeout",
            AeronErrorType::ClientErrorConductorServiceTimeout => {
                "Client Error Conductor Service Timeout"
            }
            AeronErrorType::ClientErrorBufferFull => "Client Error Buffer Full",
            AeronErrorType::PublicationBackPressured => "Publication Back Pressured",
            AeronErrorType::PublicationAdminAction => "Publication Admin Action",
            AeronErrorType::PublicationClosed => "Publication Closed",
            AeronErrorType::PublicationMaxPositionExceeded => "Publication Max Position Exceeded",
            AeronErrorType::PublicationError => "Publication Error",
            AeronErrorType::TimedOut => "Timed Out",
            AeronErrorType::Unknown(_) => "Unknown Error",
        }
    }
}
#[doc = " Represents an Aeron-specific error with a code and an optional message."]
#[doc = ""]
#[doc = " The error code is derived from Aeron C API calls."]
#[doc = " Use `get_last_err_message()` to retrieve the last human-readable message, if available."]
#[derive(Eq, PartialEq, Clone)]
pub struct AeronCError {
    pub code: i32,
}
impl AeronCError {
    #[doc = " Creates an AeronError from the error code returned by Aeron."]
    #[doc = ""]
    #[doc = " Error codes below zero are considered failure."]
    pub fn from_code(code: i32) -> Self {
        #[cfg(feature = "backtrace")]
        {
            if code < 0 {
                let backtrace = Backtrace::capture();
                let backtrace = format!("{:?}", backtrace);
                let re =
                    regex::Regex::new(r#"fn: "([^"]+)", file: "([^"]+)", line: (\d+)"#).unwrap();
                let mut lines = String::new();
                re.captures_iter(&backtrace).for_each(|cap| {
                    let function = &cap[1];
                    let mut file = cap[2].to_string();
                    let line = &cap[3];
                    if file.starts_with("./") {
                        file = format!("{}/{}", env!("CARGO_MANIFEST_DIR"), &file[2..]);
                    } else if file.starts_with("/rustc/") {
                        file = file.split("/").last().unwrap().to_string();
                    }
                    lines.push_str(&format!(" {file}:{line} in {function}\n"));
                });
                log::error!(
                    "Aeron C error code: {}, kind: '{:?}'\n{}",
                    code,
                    AeronErrorType::from_code(code),
                    lines
                );
            }
        }
        AeronCError { code }
    }
    pub fn kind(&self) -> AeronErrorType {
        AeronErrorType::from_code(self.code)
    }
    pub fn is_back_pressured(&self) -> bool {
        self.kind().is_back_pressured()
    }
    pub fn is_admin_action(&self) -> bool {
        self.kind().is_admin_action()
    }
    pub fn is_back_pressured_or_admin_action(&self) -> bool {
        self.kind().is_back_pressured_or_admin_action()
    }
}
#[doc = " # Handler"]
#[doc = ""]
#[doc = " `Handler` is a struct that wraps a raw pointer and a drop flag."]
#[doc = ""]
#[doc = " **Important:** `Handler` *MAY* not get dropped automatically. It depends if aeron takes ownership."]
#[doc = " For example for global level handlers e.g. error handler aeron will release this handle when closing."]
#[doc = ""]
#[doc = " You need to call the `release` method if you want to clear the memory manually."]
#[doc = " Its important that you test this out as aeron may do it when closing aeron client."]
#[doc = ""]
#[doc = " ## Example"]
#[doc = ""]
#[doc = " ```no_compile"]
#[doc = " use rusteron_code_gen::Handler;"]
#[doc = " let handler = Handler::leak(your_value);"]
#[doc = " // When you are done with the handler"]
#[doc = " handler.release();"]
#[doc = " ```"]
pub struct Handler<T> {
    raw_ptr: *mut T,
    should_drop: bool,
}
unsafe impl<T> Send for Handler<T> {}
unsafe impl<T> Sync for Handler<T> {}
#[doc = " Utility method for setting empty handlers"]
pub struct Handlers;
impl<T> Handler<T> {
    pub fn leak(handler: T) -> Self {
        let raw_ptr = Box::into_raw(Box::new(handler)) as *mut _;
        #[cfg(feature = "extra-logging")]
        log::info!("creating handler {:?}", raw_ptr);
        Self {
            raw_ptr,
            should_drop: true,
        }
    }
    pub fn is_none(&self) -> bool {
        self.raw_ptr.is_null()
    }
    pub fn as_raw(&self) -> *mut std::os::raw::c_void {
        self.raw_ptr as *mut std::os::raw::c_void
    }
    pub fn release(&mut self) {
        if self.should_drop && !self.raw_ptr.is_null() {
            unsafe {
                #[cfg(feature = "extra-logging")]
                log::info!("dropping handler {:?}", self.raw_ptr);
                let _ = Box::from_raw(self.raw_ptr as *mut T);
                self.should_drop = false;
            }
        }
    }
    pub unsafe fn new(raw_ptr: *mut T, should_drop: bool) -> Self {
        Self {
            raw_ptr,
            should_drop,
        }
    }
}
impl<T> Deref for Handler<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        unsafe { &*self.raw_ptr as &T }
    }
}
impl<T> DerefMut for Handler<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *self.raw_ptr as &mut T }
    }
}
pub fn find_unused_udp_port(start_port: u16) -> Option<u16> {
    let end_port = u16::MAX;
    for port in start_port..=end_port {
        if is_udp_port_available(port) {
            return Some(port);
        }
    }
    None
}
pub fn is_udp_port_available(port: u16) -> bool {
    std::net::UdpSocket::bind(("127.0.0.1", port)).is_ok()
}
#[doc = " Represents the Aeron URI parser and handler."]
pub struct ChannelUri {}
impl ChannelUri {
    pub const AERON_SCHEME: &'static str = "aeron";
    pub const SPY_QUALIFIER: &'static str = "aeron-spy";
    pub const MAX_URI_LENGTH: usize = 4095;
}
pub const DRIVER_TIMEOUT_MS_DEFAULT: u64 = 10_000;
pub const AERON_DIR_PROP_NAME: &str = "aeron.dir";
pub const AERON_IPC_MEDIA: &str = "aeron:ipc";
pub const AERON_UDP_MEDIA: &str = "aeron:udp";
pub const SPY_PREFIX: &str = "aeron-spy:";
pub const TAG_PREFIX: &str = "tag:";
#[doc = " Enum for media types."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Media {
    Ipc,
    Udp,
}
impl Media {
    pub fn as_str(&self) -> &'static str {
        match self {
            Media::Ipc => "ipc",
            Media::Udp => "udp",
        }
    }
}
#[doc = " Enum for control modes."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ControlMode {
    Manual,
    Dynamic,
    #[doc = " this is a beta feature useful when dealing with docker containers and networking"]
    Response,
}
impl ControlMode {
    pub fn as_str(&self) -> &'static str {
        match self {
            ControlMode::Manual => "manual",
            ControlMode::Dynamic => "dynamic",
            ControlMode::Response => "response",
        }
    }
}
#[cfg(test)]
#[allow(dead_code)]
pub(crate) mod test_alloc {
    use std::alloc::{GlobalAlloc, Layout, System};
    use std::sync::atomic::{AtomicIsize, Ordering};
    #[doc = " A simple global allocator that tracks the net allocation count."]
    #[doc = " For very simple examples can do allocation count before and after your test."]
    #[doc = " This does not work well with logger, running media driver, etc. Only for the most"]
    #[doc = " basic controlled examples"]
    pub struct CountingAllocator {
        allocs: AtomicIsize,
    }
    impl CountingAllocator {
        pub const fn new() -> Self {
            Self {
                allocs: AtomicIsize::new(0),
            }
        }
        #[doc = " Returns the current allocation counter value."]
        fn current(&self) -> isize {
            self.allocs.load(Ordering::SeqCst)
        }
    }
    unsafe impl GlobalAlloc for CountingAllocator {
        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
            self.allocs.fetch_add(1, Ordering::SeqCst);
            System.alloc(layout)
        }
        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
            self.allocs.fetch_sub(1, Ordering::SeqCst);
            System.dealloc(ptr, layout)
        }
    }
    #[global_allocator]
    static GLOBAL: CountingAllocator = CountingAllocator::new();
    #[doc = " Returns the current allocation counter value."]
    pub fn current_allocs() -> isize {
        GLOBAL.current()
    }
}
pub trait IntoCString {
    fn into_c_string(self) -> std::ffi::CString;
}
impl IntoCString for std::ffi::CString {
    fn into_c_string(self) -> std::ffi::CString {
        self
    }
}
impl IntoCString for &str {
    fn into_c_string(self) -> std::ffi::CString {
        #[cfg(feature = "extra-logging")]
        log::info!("created c string on heap: {:?}", self);
        std::ffi::CString::new(self).expect("failed to create CString")
    }
}
impl IntoCString for String {
    fn into_c_string(self) -> std::ffi::CString {
        #[cfg(feature = "extra-logging")]
        log::info!("created c string on heap: {:?}", self);
        std::ffi::CString::new(self).expect("failed to create CString")
    }
}
#[derive(Clone)]
pub struct OpaquePthreadAttr {
    inner: CResource<_opaque_pthread_attr_t>,
}
impl core::fmt::Debug for OpaquePthreadAttr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(OpaquePthreadAttr))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(OpaquePthreadAttr))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl OpaquePthreadAttr {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(_opaque_pthread_attr_t)
                );
                let inst: _opaque_pthread_attr_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut _opaque_pthread_attr_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(_opaque_pthread_attr_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut _opaque_pthread_attr_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut _opaque_pthread_attr_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &_opaque_pthread_attr_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for OpaquePthreadAttr {
    type Target = _opaque_pthread_attr_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut _opaque_pthread_attr_t> for OpaquePthreadAttr {
    #[inline]
    fn from(value: *mut _opaque_pthread_attr_t) -> Self {
        OpaquePthreadAttr {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<OpaquePthreadAttr> for *mut _opaque_pthread_attr_t {
    #[inline]
    fn from(value: OpaquePthreadAttr) -> Self {
        value.get_inner()
    }
}
impl From<&OpaquePthreadAttr> for *mut _opaque_pthread_attr_t {
    #[inline]
    fn from(value: &OpaquePthreadAttr) -> Self {
        value.get_inner()
    }
}
impl From<OpaquePthreadAttr> for _opaque_pthread_attr_t {
    #[inline]
    fn from(value: OpaquePthreadAttr) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const _opaque_pthread_attr_t> for OpaquePthreadAttr {
    #[inline]
    fn from(value: *const _opaque_pthread_attr_t) -> Self {
        OpaquePthreadAttr {
            inner: CResource::Borrowed(value as *mut _opaque_pthread_attr_t),
        }
    }
}
impl From<_opaque_pthread_attr_t> for OpaquePthreadAttr {
    #[inline]
    fn from(value: _opaque_pthread_attr_t) -> Self {
        OpaquePthreadAttr {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct OpaquePthreadCond {
    inner: CResource<_opaque_pthread_cond_t>,
}
impl core::fmt::Debug for OpaquePthreadCond {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(OpaquePthreadCond))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(OpaquePthreadCond))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl OpaquePthreadCond {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(_opaque_pthread_cond_t)
                );
                let inst: _opaque_pthread_cond_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut _opaque_pthread_cond_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(_opaque_pthread_cond_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut _opaque_pthread_cond_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut _opaque_pthread_cond_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &_opaque_pthread_cond_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for OpaquePthreadCond {
    type Target = _opaque_pthread_cond_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut _opaque_pthread_cond_t> for OpaquePthreadCond {
    #[inline]
    fn from(value: *mut _opaque_pthread_cond_t) -> Self {
        OpaquePthreadCond {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<OpaquePthreadCond> for *mut _opaque_pthread_cond_t {
    #[inline]
    fn from(value: OpaquePthreadCond) -> Self {
        value.get_inner()
    }
}
impl From<&OpaquePthreadCond> for *mut _opaque_pthread_cond_t {
    #[inline]
    fn from(value: &OpaquePthreadCond) -> Self {
        value.get_inner()
    }
}
impl From<OpaquePthreadCond> for _opaque_pthread_cond_t {
    #[inline]
    fn from(value: OpaquePthreadCond) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const _opaque_pthread_cond_t> for OpaquePthreadCond {
    #[inline]
    fn from(value: *const _opaque_pthread_cond_t) -> Self {
        OpaquePthreadCond {
            inner: CResource::Borrowed(value as *mut _opaque_pthread_cond_t),
        }
    }
}
impl From<_opaque_pthread_cond_t> for OpaquePthreadCond {
    #[inline]
    fn from(value: _opaque_pthread_cond_t) -> Self {
        OpaquePthreadCond {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct OpaquePthreadMutex {
    inner: CResource<_opaque_pthread_mutex_t>,
}
impl core::fmt::Debug for OpaquePthreadMutex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(OpaquePthreadMutex))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(OpaquePthreadMutex))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl OpaquePthreadMutex {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(_opaque_pthread_mutex_t)
                );
                let inst: _opaque_pthread_mutex_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut _opaque_pthread_mutex_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(_opaque_pthread_mutex_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut _opaque_pthread_mutex_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut _opaque_pthread_mutex_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &_opaque_pthread_mutex_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for OpaquePthreadMutex {
    type Target = _opaque_pthread_mutex_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut _opaque_pthread_mutex_t> for OpaquePthreadMutex {
    #[inline]
    fn from(value: *mut _opaque_pthread_mutex_t) -> Self {
        OpaquePthreadMutex {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<OpaquePthreadMutex> for *mut _opaque_pthread_mutex_t {
    #[inline]
    fn from(value: OpaquePthreadMutex) -> Self {
        value.get_inner()
    }
}
impl From<&OpaquePthreadMutex> for *mut _opaque_pthread_mutex_t {
    #[inline]
    fn from(value: &OpaquePthreadMutex) -> Self {
        value.get_inner()
    }
}
impl From<OpaquePthreadMutex> for _opaque_pthread_mutex_t {
    #[inline]
    fn from(value: OpaquePthreadMutex) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const _opaque_pthread_mutex_t> for OpaquePthreadMutex {
    #[inline]
    fn from(value: *const _opaque_pthread_mutex_t) -> Self {
        OpaquePthreadMutex {
            inner: CResource::Borrowed(value as *mut _opaque_pthread_mutex_t),
        }
    }
}
impl From<_opaque_pthread_mutex_t> for OpaquePthreadMutex {
    #[inline]
    fn from(value: _opaque_pthread_mutex_t) -> Self {
        OpaquePthreadMutex {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct OpaquePthread {
    inner: CResource<_opaque_pthread_t>,
}
impl core::fmt::Debug for OpaquePthread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(OpaquePthread))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(OpaquePthread))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl OpaquePthread {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(_opaque_pthread_t)
                );
                let inst: _opaque_pthread_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut _opaque_pthread_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(_opaque_pthread_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut _opaque_pthread_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut _opaque_pthread_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &_opaque_pthread_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for OpaquePthread {
    type Target = _opaque_pthread_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut _opaque_pthread_t> for OpaquePthread {
    #[inline]
    fn from(value: *mut _opaque_pthread_t) -> Self {
        OpaquePthread {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<OpaquePthread> for *mut _opaque_pthread_t {
    #[inline]
    fn from(value: OpaquePthread) -> Self {
        value.get_inner()
    }
}
impl From<&OpaquePthread> for *mut _opaque_pthread_t {
    #[inline]
    fn from(value: &OpaquePthread) -> Self {
        value.get_inner()
    }
}
impl From<OpaquePthread> for _opaque_pthread_t {
    #[inline]
    fn from(value: OpaquePthread) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const _opaque_pthread_t> for OpaquePthread {
    #[inline]
    fn from(value: *const _opaque_pthread_t) -> Self {
        OpaquePthread {
            inner: CResource::Borrowed(value as *mut _opaque_pthread_t),
        }
    }
}
impl From<_opaque_pthread_t> for OpaquePthread {
    #[inline]
    fn from(value: _opaque_pthread_t) -> Self {
        OpaquePthread {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct Addrinfo {
    inner: CResource<addrinfo>,
}
impl core::fmt::Debug for Addrinfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Addrinfo))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Addrinfo))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Addrinfo {
    #[inline]
    pub fn new(
        ai_flags: ::std::os::raw::c_int,
        ai_family: ::std::os::raw::c_int,
        ai_socktype: ::std::os::raw::c_int,
        ai_protocol: ::std::os::raw::c_int,
        ai_addrlen: socklen_t,
        ai_canonname: *mut ::std::os::raw::c_char,
        ai_addr: &Sockaddr,
        ai_next: &Addrinfo,
    ) -> Result<Self, AeronCError> {
        let ai_addr_copy = ai_addr.clone();
        let ai_next_copy = ai_next.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = addrinfo {
                    ai_flags: ai_flags.into(),
                    ai_family: ai_family.into(),
                    ai_socktype: ai_socktype.into(),
                    ai_protocol: ai_protocol.into(),
                    ai_addrlen: ai_addrlen.into(),
                    ai_canonname: ai_canonname.into(),
                    ai_addr: ai_addr.into(),
                    ai_next: ai_next.into(),
                };
                let inner_ptr: *mut addrinfo = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(addrinfo)
                );
                let inst: addrinfo = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut addrinfo = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(addrinfo)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn ai_flags(&self) -> ::std::os::raw::c_int {
        self.ai_flags.into()
    }
    #[inline]
    pub fn ai_family(&self) -> ::std::os::raw::c_int {
        self.ai_family.into()
    }
    #[inline]
    pub fn ai_socktype(&self) -> ::std::os::raw::c_int {
        self.ai_socktype.into()
    }
    #[inline]
    pub fn ai_protocol(&self) -> ::std::os::raw::c_int {
        self.ai_protocol.into()
    }
    #[inline]
    pub fn ai_addrlen(&self) -> socklen_t {
        self.ai_addrlen.into()
    }
    #[inline]
    pub fn ai_canonname(&self) -> &str {
        if self.ai_canonname.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.ai_canonname)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn ai_addr(&self) -> Sockaddr {
        self.ai_addr.into()
    }
    #[inline]
    pub fn ai_next(&self) -> Addrinfo {
        self.ai_next.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut addrinfo {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut addrinfo {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &addrinfo {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Addrinfo {
    type Target = addrinfo;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut addrinfo> for Addrinfo {
    #[inline]
    fn from(value: *mut addrinfo) -> Self {
        Addrinfo {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Addrinfo> for *mut addrinfo {
    #[inline]
    fn from(value: Addrinfo) -> Self {
        value.get_inner()
    }
}
impl From<&Addrinfo> for *mut addrinfo {
    #[inline]
    fn from(value: &Addrinfo) -> Self {
        value.get_inner()
    }
}
impl From<Addrinfo> for addrinfo {
    #[inline]
    fn from(value: Addrinfo) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const addrinfo> for Addrinfo {
    #[inline]
    fn from(value: *const addrinfo) -> Self {
        Addrinfo {
            inner: CResource::Borrowed(value as *mut addrinfo),
        }
    }
}
impl From<addrinfo> for Addrinfo {
    #[inline]
    fn from(value: addrinfo) -> Self {
        Addrinfo {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Addrinfo {
    fn default() -> Self {
        Addrinfo::new_zeroed_on_heap()
    }
}
impl Addrinfo {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronAgentRunner {
    inner: CResource<aeron_agent_runner_t>,
}
impl core::fmt::Debug for AeronAgentRunner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAgentRunner))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAgentRunner))
                .field("inner", &self.inner)
                .field(stringify!(running), &self.running())
                .finish()
        }
    }
}
impl AeronAgentRunner {
    #[inline]
    pub fn new(
        role_name: &std::ffi::CStr,
        agent_state: *mut ::std::os::raw::c_void,
        idle_strategy_state: *mut ::std::os::raw::c_void,
        on_start_state: *mut ::std::os::raw::c_void,
        on_start: aeron_agent_on_start_func_t,
        do_work: aeron_agent_do_work_func_t,
        on_close: aeron_agent_on_close_func_t,
        idle_strategy: aeron_idle_strategy_func_t,
        thread: aeron_thread_t,
        running: bool,
        state: u8,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_agent_runner_t {
                    role_name: role_name.as_ptr(),
                    agent_state: agent_state.into(),
                    idle_strategy_state: idle_strategy_state.into(),
                    on_start_state: on_start_state.into(),
                    on_start: on_start.into(),
                    do_work: do_work.into(),
                    on_close: on_close.into(),
                    idle_strategy: idle_strategy.into(),
                    thread: thread.into(),
                    running: running.into(),
                    state: state.into(),
                };
                let inner_ptr: *mut aeron_agent_runner_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_agent_runner_t)
                );
                let inst: aeron_agent_runner_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_agent_runner_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_agent_runner_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn role_name(&self) -> &str {
        if self.role_name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.role_name).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn agent_state(&self) -> *mut ::std::os::raw::c_void {
        self.agent_state.into()
    }
    #[inline]
    pub fn idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.idle_strategy_state.into()
    }
    #[inline]
    pub fn on_start_state(&self) -> *mut ::std::os::raw::c_void {
        self.on_start_state.into()
    }
    #[inline]
    pub fn on_start(&self) -> aeron_agent_on_start_func_t {
        self.on_start.into()
    }
    #[inline]
    pub fn do_work(&self) -> aeron_agent_do_work_func_t {
        self.do_work.into()
    }
    #[inline]
    pub fn on_close(&self) -> aeron_agent_on_close_func_t {
        self.on_close.into()
    }
    #[inline]
    pub fn idle_strategy(&self) -> aeron_idle_strategy_func_t {
        self.idle_strategy.into()
    }
    #[inline]
    pub fn thread(&self) -> aeron_thread_t {
        self.thread.into()
    }
    #[inline]
    pub fn running(&self) -> bool {
        self.running.into()
    }
    #[inline]
    pub fn state(&self) -> u8 {
        self.state.into()
    }
    #[inline]
    pub fn aeron_agent_init<
        AeronAgentStartFuncHandlerImpl: AeronAgentStartFuncCallback,
        AeronIdleStrategyFuncHandlerImpl: AeronIdleStrategyFuncCallback,
    >(
        &self,
        role_name: &std::ffi::CStr,
        state: *mut ::std::os::raw::c_void,
        on_start: Option<&Handler<AeronAgentStartFuncHandlerImpl>>,
        do_work: aeron_agent_do_work_func_t,
        on_close: aeron_agent_on_close_func_t,
        idle_strategy_func: Option<&Handler<AeronIdleStrategyFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_agent_init(
                self.get_inner(),
                role_name.as_ptr(),
                state.into(),
                {
                    let callback: aeron_agent_on_start_func_t = if on_start.is_none() {
                        None
                    } else {
                        Some(aeron_agent_on_start_func_t_callback::<AeronAgentStartFuncHandlerImpl>)
                    };
                    callback
                },
                on_start
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                do_work.into(),
                on_close.into(),
                {
                    let callback: aeron_idle_strategy_func_t = if idle_strategy_func.is_none() {
                        None
                    } else {
                        Some(
                            aeron_idle_strategy_func_t_callback::<AeronIdleStrategyFuncHandlerImpl>,
                        )
                    };
                    callback
                },
                idle_strategy_func
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn aeron_agent_init_once<
        AeronAgentStartFuncHandlerImpl: FnMut(&str) -> (),
        AeronIdleStrategyFuncHandlerImpl: FnMut(::std::os::raw::c_int) -> (),
    >(
        &self,
        role_name: &std::ffi::CStr,
        state: *mut ::std::os::raw::c_void,
        mut on_start: AeronAgentStartFuncHandlerImpl,
        do_work: aeron_agent_do_work_func_t,
        on_close: aeron_agent_on_close_func_t,
        mut idle_strategy_func: AeronIdleStrategyFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_agent_init(
                self.get_inner(),
                role_name.as_ptr(),
                state.into(),
                Some(
                    aeron_agent_on_start_func_t_callback_for_once_closure::<
                        AeronAgentStartFuncHandlerImpl,
                    >,
                ),
                &mut on_start as *mut _ as *mut std::os::raw::c_void,
                do_work.into(),
                on_close.into(),
                Some(
                    aeron_idle_strategy_func_t_callback_for_once_closure::<
                        AeronIdleStrategyFuncHandlerImpl,
                    >,
                ),
                &mut idle_strategy_func as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_agent_start(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_agent_start(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_agent_stop(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_agent_stop(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_agent_close(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_agent_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_agent_runner_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_agent_runner_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_agent_runner_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAgentRunner {
    type Target = aeron_agent_runner_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_agent_runner_t> for AeronAgentRunner {
    #[inline]
    fn from(value: *mut aeron_agent_runner_t) -> Self {
        AeronAgentRunner {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAgentRunner> for *mut aeron_agent_runner_t {
    #[inline]
    fn from(value: AeronAgentRunner) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAgentRunner> for *mut aeron_agent_runner_t {
    #[inline]
    fn from(value: &AeronAgentRunner) -> Self {
        value.get_inner()
    }
}
impl From<AeronAgentRunner> for aeron_agent_runner_t {
    #[inline]
    fn from(value: AeronAgentRunner) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_agent_runner_t> for AeronAgentRunner {
    #[inline]
    fn from(value: *const aeron_agent_runner_t) -> Self {
        AeronAgentRunner {
            inner: CResource::Borrowed(value as *mut aeron_agent_runner_t),
        }
    }
}
impl From<aeron_agent_runner_t> for AeronAgentRunner {
    #[inline]
    fn from(value: aeron_agent_runner_t) -> Self {
        AeronAgentRunner {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronAgentRunner {
    fn default() -> Self {
        AeronAgentRunner::new_zeroed_on_heap()
    }
}
impl AeronAgentRunner {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronAsyncAddCounter {
    inner: CResource<aeron_async_add_counter_t>,
}
impl core::fmt::Debug for AeronAsyncAddCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncAddCounter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncAddCounter))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncAddCounter {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_async_add_counter_t)
                );
                let inst: aeron_async_add_counter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_async_add_counter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_async_add_counter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Gets the registration id for addition of the counter. Note that using this after a call to poll the succeeds or"]
    #[doc = " errors is undefined behaviour. As the async_add_counter_t may have been freed."]
    #[doc = ""]
    #[doc = " \n# Return\n registration id for the counter."]
    pub fn get_registration_id(&self) -> i64 {
        unsafe {
            let result = aeron_async_add_counter_get_registration_id(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_add_counter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_add_counter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_add_counter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncAddCounter {
    type Target = aeron_async_add_counter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_add_counter_t> for AeronAsyncAddCounter {
    #[inline]
    fn from(value: *mut aeron_async_add_counter_t) -> Self {
        AeronAsyncAddCounter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncAddCounter> for *mut aeron_async_add_counter_t {
    #[inline]
    fn from(value: AeronAsyncAddCounter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncAddCounter> for *mut aeron_async_add_counter_t {
    #[inline]
    fn from(value: &AeronAsyncAddCounter) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncAddCounter> for aeron_async_add_counter_t {
    #[inline]
    fn from(value: AeronAsyncAddCounter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_add_counter_t> for AeronAsyncAddCounter {
    #[inline]
    fn from(value: *const aeron_async_add_counter_t) -> Self {
        AeronAsyncAddCounter {
            inner: CResource::Borrowed(value as *mut aeron_async_add_counter_t),
        }
    }
}
impl From<aeron_async_add_counter_t> for AeronAsyncAddCounter {
    #[inline]
    fn from(value: aeron_async_add_counter_t) -> Self {
        AeronAsyncAddCounter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl AeronCounter {
    #[inline]
    pub fn new(async_: &AeronAsyncAddCounter) -> Result<Self, AeronCError> {
        let resource = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_async_add_counter_poll(ctx_field, async_.into()) },
            None,
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        })
    }
}
impl Aeron {
    #[inline]
    pub fn async_add_counter(
        &self,
        type_id: i32,
        key_buffer: &[u8],
        label_buffer: &str,
    ) -> Result<AeronAsyncAddCounter, AeronCError> {
        let mut result = AeronAsyncAddCounter::new(self, type_id, key_buffer, label_buffer);
        if let Ok(result) = &mut result {
            result.inner.add_dependency(self.clone());
        }
        result
    }
}
impl Aeron {
    #[inline]
    pub fn add_counter(
        &self,
        type_id: i32,
        key_buffer: &[u8],
        label_buffer: &str,
        timeout: std::time::Duration,
    ) -> Result<AeronCounter, AeronCError> {
        let start = std::time::Instant::now();
        loop {
            if let Ok(poller) = AeronAsyncAddCounter::new(self, type_id, key_buffer, label_buffer) {
                while start.elapsed() <= timeout {
                    if let Some(result) = poller.poll()? {
                        return Ok(result);
                    }
                    #[cfg(debug_assertions)]
                    std::thread::sleep(std::time::Duration::from_millis(10));
                }
            }
            if start.elapsed() > timeout {
                log::error!("failed async poll for {:?}", self);
                return Err(AeronErrorType::TimedOut.into());
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
    }
}
impl AeronAsyncAddCounter {
    #[inline]
    pub fn new(
        client: &Aeron,
        type_id: i32,
        key_buffer: &[u8],
        label_buffer: &str,
    ) -> Result<Self, AeronCError> {
        let resource_async = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_async_add_counter(
                    ctx_field,
                    client.into(),
                    type_id.into(),
                    key_buffer.as_ptr() as *mut _,
                    key_buffer.len(),
                    label_buffer.as_ptr() as *const _,
                    label_buffer.len(),
                )
            },
            None,
            false,
            None,
        )?;
        let result = Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_async)),
        };
        result.inner.add_dependency(client.clone());
        Ok(result)
    }
    pub fn poll(&self) -> Result<Option<AeronCounter>, AeronCError> {
        let mut result = AeronCounter::new(self);
        if let Ok(result) = &mut result {
            unsafe {
                for d in (&mut *self.inner.as_owned().unwrap().dependencies.get()).iter_mut() {
                    result.inner.add_dependency(d.clone());
                }
                result.inner.as_owned().unwrap().auto_close.set(true);
            }
        }
        match result {
            Ok(result) => Ok(Some(result)),
            Err(AeronCError { code }) if code == 0 => Ok(None),
            Err(e) => Err(e),
        }
    }
    pub fn poll_blocking(&self, timeout: std::time::Duration) -> Result<AeronCounter, AeronCError> {
        if let Some(result) = self.poll()? {
            return Ok(result);
        }
        let time = std::time::Instant::now();
        while time.elapsed() < timeout {
            if let Some(result) = self.poll()? {
                return Ok(result);
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
        log::error!("failed async poll for {:?}", self);
        Err(AeronErrorType::TimedOut.into())
    }
}
#[derive(Clone)]
pub struct AeronAsyncAddExclusivePublication {
    inner: CResource<aeron_async_add_exclusive_publication_t>,
}
impl core::fmt::Debug for AeronAsyncAddExclusivePublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncAddExclusivePublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncAddExclusivePublication))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncAddExclusivePublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_async_add_exclusive_publication_t)
                );
                let inst: aeron_async_add_exclusive_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_async_add_exclusive_publication_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_async_add_exclusive_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the"]
    #[doc = " succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed."]
    #[doc = ""]
    #[doc = " \n# Return\n registration id for the exclusive_publication."]
    #[deprecated]
    #[doc = " @deprecated Use aeron_async_add_exclusive_publication_get_registration_id instead."]
    pub fn aeron_async_add_exclusive_exclusive_publication_get_registration_id(&self) -> i64 {
        unsafe {
            let result = aeron_async_add_exclusive_exclusive_publication_get_registration_id(
                self.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the"]
    #[doc = " succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed."]
    #[doc = ""]
    #[doc = " \n# Return\n registration id for the exclusive_publication."]
    pub fn get_registration_id(&self) -> i64 {
        unsafe {
            let result =
                aeron_async_add_exclusive_publication_get_registration_id(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_add_exclusive_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_add_exclusive_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_add_exclusive_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncAddExclusivePublication {
    type Target = aeron_async_add_exclusive_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_add_exclusive_publication_t> for AeronAsyncAddExclusivePublication {
    #[inline]
    fn from(value: *mut aeron_async_add_exclusive_publication_t) -> Self {
        AeronAsyncAddExclusivePublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncAddExclusivePublication> for *mut aeron_async_add_exclusive_publication_t {
    #[inline]
    fn from(value: AeronAsyncAddExclusivePublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncAddExclusivePublication> for *mut aeron_async_add_exclusive_publication_t {
    #[inline]
    fn from(value: &AeronAsyncAddExclusivePublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncAddExclusivePublication> for aeron_async_add_exclusive_publication_t {
    #[inline]
    fn from(value: AeronAsyncAddExclusivePublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_add_exclusive_publication_t> for AeronAsyncAddExclusivePublication {
    #[inline]
    fn from(value: *const aeron_async_add_exclusive_publication_t) -> Self {
        AeronAsyncAddExclusivePublication {
            inner: CResource::Borrowed(value as *mut aeron_async_add_exclusive_publication_t),
        }
    }
}
impl From<aeron_async_add_exclusive_publication_t> for AeronAsyncAddExclusivePublication {
    #[inline]
    fn from(value: aeron_async_add_exclusive_publication_t) -> Self {
        AeronAsyncAddExclusivePublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl AeronExclusivePublication {
    #[inline]
    pub fn new(async_: &AeronAsyncAddExclusivePublication) -> Result<Self, AeronCError> {
        let resource = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_async_add_exclusive_publication_poll(ctx_field, async_.into())
            },
            None,
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        })
    }
}
impl Aeron {
    #[inline]
    pub fn async_add_exclusive_publication(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
    ) -> Result<AeronAsyncAddExclusivePublication, AeronCError> {
        let mut result = AeronAsyncAddExclusivePublication::new(self, uri, stream_id);
        if let Ok(result) = &mut result {
            result.inner.add_dependency(self.clone());
        }
        result
    }
}
impl Aeron {
    #[inline]
    pub fn add_exclusive_publication(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
        timeout: std::time::Duration,
    ) -> Result<AeronExclusivePublication, AeronCError> {
        let start = std::time::Instant::now();
        loop {
            if let Ok(poller) = AeronAsyncAddExclusivePublication::new(self, uri, stream_id) {
                while start.elapsed() <= timeout {
                    if let Some(result) = poller.poll()? {
                        return Ok(result);
                    }
                    #[cfg(debug_assertions)]
                    std::thread::sleep(std::time::Duration::from_millis(10));
                }
            }
            if start.elapsed() > timeout {
                log::error!("failed async poll for {:?}", self);
                return Err(AeronErrorType::TimedOut.into());
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
    }
}
impl AeronAsyncAddExclusivePublication {
    #[inline]
    pub fn new(client: &Aeron, uri: &std::ffi::CStr, stream_id: i32) -> Result<Self, AeronCError> {
        let resource_async = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_async_add_exclusive_publication(
                    ctx_field,
                    client.into(),
                    uri.as_ptr(),
                    stream_id.into(),
                )
            },
            None,
            false,
            None,
        )?;
        let result = Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_async)),
        };
        result.inner.add_dependency(client.clone());
        Ok(result)
    }
    pub fn poll(&self) -> Result<Option<AeronExclusivePublication>, AeronCError> {
        let mut result = AeronExclusivePublication::new(self);
        if let Ok(result) = &mut result {
            unsafe {
                for d in (&mut *self.inner.as_owned().unwrap().dependencies.get()).iter_mut() {
                    result.inner.add_dependency(d.clone());
                }
                result.inner.as_owned().unwrap().auto_close.set(true);
            }
        }
        match result {
            Ok(result) => Ok(Some(result)),
            Err(AeronCError { code }) if code == 0 => Ok(None),
            Err(e) => Err(e),
        }
    }
    pub fn poll_blocking(
        &self,
        timeout: std::time::Duration,
    ) -> Result<AeronExclusivePublication, AeronCError> {
        if let Some(result) = self.poll()? {
            return Ok(result);
        }
        let time = std::time::Instant::now();
        while time.elapsed() < timeout {
            if let Some(result) = self.poll()? {
                return Ok(result);
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
        log::error!("failed async poll for {:?}", self);
        Err(AeronErrorType::TimedOut.into())
    }
}
#[derive(Clone)]
pub struct AeronAsyncAddPublication {
    inner: CResource<aeron_async_add_publication_t>,
}
impl core::fmt::Debug for AeronAsyncAddPublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncAddPublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncAddPublication))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncAddPublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_async_add_publication_t)
                );
                let inst: aeron_async_add_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_async_add_publication_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_async_add_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Gets the registration id for addition of the publication. Note that using this after a call to poll the succeeds or"]
    #[doc = " errors is undefined behaviour. As the async_add_publication_t may have been freed."]
    #[doc = ""]
    #[doc = " \n# Return\n registration id for the publication."]
    pub fn get_registration_id(&self) -> i64 {
        unsafe {
            let result = aeron_async_add_publication_get_registration_id(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_add_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_add_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_add_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncAddPublication {
    type Target = aeron_async_add_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_add_publication_t> for AeronAsyncAddPublication {
    #[inline]
    fn from(value: *mut aeron_async_add_publication_t) -> Self {
        AeronAsyncAddPublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncAddPublication> for *mut aeron_async_add_publication_t {
    #[inline]
    fn from(value: AeronAsyncAddPublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncAddPublication> for *mut aeron_async_add_publication_t {
    #[inline]
    fn from(value: &AeronAsyncAddPublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncAddPublication> for aeron_async_add_publication_t {
    #[inline]
    fn from(value: AeronAsyncAddPublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_add_publication_t> for AeronAsyncAddPublication {
    #[inline]
    fn from(value: *const aeron_async_add_publication_t) -> Self {
        AeronAsyncAddPublication {
            inner: CResource::Borrowed(value as *mut aeron_async_add_publication_t),
        }
    }
}
impl From<aeron_async_add_publication_t> for AeronAsyncAddPublication {
    #[inline]
    fn from(value: aeron_async_add_publication_t) -> Self {
        AeronAsyncAddPublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl AeronPublication {
    #[inline]
    pub fn new(async_: &AeronAsyncAddPublication) -> Result<Self, AeronCError> {
        let resource = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_async_add_publication_poll(ctx_field, async_.into()) },
            None,
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        })
    }
}
impl Aeron {
    #[inline]
    pub fn async_add_publication(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
    ) -> Result<AeronAsyncAddPublication, AeronCError> {
        let mut result = AeronAsyncAddPublication::new(self, uri, stream_id);
        if let Ok(result) = &mut result {
            result.inner.add_dependency(self.clone());
        }
        result
    }
}
impl Aeron {
    #[inline]
    pub fn add_publication(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
        timeout: std::time::Duration,
    ) -> Result<AeronPublication, AeronCError> {
        let start = std::time::Instant::now();
        loop {
            if let Ok(poller) = AeronAsyncAddPublication::new(self, uri, stream_id) {
                while start.elapsed() <= timeout {
                    if let Some(result) = poller.poll()? {
                        return Ok(result);
                    }
                    #[cfg(debug_assertions)]
                    std::thread::sleep(std::time::Duration::from_millis(10));
                }
            }
            if start.elapsed() > timeout {
                log::error!("failed async poll for {:?}", self);
                return Err(AeronErrorType::TimedOut.into());
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
    }
}
impl AeronAsyncAddPublication {
    #[inline]
    pub fn new(client: &Aeron, uri: &std::ffi::CStr, stream_id: i32) -> Result<Self, AeronCError> {
        let resource_async = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_async_add_publication(
                    ctx_field,
                    client.into(),
                    uri.as_ptr(),
                    stream_id.into(),
                )
            },
            None,
            false,
            None,
        )?;
        let result = Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_async)),
        };
        result.inner.add_dependency(client.clone());
        Ok(result)
    }
    pub fn poll(&self) -> Result<Option<AeronPublication>, AeronCError> {
        let mut result = AeronPublication::new(self);
        if let Ok(result) = &mut result {
            unsafe {
                for d in (&mut *self.inner.as_owned().unwrap().dependencies.get()).iter_mut() {
                    result.inner.add_dependency(d.clone());
                }
                result.inner.as_owned().unwrap().auto_close.set(true);
            }
        }
        match result {
            Ok(result) => Ok(Some(result)),
            Err(AeronCError { code }) if code == 0 => Ok(None),
            Err(e) => Err(e),
        }
    }
    pub fn poll_blocking(
        &self,
        timeout: std::time::Duration,
    ) -> Result<AeronPublication, AeronCError> {
        if let Some(result) = self.poll()? {
            return Ok(result);
        }
        let time = std::time::Instant::now();
        while time.elapsed() < timeout {
            if let Some(result) = self.poll()? {
                return Ok(result);
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
        log::error!("failed async poll for {:?}", self);
        Err(AeronErrorType::TimedOut.into())
    }
}
#[derive(Clone)]
pub struct AeronAsyncAddSubscription {
    inner: CResource<aeron_async_add_subscription_t>,
}
impl core::fmt::Debug for AeronAsyncAddSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncAddSubscription))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncAddSubscription))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncAddSubscription {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_async_add_subscription_t)
                );
                let inst: aeron_async_add_subscription_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_async_add_subscription_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_async_add_subscription_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Gets the registration id for addition of the subscription. Note that using this after a call to poll the succeeds or"]
    #[doc = " errors is undefined behaviour. As the async_add_subscription_t may have been freed."]
    #[doc = ""]
    #[doc = " \n# Return\n registration id for the subscription."]
    pub fn get_registration_id(&self) -> i64 {
        unsafe {
            let result = aeron_async_add_subscription_get_registration_id(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_add_subscription_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_add_subscription_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_add_subscription_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncAddSubscription {
    type Target = aeron_async_add_subscription_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_add_subscription_t> for AeronAsyncAddSubscription {
    #[inline]
    fn from(value: *mut aeron_async_add_subscription_t) -> Self {
        AeronAsyncAddSubscription {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncAddSubscription> for *mut aeron_async_add_subscription_t {
    #[inline]
    fn from(value: AeronAsyncAddSubscription) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncAddSubscription> for *mut aeron_async_add_subscription_t {
    #[inline]
    fn from(value: &AeronAsyncAddSubscription) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncAddSubscription> for aeron_async_add_subscription_t {
    #[inline]
    fn from(value: AeronAsyncAddSubscription) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_add_subscription_t> for AeronAsyncAddSubscription {
    #[inline]
    fn from(value: *const aeron_async_add_subscription_t) -> Self {
        AeronAsyncAddSubscription {
            inner: CResource::Borrowed(value as *mut aeron_async_add_subscription_t),
        }
    }
}
impl From<aeron_async_add_subscription_t> for AeronAsyncAddSubscription {
    #[inline]
    fn from(value: aeron_async_add_subscription_t) -> Self {
        AeronAsyncAddSubscription {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl AeronSubscription {
    #[inline]
    pub fn new(async_: &AeronAsyncAddSubscription) -> Result<Self, AeronCError> {
        let resource = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_async_add_subscription_poll(ctx_field, async_.into()) },
            None,
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        })
    }
}
impl Aeron {
    #[inline]
    pub fn async_add_subscription<
        AeronAvailableImageHandlerImpl: AeronAvailableImageCallback,
        AeronUnavailableImageHandlerImpl: AeronUnavailableImageCallback,
    >(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
        on_available_image_handler: Option<&Handler<AeronAvailableImageHandlerImpl>>,
        on_unavailable_image_handler: Option<&Handler<AeronUnavailableImageHandlerImpl>>,
    ) -> Result<AeronAsyncAddSubscription, AeronCError> {
        let mut result = AeronAsyncAddSubscription::new(
            self,
            uri,
            stream_id,
            on_available_image_handler,
            on_unavailable_image_handler,
        );
        if let Ok(result) = &mut result {
            result.inner.add_dependency(self.clone());
        }
        result
    }
}
impl Aeron {
    #[inline]
    pub fn add_subscription<
        AeronAvailableImageHandlerImpl: AeronAvailableImageCallback,
        AeronUnavailableImageHandlerImpl: AeronUnavailableImageCallback,
    >(
        &self,
        uri: &std::ffi::CStr,
        stream_id: i32,
        on_available_image_handler: Option<&Handler<AeronAvailableImageHandlerImpl>>,
        on_unavailable_image_handler: Option<&Handler<AeronUnavailableImageHandlerImpl>>,
        timeout: std::time::Duration,
    ) -> Result<AeronSubscription, AeronCError> {
        let start = std::time::Instant::now();
        loop {
            if let Ok(poller) = AeronAsyncAddSubscription::new(
                self,
                uri,
                stream_id,
                on_available_image_handler,
                on_unavailable_image_handler,
            ) {
                while start.elapsed() <= timeout {
                    if let Some(result) = poller.poll()? {
                        return Ok(result);
                    }
                    #[cfg(debug_assertions)]
                    std::thread::sleep(std::time::Duration::from_millis(10));
                }
            }
            if start.elapsed() > timeout {
                log::error!("failed async poll for {:?}", self);
                return Err(AeronErrorType::TimedOut.into());
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
    }
}
impl AeronAsyncAddSubscription {
    #[inline]
    pub fn new<
        AeronAvailableImageHandlerImpl: AeronAvailableImageCallback,
        AeronUnavailableImageHandlerImpl: AeronUnavailableImageCallback,
    >(
        client: &Aeron,
        uri: &std::ffi::CStr,
        stream_id: i32,
        on_available_image_handler: Option<&Handler<AeronAvailableImageHandlerImpl>>,
        on_unavailable_image_handler: Option<&Handler<AeronUnavailableImageHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let resource_async = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_async_add_subscription(
                    ctx_field,
                    client.into(),
                    uri.as_ptr(),
                    stream_id.into(),
                    {
                        let callback: aeron_on_available_image_t = if on_available_image_handler
                            .is_none()
                        {
                            None
                        } else {
                            Some(
                                aeron_on_available_image_t_callback::<AeronAvailableImageHandlerImpl>,
                            )
                        };
                        callback
                    },
                    on_available_image_handler
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                    {
                        let callback: aeron_on_unavailable_image_t =
                            if on_unavailable_image_handler.is_none() {
                                None
                            } else {
                                Some(
                                    aeron_on_unavailable_image_t_callback::<
                                        AeronUnavailableImageHandlerImpl,
                                    >,
                                )
                            };
                        callback
                    },
                    on_unavailable_image_handler
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                )
            },
            None,
            false,
            None,
        )?;
        let result = Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_async)),
        };
        result.inner.add_dependency(client.clone());
        Ok(result)
    }
    pub fn poll(&self) -> Result<Option<AeronSubscription>, AeronCError> {
        let mut result = AeronSubscription::new(self);
        if let Ok(result) = &mut result {
            unsafe {
                for d in (&mut *self.inner.as_owned().unwrap().dependencies.get()).iter_mut() {
                    result.inner.add_dependency(d.clone());
                }
                result.inner.as_owned().unwrap().auto_close.set(true);
            }
        }
        match result {
            Ok(result) => Ok(Some(result)),
            Err(AeronCError { code }) if code == 0 => Ok(None),
            Err(e) => Err(e),
        }
    }
    pub fn poll_blocking(
        &self,
        timeout: std::time::Duration,
    ) -> Result<AeronSubscription, AeronCError> {
        if let Some(result) = self.poll()? {
            return Ok(result);
        }
        let time = std::time::Instant::now();
        while time.elapsed() < timeout {
            if let Some(result) = self.poll()? {
                return Ok(result);
            }
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_millis(10));
        }
        log::error!("failed async poll for {:?}", self);
        Err(AeronErrorType::TimedOut.into())
    }
}
#[derive(Clone)]
pub struct AeronAsyncDestinationById {
    inner: CResource<aeron_async_destination_by_id_t>,
}
impl core::fmt::Debug for AeronAsyncDestinationById {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncDestinationById))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncDestinationById))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncDestinationById {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_async_destination_by_id_t)
                );
                let inst: aeron_async_destination_by_id_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_async_destination_by_id_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_async_destination_by_id_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_destination_by_id_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_destination_by_id_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_destination_by_id_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncDestinationById {
    type Target = aeron_async_destination_by_id_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_destination_by_id_t> for AeronAsyncDestinationById {
    #[inline]
    fn from(value: *mut aeron_async_destination_by_id_t) -> Self {
        AeronAsyncDestinationById {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncDestinationById> for *mut aeron_async_destination_by_id_t {
    #[inline]
    fn from(value: AeronAsyncDestinationById) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncDestinationById> for *mut aeron_async_destination_by_id_t {
    #[inline]
    fn from(value: &AeronAsyncDestinationById) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncDestinationById> for aeron_async_destination_by_id_t {
    #[inline]
    fn from(value: AeronAsyncDestinationById) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_destination_by_id_t> for AeronAsyncDestinationById {
    #[inline]
    fn from(value: *const aeron_async_destination_by_id_t) -> Self {
        AeronAsyncDestinationById {
            inner: CResource::Borrowed(value as *mut aeron_async_destination_by_id_t),
        }
    }
}
impl From<aeron_async_destination_by_id_t> for AeronAsyncDestinationById {
    #[inline]
    fn from(value: aeron_async_destination_by_id_t) -> Self {
        AeronAsyncDestinationById {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronAsyncDestination {
    inner: CResource<aeron_async_destination_t>,
}
impl core::fmt::Debug for AeronAsyncDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAsyncDestination))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAsyncDestination))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAsyncDestination {
    #[doc = "Add a destination manually to a multi-destination-cast publication."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `publication` to add destination to."]
    #[doc = " \n - `uri` for the destination to add."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn aeron_publication_async_add_destination(
        client: &Aeron,
        publication: &AeronPublication,
        uri: &std::ffi::CStr,
    ) -> Result<Self, AeronCError> {
        let client_copy = client.clone();
        let client: *mut aeron_t = client.into();
        let publication_copy = publication.clone();
        let publication: *mut aeron_publication_t = publication.into();
        let uri: *const ::std::os::raw::c_char = uri.as_ptr();
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_publication_async_add_destination(ctx_field, client, publication, uri)
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_publication_async_remove_destination(
                    ctx_field,
                    client.into(),
                    publication.into(),
                    uri.into(),
                )
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[doc = "Add a destination manually to a multi-destination-cast exclusive publication."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `publication` to add destination to."]
    #[doc = " \n - `uri` for the destination to add."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_add_destination(
        client: &Aeron,
        publication: &AeronExclusivePublication,
        uri: &std::ffi::CStr,
    ) -> Result<Self, AeronCError> {
        let client_copy = client.clone();
        let client: *mut aeron_t = client.into();
        let publication_copy = publication.clone();
        let publication: *mut aeron_exclusive_publication_t = publication.into();
        let uri: *const ::std::os::raw::c_char = uri.as_ptr();
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_exclusive_publication_async_add_destination(
                    ctx_field,
                    client,
                    publication,
                    uri,
                )
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_exclusive_publication_async_remove_destination(
                    ctx_field,
                    client.into(),
                    publication.into(),
                    uri.into(),
                )
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[doc = "Add a destination manually to a multi-destination-subscription."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `subscription` to add destination to."]
    #[doc = " \n - `uri` for the destination to add."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn aeron_subscription_async_add_destination(
        client: &Aeron,
        subscription: &AeronSubscription,
        uri: &std::ffi::CStr,
    ) -> Result<Self, AeronCError> {
        let client_copy = client.clone();
        let client: *mut aeron_t = client.into();
        let subscription_copy = subscription.clone();
        let subscription: *mut aeron_subscription_t = subscription.into();
        let uri: *const ::std::os::raw::c_char = uri.as_ptr();
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_subscription_async_add_destination(ctx_field, client, subscription, uri)
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_subscription_async_remove_destination(
                    ctx_field,
                    client.into(),
                    subscription.into(),
                    uri.into(),
                )
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    #[doc = "Poll the completion of the add/remove of a destination to/from a publication."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_publication_async_destination_poll(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_async_destination_poll(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll the completion of the add/remove of a destination to/from an exclusive publication."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_exclusive_publication_async_destination_poll(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_exclusive_publication_async_destination_poll(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll the completion of add/remove of a destination to/from a subscription."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_subscription_async_destination_poll(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_async_destination_poll(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Gets the registration_id for the destination command supplied. Note that this is the correlation_id used for"]
    #[doc = " the specified destination command, not the registration_id for the original parent resource (publication,"]
    #[doc = " subscription)."]
    #[doc = ""]
    #[doc = " \n# Return\n correlation_id sent to driver."]
    pub fn get_registration_id(&self) -> i64 {
        unsafe {
            let result = aeron_async_destination_get_registration_id(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_async_destination_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_async_destination_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_async_destination_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAsyncDestination {
    type Target = aeron_async_destination_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_async_destination_t> for AeronAsyncDestination {
    #[inline]
    fn from(value: *mut aeron_async_destination_t) -> Self {
        AeronAsyncDestination {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAsyncDestination> for *mut aeron_async_destination_t {
    #[inline]
    fn from(value: AeronAsyncDestination) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAsyncDestination> for *mut aeron_async_destination_t {
    #[inline]
    fn from(value: &AeronAsyncDestination) -> Self {
        value.get_inner()
    }
}
impl From<AeronAsyncDestination> for aeron_async_destination_t {
    #[inline]
    fn from(value: AeronAsyncDestination) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_async_destination_t> for AeronAsyncDestination {
    #[inline]
    fn from(value: *const aeron_async_destination_t) -> Self {
        AeronAsyncDestination {
            inner: CResource::Borrowed(value as *mut aeron_async_destination_t),
        }
    }
}
impl From<aeron_async_destination_t> for AeronAsyncDestination {
    #[inline]
    fn from(value: aeron_async_destination_t) -> Self {
        AeronAsyncDestination {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronAtomicCounter {
    inner: CResource<aeron_atomic_counter_t>,
}
impl core::fmt::Debug for AeronAtomicCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAtomicCounter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAtomicCounter))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAtomicCounter {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_atomic_counter_t)
                );
                let inst: aeron_atomic_counter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_atomic_counter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_atomic_counter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_atomic_counter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_atomic_counter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_atomic_counter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAtomicCounter {
    type Target = aeron_atomic_counter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_atomic_counter_t> for AeronAtomicCounter {
    #[inline]
    fn from(value: *mut aeron_atomic_counter_t) -> Self {
        AeronAtomicCounter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAtomicCounter> for *mut aeron_atomic_counter_t {
    #[inline]
    fn from(value: AeronAtomicCounter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAtomicCounter> for *mut aeron_atomic_counter_t {
    #[inline]
    fn from(value: &AeronAtomicCounter) -> Self {
        value.get_inner()
    }
}
impl From<AeronAtomicCounter> for aeron_atomic_counter_t {
    #[inline]
    fn from(value: AeronAtomicCounter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_atomic_counter_t> for AeronAtomicCounter {
    #[inline]
    fn from(value: *const aeron_atomic_counter_t) -> Self {
        AeronAtomicCounter {
            inner: CResource::Borrowed(value as *mut aeron_atomic_counter_t),
        }
    }
}
impl From<aeron_atomic_counter_t> for AeronAtomicCounter {
    #[inline]
    fn from(value: aeron_atomic_counter_t) -> Self {
        AeronAtomicCounter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronBlockingLinkedQueue {
    inner: CResource<aeron_blocking_linked_queue_t>,
}
impl core::fmt::Debug for AeronBlockingLinkedQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronBlockingLinkedQueue))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronBlockingLinkedQueue))
                .field("inner", &self.inner)
                .field(stringify!(queue), &self.queue())
                .finish()
        }
    }
}
impl AeronBlockingLinkedQueue {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_blocking_linked_queue_t)
                );
                let inst: aeron_blocking_linked_queue_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_blocking_linked_queue_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_blocking_linked_queue_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn queue(&self) -> AeronLinkedQueue {
        self.queue.into()
    }
    #[inline]
    pub fn mutex(&self) -> aeron_mutex_t {
        self.mutex.into()
    }
    #[inline]
    pub fn cv(&self) -> aeron_cond_t {
        self.cv.into()
    }
    #[inline]
    pub fn init(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_blocking_linked_queue_init(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_blocking_linked_queue_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn offer(&self, element: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_blocking_linked_queue_offer(self.get_inner(), element.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn offer_ex(
        &self,
        element: *mut ::std::os::raw::c_void,
        node: &AeronLinkedQueueNode,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_blocking_linked_queue_offer_ex(
                self.get_inner(),
                element.into(),
                node.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn poll(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_blocking_linked_queue_poll(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn take(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_blocking_linked_queue_take(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn is_empty(&self) -> bool {
        unsafe {
            let result = aeron_blocking_linked_queue_is_empty(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn unblock(&self) -> () {
        unsafe {
            let result = aeron_blocking_linked_queue_unblock(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_blocking_linked_queue_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_blocking_linked_queue_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_blocking_linked_queue_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronBlockingLinkedQueue {
    type Target = aeron_blocking_linked_queue_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_blocking_linked_queue_t> for AeronBlockingLinkedQueue {
    #[inline]
    fn from(value: *mut aeron_blocking_linked_queue_t) -> Self {
        AeronBlockingLinkedQueue {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronBlockingLinkedQueue> for *mut aeron_blocking_linked_queue_t {
    #[inline]
    fn from(value: AeronBlockingLinkedQueue) -> Self {
        value.get_inner()
    }
}
impl From<&AeronBlockingLinkedQueue> for *mut aeron_blocking_linked_queue_t {
    #[inline]
    fn from(value: &AeronBlockingLinkedQueue) -> Self {
        value.get_inner()
    }
}
impl From<AeronBlockingLinkedQueue> for aeron_blocking_linked_queue_t {
    #[inline]
    fn from(value: AeronBlockingLinkedQueue) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_blocking_linked_queue_t> for AeronBlockingLinkedQueue {
    #[inline]
    fn from(value: *const aeron_blocking_linked_queue_t) -> Self {
        AeronBlockingLinkedQueue {
            inner: CResource::Borrowed(value as *mut aeron_blocking_linked_queue_t),
        }
    }
}
impl From<aeron_blocking_linked_queue_t> for AeronBlockingLinkedQueue {
    #[inline]
    fn from(value: aeron_blocking_linked_queue_t) -> Self {
        AeronBlockingLinkedQueue {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronBroadcastDescriptor {
    inner: CResource<aeron_broadcast_descriptor_t>,
}
impl core::fmt::Debug for AeronBroadcastDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronBroadcastDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronBroadcastDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(tail_intent_counter), &self.tail_intent_counter())
                .field(stringify!(tail_counter), &self.tail_counter())
                .field(stringify!(latest_counter), &self.latest_counter())
                .finish()
        }
    }
}
impl AeronBroadcastDescriptor {
    #[inline]
    pub fn new(
        tail_intent_counter: i64,
        tail_counter: i64,
        latest_counter: i64,
        pad: [u8; 104usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_broadcast_descriptor_t {
                    tail_intent_counter: tail_intent_counter.into(),
                    tail_counter: tail_counter.into(),
                    latest_counter: latest_counter.into(),
                    pad: pad.into(),
                };
                let inner_ptr: *mut aeron_broadcast_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_broadcast_descriptor_t)
                );
                let inst: aeron_broadcast_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_broadcast_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_broadcast_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn tail_intent_counter(&self) -> i64 {
        self.tail_intent_counter.into()
    }
    #[inline]
    pub fn tail_counter(&self) -> i64 {
        self.tail_counter.into()
    }
    #[inline]
    pub fn latest_counter(&self) -> i64 {
        self.latest_counter.into()
    }
    #[inline]
    pub fn pad(&self) -> [u8; 104usize] {
        self.pad.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_broadcast_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_broadcast_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_broadcast_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronBroadcastDescriptor {
    type Target = aeron_broadcast_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_broadcast_descriptor_t> for AeronBroadcastDescriptor {
    #[inline]
    fn from(value: *mut aeron_broadcast_descriptor_t) -> Self {
        AeronBroadcastDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronBroadcastDescriptor> for *mut aeron_broadcast_descriptor_t {
    #[inline]
    fn from(value: AeronBroadcastDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronBroadcastDescriptor> for *mut aeron_broadcast_descriptor_t {
    #[inline]
    fn from(value: &AeronBroadcastDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronBroadcastDescriptor> for aeron_broadcast_descriptor_t {
    #[inline]
    fn from(value: AeronBroadcastDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_broadcast_descriptor_t> for AeronBroadcastDescriptor {
    #[inline]
    fn from(value: *const aeron_broadcast_descriptor_t) -> Self {
        AeronBroadcastDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_broadcast_descriptor_t),
        }
    }
}
impl From<aeron_broadcast_descriptor_t> for AeronBroadcastDescriptor {
    #[inline]
    fn from(value: aeron_broadcast_descriptor_t) -> Self {
        AeronBroadcastDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronBroadcastDescriptor {
    fn default() -> Self {
        AeronBroadcastDescriptor::new_zeroed_on_heap()
    }
}
impl AeronBroadcastDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronBroadcastRecordDescriptor {
    inner: CResource<aeron_broadcast_record_descriptor_t>,
}
impl core::fmt::Debug for AeronBroadcastRecordDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronBroadcastRecordDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronBroadcastRecordDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .field(stringify!(msg_type_id), &self.msg_type_id())
                .finish()
        }
    }
}
impl AeronBroadcastRecordDescriptor {
    #[inline]
    pub fn new(length: i32, msg_type_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_broadcast_record_descriptor_t {
                    length: length.into(),
                    msg_type_id: msg_type_id.into(),
                };
                let inner_ptr: *mut aeron_broadcast_record_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_broadcast_record_descriptor_t)
                );
                let inst: aeron_broadcast_record_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_broadcast_record_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_broadcast_record_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn length(&self) -> i32 {
        self.length.into()
    }
    #[inline]
    pub fn msg_type_id(&self) -> i32 {
        self.msg_type_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_broadcast_record_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_broadcast_record_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_broadcast_record_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronBroadcastRecordDescriptor {
    type Target = aeron_broadcast_record_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_broadcast_record_descriptor_t> for AeronBroadcastRecordDescriptor {
    #[inline]
    fn from(value: *mut aeron_broadcast_record_descriptor_t) -> Self {
        AeronBroadcastRecordDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronBroadcastRecordDescriptor> for *mut aeron_broadcast_record_descriptor_t {
    #[inline]
    fn from(value: AeronBroadcastRecordDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronBroadcastRecordDescriptor> for *mut aeron_broadcast_record_descriptor_t {
    #[inline]
    fn from(value: &AeronBroadcastRecordDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronBroadcastRecordDescriptor> for aeron_broadcast_record_descriptor_t {
    #[inline]
    fn from(value: AeronBroadcastRecordDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_broadcast_record_descriptor_t> for AeronBroadcastRecordDescriptor {
    #[inline]
    fn from(value: *const aeron_broadcast_record_descriptor_t) -> Self {
        AeronBroadcastRecordDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_broadcast_record_descriptor_t),
        }
    }
}
impl From<aeron_broadcast_record_descriptor_t> for AeronBroadcastRecordDescriptor {
    #[inline]
    fn from(value: aeron_broadcast_record_descriptor_t) -> Self {
        AeronBroadcastRecordDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronBroadcastRecordDescriptor {
    fn default() -> Self {
        AeronBroadcastRecordDescriptor::new_zeroed_on_heap()
    }
}
impl AeronBroadcastRecordDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronBroadcastTransmitter {
    inner: CResource<aeron_broadcast_transmitter_t>,
}
impl core::fmt::Debug for AeronBroadcastTransmitter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronBroadcastTransmitter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronBroadcastTransmitter))
                .field("inner", &self.inner)
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(max_message_length), &self.max_message_length())
                .finish()
        }
    }
}
impl AeronBroadcastTransmitter {
    #[inline]
    pub fn new(
        buffer: *mut u8,
        descriptor: &AeronBroadcastDescriptor,
        capacity: usize,
        max_message_length: usize,
    ) -> Result<Self, AeronCError> {
        let descriptor_copy = descriptor.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_broadcast_transmitter_t {
                    buffer: buffer.into(),
                    descriptor: descriptor.into(),
                    capacity: capacity.into(),
                    max_message_length: max_message_length.into(),
                };
                let inner_ptr: *mut aeron_broadcast_transmitter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_broadcast_transmitter_t)
                );
                let inst: aeron_broadcast_transmitter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_broadcast_transmitter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_broadcast_transmitter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn buffer(&self) -> *mut u8 {
        self.buffer.into()
    }
    #[inline]
    pub fn descriptor(&self) -> AeronBroadcastDescriptor {
        self.descriptor.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn max_message_length(&self) -> usize {
        self.max_message_length.into()
    }
    #[inline]
    pub fn init(
        &self,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_broadcast_transmitter_init(self.get_inner(), buffer.into(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn transmit(
        &self,
        msg_type_id: i32,
        msg: *const ::std::os::raw::c_void,
        length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_broadcast_transmitter_transmit(
                self.get_inner(),
                msg_type_id.into(),
                msg.into(),
                length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_broadcast_transmitter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_broadcast_transmitter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_broadcast_transmitter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronBroadcastTransmitter {
    type Target = aeron_broadcast_transmitter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_broadcast_transmitter_t> for AeronBroadcastTransmitter {
    #[inline]
    fn from(value: *mut aeron_broadcast_transmitter_t) -> Self {
        AeronBroadcastTransmitter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronBroadcastTransmitter> for *mut aeron_broadcast_transmitter_t {
    #[inline]
    fn from(value: AeronBroadcastTransmitter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronBroadcastTransmitter> for *mut aeron_broadcast_transmitter_t {
    #[inline]
    fn from(value: &AeronBroadcastTransmitter) -> Self {
        value.get_inner()
    }
}
impl From<AeronBroadcastTransmitter> for aeron_broadcast_transmitter_t {
    #[inline]
    fn from(value: AeronBroadcastTransmitter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_broadcast_transmitter_t> for AeronBroadcastTransmitter {
    #[inline]
    fn from(value: *const aeron_broadcast_transmitter_t) -> Self {
        AeronBroadcastTransmitter {
            inner: CResource::Borrowed(value as *mut aeron_broadcast_transmitter_t),
        }
    }
}
impl From<aeron_broadcast_transmitter_t> for AeronBroadcastTransmitter {
    #[inline]
    fn from(value: aeron_broadcast_transmitter_t) -> Self {
        AeronBroadcastTransmitter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronBroadcastTransmitter {
    fn default() -> Self {
        AeronBroadcastTransmitter::new_zeroed_on_heap()
    }
}
impl AeronBroadcastTransmitter {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[doc = "Structure used to hold information for a try_claim function call."]
#[derive(Clone)]
pub struct AeronBufferClaim {
    inner: CResource<aeron_buffer_claim_t>,
}
impl core::fmt::Debug for AeronBufferClaim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronBufferClaim))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronBufferClaim))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronBufferClaim {
    #[inline]
    pub fn new(frame_header: *mut u8, data: &mut [u8]) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_buffer_claim_t {
                    frame_header: frame_header.into(),
                    data: data.as_ptr() as *mut _,
                    length: data.len(),
                };
                let inner_ptr: *mut aeron_buffer_claim_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_buffer_claim_t)
                );
                let inst: aeron_buffer_claim_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_buffer_claim_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_buffer_claim_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> *mut u8 {
        self.frame_header.into()
    }
    #[inline]
    pub fn data(&self) -> &mut [u8] {
        unsafe {
            if self.data.is_null() {
                &mut [] as &mut [_]
            } else {
                std::slice::from_raw_parts_mut(self.data, self.length.try_into().unwrap())
            }
        }
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline]
    #[doc = "Commit the given buffer_claim as a complete message available for consumption."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn commit(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_buffer_claim_commit(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Abort the given buffer_claim and assign its position as padding."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn abort(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_buffer_claim_abort(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_buffer_claim_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_buffer_claim_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_buffer_claim_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronBufferClaim {
    type Target = aeron_buffer_claim_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_buffer_claim_t> for AeronBufferClaim {
    #[inline]
    fn from(value: *mut aeron_buffer_claim_t) -> Self {
        AeronBufferClaim {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronBufferClaim> for *mut aeron_buffer_claim_t {
    #[inline]
    fn from(value: AeronBufferClaim) -> Self {
        value.get_inner()
    }
}
impl From<&AeronBufferClaim> for *mut aeron_buffer_claim_t {
    #[inline]
    fn from(value: &AeronBufferClaim) -> Self {
        value.get_inner()
    }
}
impl From<AeronBufferClaim> for aeron_buffer_claim_t {
    #[inline]
    fn from(value: AeronBufferClaim) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_buffer_claim_t> for AeronBufferClaim {
    #[inline]
    fn from(value: *const aeron_buffer_claim_t) -> Self {
        AeronBufferClaim {
            inner: CResource::Borrowed(value as *mut aeron_buffer_claim_t),
        }
    }
}
impl From<aeron_buffer_claim_t> for AeronBufferClaim {
    #[inline]
    fn from(value: aeron_buffer_claim_t) -> Self {
        AeronBufferClaim {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronBufferClaim {
    fn default() -> Self {
        AeronBufferClaim::new_zeroed_on_heap()
    }
}
impl AeronBufferClaim {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronChannelEndpointStatusKeyLayout {
    inner: CResource<aeron_channel_endpoint_status_key_layout_t>,
}
impl core::fmt::Debug for AeronChannelEndpointStatusKeyLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronChannelEndpointStatusKeyLayout))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronChannelEndpointStatusKeyLayout))
                .field("inner", &self.inner)
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronChannelEndpointStatusKeyLayout {
    #[inline]
    pub fn new(
        channel_length: i32,
        channel: [::std::os::raw::c_char; 108usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_channel_endpoint_status_key_layout_t {
                    channel_length: channel_length.into(),
                    channel: channel.into(),
                };
                let inner_ptr: *mut aeron_channel_endpoint_status_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_channel_endpoint_status_key_layout_t)
                );
                let inst: aeron_channel_endpoint_status_key_layout_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_channel_endpoint_status_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_channel_endpoint_status_key_layout_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline]
    pub fn channel(&self) -> [::std::os::raw::c_char; 108usize] {
        self.channel.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_channel_endpoint_status_key_layout_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_channel_endpoint_status_key_layout_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_channel_endpoint_status_key_layout_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronChannelEndpointStatusKeyLayout {
    type Target = aeron_channel_endpoint_status_key_layout_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_channel_endpoint_status_key_layout_t> for AeronChannelEndpointStatusKeyLayout {
    #[inline]
    fn from(value: *mut aeron_channel_endpoint_status_key_layout_t) -> Self {
        AeronChannelEndpointStatusKeyLayout {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronChannelEndpointStatusKeyLayout> for *mut aeron_channel_endpoint_status_key_layout_t {
    #[inline]
    fn from(value: AeronChannelEndpointStatusKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<&AeronChannelEndpointStatusKeyLayout>
    for *mut aeron_channel_endpoint_status_key_layout_t
{
    #[inline]
    fn from(value: &AeronChannelEndpointStatusKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<AeronChannelEndpointStatusKeyLayout> for aeron_channel_endpoint_status_key_layout_t {
    #[inline]
    fn from(value: AeronChannelEndpointStatusKeyLayout) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_channel_endpoint_status_key_layout_t>
    for AeronChannelEndpointStatusKeyLayout
{
    #[inline]
    fn from(value: *const aeron_channel_endpoint_status_key_layout_t) -> Self {
        AeronChannelEndpointStatusKeyLayout {
            inner: CResource::Borrowed(value as *mut aeron_channel_endpoint_status_key_layout_t),
        }
    }
}
impl From<aeron_channel_endpoint_status_key_layout_t> for AeronChannelEndpointStatusKeyLayout {
    #[inline]
    fn from(value: aeron_channel_endpoint_status_key_layout_t) -> Self {
        AeronChannelEndpointStatusKeyLayout {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronChannelEndpointStatusKeyLayout {
    fn default() -> Self {
        AeronChannelEndpointStatusKeyLayout::new_zeroed_on_heap()
    }
}
impl AeronChannelEndpointStatusKeyLayout {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronClientRegisteringResource {
    inner: CResource<aeron_client_registering_resource_t>,
}
impl core::fmt::Debug for AeronClientRegisteringResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronClientRegisteringResource))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronClientRegisteringResource))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronClientRegisteringResource {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_client_registering_resource_t)
                );
                let inst: aeron_client_registering_resource_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_client_registering_resource_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_client_registering_resource_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_client_registering_resource_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_client_registering_resource_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_client_registering_resource_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronClientRegisteringResource {
    type Target = aeron_client_registering_resource_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_client_registering_resource_t> for AeronClientRegisteringResource {
    #[inline]
    fn from(value: *mut aeron_client_registering_resource_t) -> Self {
        AeronClientRegisteringResource {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronClientRegisteringResource> for *mut aeron_client_registering_resource_t {
    #[inline]
    fn from(value: AeronClientRegisteringResource) -> Self {
        value.get_inner()
    }
}
impl From<&AeronClientRegisteringResource> for *mut aeron_client_registering_resource_t {
    #[inline]
    fn from(value: &AeronClientRegisteringResource) -> Self {
        value.get_inner()
    }
}
impl From<AeronClientRegisteringResource> for aeron_client_registering_resource_t {
    #[inline]
    fn from(value: AeronClientRegisteringResource) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_client_registering_resource_t> for AeronClientRegisteringResource {
    #[inline]
    fn from(value: *const aeron_client_registering_resource_t) -> Self {
        AeronClientRegisteringResource {
            inner: CResource::Borrowed(value as *mut aeron_client_registering_resource_t),
        }
    }
}
impl From<aeron_client_registering_resource_t> for AeronClientRegisteringResource {
    #[inline]
    fn from(value: aeron_client_registering_resource_t) -> Self {
        AeronClientRegisteringResource {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronClient {
    inner: CResource<aeron_client_t>,
}
impl core::fmt::Debug for AeronClient {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronClient))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronClient))
                .field("inner", &self.inner)
                .field(stringify!(reached_end_of_life), &self.reached_end_of_life())
                .field(stringify!(closed_by_command), &self.closed_by_command())
                .field(stringify!(client_id), &self.client_id())
                .field(
                    stringify!(client_liveness_timeout_ms),
                    &self.client_liveness_timeout_ms(),
                )
                .field(stringify!(heartbeat_timestamp), &self.heartbeat_timestamp())
                .finish()
        }
    }
}
impl AeronClient {
    #[inline]
    pub fn new(
        reached_end_of_life: bool,
        closed_by_command: bool,
        client_id: i64,
        client_liveness_timeout_ms: i64,
        heartbeat_timestamp: AeronAtomicCounter,
        publication_links: aeron_client_stct_publication_link_stct,
        counter_links: aeron_client_stct_counter_link_stct,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_client_t {
                    reached_end_of_life: reached_end_of_life.into(),
                    closed_by_command: closed_by_command.into(),
                    client_id: client_id.into(),
                    client_liveness_timeout_ms: client_liveness_timeout_ms.into(),
                    heartbeat_timestamp: heartbeat_timestamp.into(),
                    publication_links: publication_links.into(),
                    counter_links: counter_links.into(),
                };
                let inner_ptr: *mut aeron_client_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_client_t)
                );
                let inst: aeron_client_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_client_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_client_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn reached_end_of_life(&self) -> bool {
        self.reached_end_of_life.into()
    }
    #[inline]
    pub fn closed_by_command(&self) -> bool {
        self.closed_by_command.into()
    }
    #[inline]
    pub fn client_id(&self) -> i64 {
        self.client_id.into()
    }
    #[inline]
    pub fn client_liveness_timeout_ms(&self) -> i64 {
        self.client_liveness_timeout_ms.into()
    }
    #[inline]
    pub fn heartbeat_timestamp(&self) -> AeronAtomicCounter {
        self.heartbeat_timestamp.into()
    }
    #[inline]
    pub fn publication_links(&self) -> aeron_client_stct_publication_link_stct {
        self.publication_links.into()
    }
    #[inline]
    pub fn counter_links(&self) -> aeron_client_stct_counter_link_stct {
        self.counter_links.into()
    }
    #[inline]
    pub fn free(arg1: *mut ::std::os::raw::c_void) -> bool {
        unsafe {
            let result = aeron_client_free(arg1.into());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_client_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_client_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_client_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronClient {
    type Target = aeron_client_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_client_t> for AeronClient {
    #[inline]
    fn from(value: *mut aeron_client_t) -> Self {
        AeronClient {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronClient> for *mut aeron_client_t {
    #[inline]
    fn from(value: AeronClient) -> Self {
        value.get_inner()
    }
}
impl From<&AeronClient> for *mut aeron_client_t {
    #[inline]
    fn from(value: &AeronClient) -> Self {
        value.get_inner()
    }
}
impl From<AeronClient> for aeron_client_t {
    #[inline]
    fn from(value: AeronClient) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_client_t> for AeronClient {
    #[inline]
    fn from(value: *const aeron_client_t) -> Self {
        AeronClient {
            inner: CResource::Borrowed(value as *mut aeron_client_t),
        }
    }
}
impl From<aeron_client_t> for AeronClient {
    #[inline]
    fn from(value: aeron_client_t) -> Self {
        AeronClient {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronClient {
    fn default() -> Self {
        AeronClient::new_zeroed_on_heap()
    }
}
impl AeronClient {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronClientTimeout {
    inner: CResource<aeron_client_timeout_t>,
}
impl core::fmt::Debug for AeronClientTimeout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronClientTimeout))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronClientTimeout))
                .field("inner", &self.inner)
                .field(stringify!(client_id), &self.client_id())
                .finish()
        }
    }
}
impl AeronClientTimeout {
    #[inline]
    pub fn new(client_id: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_client_timeout_t {
                    client_id: client_id.into(),
                };
                let inner_ptr: *mut aeron_client_timeout_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_client_timeout_t)
                );
                let inst: aeron_client_timeout_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_client_timeout_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_client_timeout_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn client_id(&self) -> i64 {
        self.client_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_client_timeout_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_client_timeout_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_client_timeout_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronClientTimeout {
    type Target = aeron_client_timeout_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_client_timeout_t> for AeronClientTimeout {
    #[inline]
    fn from(value: *mut aeron_client_timeout_t) -> Self {
        AeronClientTimeout {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronClientTimeout> for *mut aeron_client_timeout_t {
    #[inline]
    fn from(value: AeronClientTimeout) -> Self {
        value.get_inner()
    }
}
impl From<&AeronClientTimeout> for *mut aeron_client_timeout_t {
    #[inline]
    fn from(value: &AeronClientTimeout) -> Self {
        value.get_inner()
    }
}
impl From<AeronClientTimeout> for aeron_client_timeout_t {
    #[inline]
    fn from(value: AeronClientTimeout) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_client_timeout_t> for AeronClientTimeout {
    #[inline]
    fn from(value: *const aeron_client_timeout_t) -> Self {
        AeronClientTimeout {
            inner: CResource::Borrowed(value as *mut aeron_client_timeout_t),
        }
    }
}
impl From<aeron_client_timeout_t> for AeronClientTimeout {
    #[inline]
    fn from(value: aeron_client_timeout_t) -> Self {
        AeronClientTimeout {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronClientTimeout {
    fn default() -> Self {
        AeronClientTimeout::new_zeroed_on_heap()
    }
}
impl AeronClientTimeout {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronClockCache {
    inner: CResource<aeron_clock_cache_t>,
}
impl core::fmt::Debug for AeronClockCache {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronClockCache))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronClockCache))
                .field("inner", &self.inner)
                .field(stringify!(cached_epoch_time), &self.cached_epoch_time())
                .field(stringify!(cached_nano_time), &self.cached_nano_time())
                .finish()
        }
    }
}
impl AeronClockCache {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_clock_cache_t)
                );
                let inst: aeron_clock_cache_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_clock_cache_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_clock_cache_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn pre_pad(&self) -> [u8; 56usize] {
        self.pre_pad.into()
    }
    #[inline]
    pub fn cached_epoch_time(&self) -> i64 {
        self.cached_epoch_time.into()
    }
    #[inline]
    pub fn cached_nano_time(&self) -> i64 {
        self.cached_nano_time.into()
    }
    #[inline]
    pub fn post_pad(&self) -> [u8; 56usize] {
        self.post_pad.into()
    }
    #[inline]
    #[doc = "Update the cached clock with the current epoch and nano time values."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `epoch_time` current ms since epoch."]
    #[doc = " \n - `nano_time` current ns time."]
    pub fn aeron_clock_update_cached_time(&self, epoch_time: i64, nano_time: i64) -> () {
        unsafe {
            let result = aeron_clock_update_cached_time(
                self.get_inner(),
                epoch_time.into(),
                nano_time.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Update the cached clock with the current epoch time value."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `epoch_time` current ms since epoch."]
    pub fn aeron_clock_update_cached_epoch_time(&self, epoch_time: i64) -> () {
        unsafe {
            let result = aeron_clock_update_cached_epoch_time(self.get_inner(), epoch_time.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Update the cached clock with the current nano time value."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `nano_time` current ns time."]
    pub fn aeron_clock_update_cached_nano_time(&self, nano_time: i64) -> () {
        unsafe {
            let result = aeron_clock_update_cached_nano_time(self.get_inner(), nano_time.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Retrieves the cached epoch time from supplied cached clock."]
    #[doc = ""]
    #[doc = " \n# Return\n The current cached value for the epoch time."]
    pub fn aeron_clock_cached_epoch_time(&self) -> i64 {
        unsafe {
            let result = aeron_clock_cached_epoch_time(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Retrieves the cached nano time from supplied cached clock."]
    #[doc = ""]
    #[doc = " \n# Return\n The current cached value for the nano time."]
    pub fn aeron_clock_cached_nano_time(&self) -> i64 {
        unsafe {
            let result = aeron_clock_cached_nano_time(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_clock_cache_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_clock_cache_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_clock_cache_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronClockCache {
    type Target = aeron_clock_cache_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_clock_cache_t> for AeronClockCache {
    #[inline]
    fn from(value: *mut aeron_clock_cache_t) -> Self {
        AeronClockCache {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronClockCache> for *mut aeron_clock_cache_t {
    #[inline]
    fn from(value: AeronClockCache) -> Self {
        value.get_inner()
    }
}
impl From<&AeronClockCache> for *mut aeron_clock_cache_t {
    #[inline]
    fn from(value: &AeronClockCache) -> Self {
        value.get_inner()
    }
}
impl From<AeronClockCache> for aeron_clock_cache_t {
    #[inline]
    fn from(value: AeronClockCache) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_clock_cache_t> for AeronClockCache {
    #[inline]
    fn from(value: *const aeron_clock_cache_t) -> Self {
        AeronClockCache {
            inner: CResource::Borrowed(value as *mut aeron_clock_cache_t),
        }
    }
}
impl From<aeron_clock_cache_t> for AeronClockCache {
    #[inline]
    fn from(value: aeron_clock_cache_t) -> Self {
        AeronClockCache {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronCncConstants {
    inner: CResource<aeron_cnc_constants_t>,
}
impl core::fmt::Debug for AeronCncConstants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCncConstants))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCncConstants))
                .field("inner", &self.inner)
                .field(stringify!(cnc_version), &self.cnc_version())
                .field(
                    stringify!(to_driver_buffer_length),
                    &self.to_driver_buffer_length(),
                )
                .field(
                    stringify!(to_clients_buffer_length),
                    &self.to_clients_buffer_length(),
                )
                .field(
                    stringify!(counter_metadata_buffer_length),
                    &self.counter_metadata_buffer_length(),
                )
                .field(
                    stringify!(counter_values_buffer_length),
                    &self.counter_values_buffer_length(),
                )
                .field(
                    stringify!(error_log_buffer_length),
                    &self.error_log_buffer_length(),
                )
                .field(
                    stringify!(client_liveness_timeout),
                    &self.client_liveness_timeout(),
                )
                .field(stringify!(start_timestamp), &self.start_timestamp())
                .field(stringify!(pid), &self.pid())
                .field(stringify!(file_page_size), &self.file_page_size())
                .finish()
        }
    }
}
impl AeronCncConstants {
    #[inline]
    pub fn new(
        cnc_version: i32,
        to_driver_buffer_length: i32,
        to_clients_buffer_length: i32,
        counter_metadata_buffer_length: i32,
        counter_values_buffer_length: i32,
        error_log_buffer_length: i32,
        client_liveness_timeout: i64,
        start_timestamp: i64,
        pid: i64,
        file_page_size: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_cnc_constants_t {
                    cnc_version: cnc_version.into(),
                    to_driver_buffer_length: to_driver_buffer_length.into(),
                    to_clients_buffer_length: to_clients_buffer_length.into(),
                    counter_metadata_buffer_length: counter_metadata_buffer_length.into(),
                    counter_values_buffer_length: counter_values_buffer_length.into(),
                    error_log_buffer_length: error_log_buffer_length.into(),
                    client_liveness_timeout: client_liveness_timeout.into(),
                    start_timestamp: start_timestamp.into(),
                    pid: pid.into(),
                    file_page_size: file_page_size.into(),
                };
                let inner_ptr: *mut aeron_cnc_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_cnc_constants_t)
                );
                let inst: aeron_cnc_constants_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_cnc_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_cnc_constants_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn cnc_version(&self) -> i32 {
        self.cnc_version.into()
    }
    #[inline]
    pub fn to_driver_buffer_length(&self) -> i32 {
        self.to_driver_buffer_length.into()
    }
    #[inline]
    pub fn to_clients_buffer_length(&self) -> i32 {
        self.to_clients_buffer_length.into()
    }
    #[inline]
    pub fn counter_metadata_buffer_length(&self) -> i32 {
        self.counter_metadata_buffer_length.into()
    }
    #[inline]
    pub fn counter_values_buffer_length(&self) -> i32 {
        self.counter_values_buffer_length.into()
    }
    #[inline]
    pub fn error_log_buffer_length(&self) -> i32 {
        self.error_log_buffer_length.into()
    }
    #[inline]
    pub fn client_liveness_timeout(&self) -> i64 {
        self.client_liveness_timeout.into()
    }
    #[inline]
    pub fn start_timestamp(&self) -> i64 {
        self.start_timestamp.into()
    }
    #[inline]
    pub fn pid(&self) -> i64 {
        self.pid.into()
    }
    #[inline]
    pub fn file_page_size(&self) -> i32 {
        self.file_page_size.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_cnc_constants_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_cnc_constants_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_cnc_constants_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCncConstants {
    type Target = aeron_cnc_constants_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_cnc_constants_t> for AeronCncConstants {
    #[inline]
    fn from(value: *mut aeron_cnc_constants_t) -> Self {
        AeronCncConstants {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCncConstants> for *mut aeron_cnc_constants_t {
    #[inline]
    fn from(value: AeronCncConstants) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCncConstants> for *mut aeron_cnc_constants_t {
    #[inline]
    fn from(value: &AeronCncConstants) -> Self {
        value.get_inner()
    }
}
impl From<AeronCncConstants> for aeron_cnc_constants_t {
    #[inline]
    fn from(value: AeronCncConstants) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_cnc_constants_t> for AeronCncConstants {
    #[inline]
    fn from(value: *const aeron_cnc_constants_t) -> Self {
        AeronCncConstants {
            inner: CResource::Borrowed(value as *mut aeron_cnc_constants_t),
        }
    }
}
impl From<aeron_cnc_constants_t> for AeronCncConstants {
    #[inline]
    fn from(value: aeron_cnc_constants_t) -> Self {
        AeronCncConstants {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCncConstants {
    fn default() -> Self {
        AeronCncConstants::new_zeroed_on_heap()
    }
}
impl AeronCncConstants {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCncMetadata {
    inner: CResource<aeron_cnc_metadata_t>,
}
impl core::fmt::Debug for AeronCncMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCncMetadata))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCncMetadata))
                .field("inner", &self.inner)
                .field(stringify!(cnc_version), &self.cnc_version())
                .field(
                    stringify!(to_driver_buffer_length),
                    &self.to_driver_buffer_length(),
                )
                .field(
                    stringify!(to_clients_buffer_length),
                    &self.to_clients_buffer_length(),
                )
                .field(
                    stringify!(counter_metadata_buffer_length),
                    &self.counter_metadata_buffer_length(),
                )
                .field(
                    stringify!(counter_values_buffer_length),
                    &self.counter_values_buffer_length(),
                )
                .field(
                    stringify!(error_log_buffer_length),
                    &self.error_log_buffer_length(),
                )
                .field(
                    stringify!(client_liveness_timeout),
                    &self.client_liveness_timeout(),
                )
                .field(stringify!(start_timestamp), &self.start_timestamp())
                .field(stringify!(pid), &self.pid())
                .field(stringify!(file_page_size), &self.file_page_size())
                .finish()
        }
    }
}
impl AeronCncMetadata {
    #[inline]
    pub fn new(
        cnc_version: i32,
        to_driver_buffer_length: i32,
        to_clients_buffer_length: i32,
        counter_metadata_buffer_length: i32,
        counter_values_buffer_length: i32,
        error_log_buffer_length: i32,
        client_liveness_timeout: i64,
        start_timestamp: i64,
        pid: i64,
        file_page_size: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_cnc_metadata_t {
                    cnc_version: cnc_version.into(),
                    to_driver_buffer_length: to_driver_buffer_length.into(),
                    to_clients_buffer_length: to_clients_buffer_length.into(),
                    counter_metadata_buffer_length: counter_metadata_buffer_length.into(),
                    counter_values_buffer_length: counter_values_buffer_length.into(),
                    error_log_buffer_length: error_log_buffer_length.into(),
                    client_liveness_timeout: client_liveness_timeout.into(),
                    start_timestamp: start_timestamp.into(),
                    pid: pid.into(),
                    file_page_size: file_page_size.into(),
                };
                let inner_ptr: *mut aeron_cnc_metadata_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_cnc_metadata_t)
                );
                let inst: aeron_cnc_metadata_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_cnc_metadata_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_cnc_metadata_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn cnc_version(&self) -> i32 {
        self.cnc_version.into()
    }
    #[inline]
    pub fn to_driver_buffer_length(&self) -> i32 {
        self.to_driver_buffer_length.into()
    }
    #[inline]
    pub fn to_clients_buffer_length(&self) -> i32 {
        self.to_clients_buffer_length.into()
    }
    #[inline]
    pub fn counter_metadata_buffer_length(&self) -> i32 {
        self.counter_metadata_buffer_length.into()
    }
    #[inline]
    pub fn counter_values_buffer_length(&self) -> i32 {
        self.counter_values_buffer_length.into()
    }
    #[inline]
    pub fn error_log_buffer_length(&self) -> i32 {
        self.error_log_buffer_length.into()
    }
    #[inline]
    pub fn client_liveness_timeout(&self) -> i64 {
        self.client_liveness_timeout.into()
    }
    #[inline]
    pub fn start_timestamp(&self) -> i64 {
        self.start_timestamp.into()
    }
    #[inline]
    pub fn pid(&self) -> i64 {
        self.pid.into()
    }
    #[inline]
    pub fn file_page_size(&self) -> i32 {
        self.file_page_size.into()
    }
    #[inline]
    pub fn aeron_cnc_version_volatile(&self) -> i32 {
        unsafe {
            let result = aeron_cnc_version_volatile(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_cnc_metadata_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_cnc_metadata_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_cnc_metadata_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCncMetadata {
    type Target = aeron_cnc_metadata_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_cnc_metadata_t> for AeronCncMetadata {
    #[inline]
    fn from(value: *mut aeron_cnc_metadata_t) -> Self {
        AeronCncMetadata {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCncMetadata> for *mut aeron_cnc_metadata_t {
    #[inline]
    fn from(value: AeronCncMetadata) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCncMetadata> for *mut aeron_cnc_metadata_t {
    #[inline]
    fn from(value: &AeronCncMetadata) -> Self {
        value.get_inner()
    }
}
impl From<AeronCncMetadata> for aeron_cnc_metadata_t {
    #[inline]
    fn from(value: AeronCncMetadata) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_cnc_metadata_t> for AeronCncMetadata {
    #[inline]
    fn from(value: *const aeron_cnc_metadata_t) -> Self {
        AeronCncMetadata {
            inner: CResource::Borrowed(value as *mut aeron_cnc_metadata_t),
        }
    }
}
impl From<aeron_cnc_metadata_t> for AeronCncMetadata {
    #[inline]
    fn from(value: aeron_cnc_metadata_t) -> Self {
        AeronCncMetadata {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCncMetadata {
    fn default() -> Self {
        AeronCncMetadata::new_zeroed_on_heap()
    }
}
impl AeronCncMetadata {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCnc {
    inner: CResource<aeron_cnc_t>,
}
impl core::fmt::Debug for AeronCnc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCnc))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCnc))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronCnc {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_cnc_t)
                );
                let inst: aeron_cnc_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_cnc_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_cnc_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Fetch the sets of constant values associated with this command and control file."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `constants` user supplied structure to hold return values."]
    #[doc = " \n# Return\n 0 on success, -1 on failure."]
    pub fn constants(&self, constants: &AeronCncConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_cnc_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fetch the sets of constant values associated with this command and control file."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronCncConstants, AeronCError> {
        let result = AeronCncConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Get the current file name of the cnc file."]
    #[doc = ""]
    #[doc = " \n# Return\n name of the cnc file"]
    pub fn filename(&self) -> &str {
        unsafe {
            let result = aeron_cnc_filename(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Gets the timestamp of the last heartbeat sent to the media driver from any client."]
    #[doc = ""]
    #[doc = " \n# Return\n last heartbeat timestamp in ms."]
    pub fn to_driver_heartbeat(&self) -> i64 {
        unsafe {
            let result = aeron_cnc_to_driver_heartbeat(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Reads the current error log for this driver."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `callback` called for every distinct error observation"]
    #[doc = " \n - `clientd` client data to be passed to the callback"]
    #[doc = " \n - `since_timestamp` only return errors after this timestamp (0 returns all)"]
    #[doc = " \n# Return\n the number of distinct errors seen"]
    pub fn error_log_read<AeronErrorLogReaderFuncHandlerImpl: AeronErrorLogReaderFuncCallback>(
        &self,
        callback: Option<&Handler<AeronErrorLogReaderFuncHandlerImpl>>,
        since_timestamp: i64,
    ) -> usize {
        unsafe {
            let result = aeron_cnc_error_log_read(
                self.get_inner(),
                {
                    let callback: aeron_error_log_reader_func_t = if callback.is_none() {
                        None
                    } else {
                        Some(
                            aeron_error_log_reader_func_t_callback::<
                                AeronErrorLogReaderFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                callback
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                since_timestamp.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Reads the current error log for this driver."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `callback` called for every distinct error observation"]
    #[doc = " \n - `clientd` client data to be passed to the callback"]
    #[doc = " \n - `since_timestamp` only return errors after this timestamp (0 returns all)"]
    #[doc = " \n# Return\n the number of distinct errors seen"]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn error_log_read_once<
        AeronErrorLogReaderFuncHandlerImpl: FnMut(i32, i64, i64, &str) -> (),
    >(
        &self,
        mut callback: AeronErrorLogReaderFuncHandlerImpl,
        since_timestamp: i64,
    ) -> usize {
        unsafe {
            let result = aeron_cnc_error_log_read(
                self.get_inner(),
                Some(
                    aeron_error_log_reader_func_t_callback_for_once_closure::<
                        AeronErrorLogReaderFuncHandlerImpl,
                    >,
                ),
                &mut callback as *mut _ as *mut std::os::raw::c_void,
                since_timestamp.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Gets a counters reader for this command and control file. This does not need to be closed manually, resources"]
    #[doc = " are tied to the instance of aeron_cnc."]
    #[doc = ""]
    #[doc = " \n# Return\n pointer to a counters reader."]
    pub fn counters_reader(&self) -> AeronCountersReader {
        unsafe {
            let result = aeron_cnc_counters_reader(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Read all of the data loss observations from the report in the same media driver instances as the cnc file."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `entry_func` callback for each observation found"]
    #[doc = " \n# Return\n -1 on failure, number of observations on success (could be 0)."]
    pub fn loss_reporter_read<
        AeronLossReporterReadEntryFuncHandlerImpl: AeronLossReporterReadEntryFuncCallback,
    >(
        &self,
        entry_func: Option<&Handler<AeronLossReporterReadEntryFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_cnc_loss_reporter_read(
                self.get_inner(),
                {
                    let callback: aeron_loss_reporter_read_entry_func_t = if entry_func.is_none() {
                        None
                    } else {
                        Some(
                            aeron_loss_reporter_read_entry_func_t_callback::<
                                AeronLossReporterReadEntryFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                entry_func
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Read all of the data loss observations from the report in the same media driver instances as the cnc file."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `entry_func` callback for each observation found"]
    #[doc = " \n# Return\n -1 on failure, number of observations on success (could be 0)."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn loss_reporter_read_once<
        AeronLossReporterReadEntryFuncHandlerImpl: FnMut(i64, i64, i64, i64, i32, i32, &str, &str) -> (),
    >(
        &self,
        mut entry_func: AeronLossReporterReadEntryFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_cnc_loss_reporter_read(
                self.get_inner(),
                Some(
                    aeron_loss_reporter_read_entry_func_t_callback_for_once_closure::<
                        AeronLossReporterReadEntryFuncHandlerImpl,
                    >,
                ),
                &mut entry_func as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Closes the instance of the aeron cnc and frees its resources."]
    #[doc = ""]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_cnc_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn resolve_filename(
        directory: &std::ffi::CStr,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_cnc_resolve_filename(
                directory.as_ptr(),
                filename_buffer.into(),
                filename_buffer_length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_cnc_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_cnc_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_cnc_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCnc {
    type Target = aeron_cnc_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_cnc_t> for AeronCnc {
    #[inline]
    fn from(value: *mut aeron_cnc_t) -> Self {
        AeronCnc {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCnc> for *mut aeron_cnc_t {
    #[inline]
    fn from(value: AeronCnc) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCnc> for *mut aeron_cnc_t {
    #[inline]
    fn from(value: &AeronCnc) -> Self {
        value.get_inner()
    }
}
impl From<AeronCnc> for aeron_cnc_t {
    #[inline]
    fn from(value: AeronCnc) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_cnc_t> for AeronCnc {
    #[inline]
    fn from(value: *const aeron_cnc_t) -> Self {
        AeronCnc {
            inner: CResource::Borrowed(value as *mut aeron_cnc_t),
        }
    }
}
impl From<aeron_cnc_t> for AeronCnc {
    #[inline]
    fn from(value: aeron_cnc_t) -> Self {
        AeronCnc {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronCongestionControlStrategy {
    inner: CResource<aeron_congestion_control_strategy_t>,
}
impl core::fmt::Debug for AeronCongestionControlStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCongestionControlStrategy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCongestionControlStrategy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronCongestionControlStrategy {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_congestion_control_strategy_t)
                );
                let inst: aeron_congestion_control_strategy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_congestion_control_strategy_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_congestion_control_strategy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn should_measure_rtt(
        &self,
    ) -> aeron_congestion_control_strategy_should_measure_rtt_func_t {
        self.should_measure_rtt.into()
    }
    #[inline]
    pub fn on_rttm_sent(&self) -> aeron_congestion_control_strategy_on_rttm_sent_func_t {
        self.on_rttm_sent.into()
    }
    #[inline]
    pub fn on_rttm(&self) -> aeron_congestion_control_strategy_on_rttm_func_t {
        self.on_rttm.into()
    }
    #[inline]
    pub fn on_track_rebuild(&self) -> aeron_congestion_control_strategy_on_track_rebuild_func_t {
        self.on_track_rebuild.into()
    }
    #[inline]
    pub fn initial_window_length(
        &self,
    ) -> aeron_congestion_control_strategy_initial_window_length_func_t {
        self.initial_window_length.into()
    }
    #[inline]
    pub fn max_window_length(&self) -> aeron_congestion_control_strategy_max_window_length_func_t {
        self.max_window_length.into()
    }
    #[inline]
    pub fn fini(&self) -> aeron_congestion_control_strategy_fini_func_t {
        self.fini.into()
    }
    #[inline]
    pub fn state(&self) -> *mut ::std::os::raw::c_void {
        self.state.into()
    }
    #[inline]
    pub fn supplier_load(
        strategy_name: &std::ffi::CStr,
    ) -> aeron_congestion_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_congestion_control_strategy_supplier_load(strategy_name.as_ptr());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_congestion_control_strategy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_congestion_control_strategy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_congestion_control_strategy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCongestionControlStrategy {
    type Target = aeron_congestion_control_strategy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_congestion_control_strategy_t> for AeronCongestionControlStrategy {
    #[inline]
    fn from(value: *mut aeron_congestion_control_strategy_t) -> Self {
        AeronCongestionControlStrategy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCongestionControlStrategy> for *mut aeron_congestion_control_strategy_t {
    #[inline]
    fn from(value: AeronCongestionControlStrategy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCongestionControlStrategy> for *mut aeron_congestion_control_strategy_t {
    #[inline]
    fn from(value: &AeronCongestionControlStrategy) -> Self {
        value.get_inner()
    }
}
impl From<AeronCongestionControlStrategy> for aeron_congestion_control_strategy_t {
    #[inline]
    fn from(value: AeronCongestionControlStrategy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_congestion_control_strategy_t> for AeronCongestionControlStrategy {
    #[inline]
    fn from(value: *const aeron_congestion_control_strategy_t) -> Self {
        AeronCongestionControlStrategy {
            inner: CResource::Borrowed(value as *mut aeron_congestion_control_strategy_t),
        }
    }
}
impl From<aeron_congestion_control_strategy_t> for AeronCongestionControlStrategy {
    #[inline]
    fn from(value: aeron_congestion_control_strategy_t) -> Self {
        AeronCongestionControlStrategy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronContext {
    inner: CResource<aeron_context_t>,
}
impl core::fmt::Debug for AeronContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronContext))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronContext))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronContext {
    #[doc = "Create a `AeronContext` struct and initialize with default values."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new() -> Result<Self, AeronCError> {
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_context_init(ctx_field) },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_context_close(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    pub fn set_dir(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_dir(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_dir(&self) -> &str {
        unsafe {
            let result = aeron_context_get_dir(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_driver_timeout_ms(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_driver_timeout_ms(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_driver_timeout_ms(&self) -> u64 {
        unsafe {
            let result = aeron_context_get_driver_timeout_ms(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_keepalive_interval_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_keepalive_interval_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_keepalive_interval_ns(&self) -> u64 {
        unsafe {
            let result = aeron_context_get_keepalive_interval_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_resource_linger_duration_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_context_set_resource_linger_duration_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_resource_linger_duration_ns(&self) -> u64 {
        unsafe {
            let result = aeron_context_get_resource_linger_duration_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_idle_sleep_duration_ns(&self) -> u64 {
        unsafe {
            let result = aeron_context_get_idle_sleep_duration_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_idle_sleep_duration_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_idle_sleep_duration_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_pre_touch_mapped_memory(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_pre_touch_mapped_memory(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_pre_touch_mapped_memory(&self) -> bool {
        unsafe {
            let result = aeron_context_get_pre_touch_mapped_memory(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_client_name(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_client_name(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_client_name(&self) -> &str {
        unsafe {
            let result = aeron_context_get_client_name(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_error_handler<AeronErrorHandlerHandlerImpl: AeronErrorHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronErrorHandlerHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_error_handler(
                self.get_inner(),
                {
                    let callback: aeron_error_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_error_handler_t_callback::<AeronErrorHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_error_handler_once<
        AeronErrorHandlerHandlerImpl: FnMut(::std::os::raw::c_int, &str) -> (),
    >(
        &self,
        mut handler: AeronErrorHandlerHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_error_handler(
                self.get_inner(),
                Some(
                    aeron_error_handler_t_callback_for_once_closure::<AeronErrorHandlerHandlerImpl>,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_error_handler(&self) -> aeron_error_handler_t {
        unsafe {
            let result = aeron_context_get_error_handler(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_error_handler_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_error_handler_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_error_frame_handler<
        AeronPublicationErrorFrameHandlerHandlerImpl: AeronPublicationErrorFrameHandlerCallback,
    >(
        &self,
        handler: Option<&Handler<AeronPublicationErrorFrameHandlerHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_publication_error_frame_handler(
                self.get_inner(),
                {
                    let callback: aeron_publication_error_frame_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_publication_error_frame_handler_t_callback::<
                                AeronPublicationErrorFrameHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_publication_error_frame_handler_once<
        AeronPublicationErrorFrameHandlerHandlerImpl: FnMut(AeronPublicationErrorValues) -> (),
    >(
        &self,
        mut handler: AeronPublicationErrorFrameHandlerHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_publication_error_frame_handler(
                self.get_inner(),
                Some(
                    aeron_publication_error_frame_handler_t_callback_for_once_closure::<
                        AeronPublicationErrorFrameHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_error_frame_handler(&self) -> aeron_publication_error_frame_handler_t {
        unsafe {
            let result = aeron_context_get_publication_error_frame_handler(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_publication_error_frame_handler_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result =
                aeron_context_get_publication_error_frame_handler_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_new_publication<AeronNewPublicationHandlerImpl: AeronNewPublicationCallback>(
        &self,
        handler: Option<&Handler<AeronNewPublicationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_publication(
                self.get_inner(),
                {
                    let callback: aeron_on_new_publication_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_on_new_publication_t_callback::<AeronNewPublicationHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_new_publication_once<
        AeronNewPublicationHandlerImpl: FnMut(AeronAsyncAddPublication, &str, i32, i32, i64) -> (),
    >(
        &self,
        mut handler: AeronNewPublicationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_publication(
                self.get_inner(),
                Some(
                    aeron_on_new_publication_t_callback_for_once_closure::<
                        AeronNewPublicationHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_new_publication(&self) -> aeron_on_new_publication_t {
        unsafe {
            let result = aeron_context_get_on_new_publication(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_new_publication_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_new_publication_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_new_exclusive_publication<
        AeronNewPublicationHandlerImpl: AeronNewPublicationCallback,
    >(
        &self,
        handler: Option<&Handler<AeronNewPublicationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_exclusive_publication(
                self.get_inner(),
                {
                    let callback: aeron_on_new_publication_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_on_new_publication_t_callback::<AeronNewPublicationHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_new_exclusive_publication_once<
        AeronNewPublicationHandlerImpl: FnMut(AeronAsyncAddPublication, &str, i32, i32, i64) -> (),
    >(
        &self,
        mut handler: AeronNewPublicationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_exclusive_publication(
                self.get_inner(),
                Some(
                    aeron_on_new_publication_t_callback_for_once_closure::<
                        AeronNewPublicationHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_new_exclusive_publication(&self) -> aeron_on_new_publication_t {
        unsafe {
            let result = aeron_context_get_on_new_exclusive_publication(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_new_exclusive_publication_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_new_exclusive_publication_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_new_subscription<
        AeronNewSubscriptionHandlerImpl: AeronNewSubscriptionCallback,
    >(
        &self,
        handler: Option<&Handler<AeronNewSubscriptionHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_subscription(
                self.get_inner(),
                {
                    let callback: aeron_on_new_subscription_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_on_new_subscription_t_callback::<AeronNewSubscriptionHandlerImpl>,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_new_subscription_once<
        AeronNewSubscriptionHandlerImpl: FnMut(AeronAsyncAddSubscription, &str, i32, i64) -> (),
    >(
        &self,
        mut handler: AeronNewSubscriptionHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_new_subscription(
                self.get_inner(),
                Some(
                    aeron_on_new_subscription_t_callback_for_once_closure::<
                        AeronNewSubscriptionHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_new_subscription(&self) -> aeron_on_new_subscription_t {
        unsafe {
            let result = aeron_context_get_on_new_subscription(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_new_subscription_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_new_subscription_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_available_counter<
        AeronAvailableCounterHandlerImpl: AeronAvailableCounterCallback,
    >(
        &self,
        handler: Option<&Handler<AeronAvailableCounterHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_available_counter(
                self.get_inner(),
                {
                    let callback: aeron_on_available_counter_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_on_available_counter_t_callback::<AeronAvailableCounterHandlerImpl>,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_available_counter_once<
        AeronAvailableCounterHandlerImpl: FnMut(AeronCountersReader, i64, i32) -> (),
    >(
        &self,
        mut handler: AeronAvailableCounterHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_available_counter(
                self.get_inner(),
                Some(
                    aeron_on_available_counter_t_callback_for_once_closure::<
                        AeronAvailableCounterHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_available_counter(&self) -> aeron_on_available_counter_t {
        unsafe {
            let result = aeron_context_get_on_available_counter(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_available_counter_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_available_counter_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_unavailable_counter<
        AeronUnavailableCounterHandlerImpl: AeronUnavailableCounterCallback,
    >(
        &self,
        handler: Option<&Handler<AeronUnavailableCounterHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_unavailable_counter(
                self.get_inner(),
                {
                    let callback: aeron_on_unavailable_counter_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_on_unavailable_counter_t_callback::<
                                AeronUnavailableCounterHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_unavailable_counter_once<
        AeronUnavailableCounterHandlerImpl: FnMut(AeronCountersReader, i64, i32) -> (),
    >(
        &self,
        mut handler: AeronUnavailableCounterHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_unavailable_counter(
                self.get_inner(),
                Some(
                    aeron_on_unavailable_counter_t_callback_for_once_closure::<
                        AeronUnavailableCounterHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_unavailable_counter(&self) -> aeron_on_unavailable_counter_t {
        unsafe {
            let result = aeron_context_get_on_unavailable_counter(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_unavailable_counter_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_unavailable_counter_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_on_close_client<AeronCloseClientHandlerImpl: AeronCloseClientCallback>(
        &self,
        handler: Option<&Handler<AeronCloseClientHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_close_client(
                self.get_inner(),
                {
                    let callback: aeron_on_close_client_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_on_close_client_t_callback::<AeronCloseClientHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_on_close_client_once<AeronCloseClientHandlerImpl: FnMut() -> ()>(
        &self,
        mut handler: AeronCloseClientHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_on_close_client(
                self.get_inner(),
                Some(
                    aeron_on_close_client_t_callback_for_once_closure::<AeronCloseClientHandlerImpl>,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_on_close_client(&self) -> aeron_on_close_client_t {
        unsafe {
            let result = aeron_context_get_on_close_client(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_on_close_client_clientd(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_on_close_client_clientd(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Whether to use an invoker to control the conductor agent or spawn a thread."]
    pub fn set_use_conductor_agent_invoker(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_context_set_use_conductor_agent_invoker(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_use_conductor_agent_invoker(&self) -> bool {
        unsafe {
            let result = aeron_context_get_use_conductor_agent_invoker(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_agent_on_start_function<
        AeronAgentStartFuncHandlerImpl: AeronAgentStartFuncCallback,
    >(
        &self,
        value: Option<&Handler<AeronAgentStartFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_agent_on_start_function(
                self.get_inner(),
                {
                    let callback: aeron_agent_on_start_func_t = if value.is_none() {
                        None
                    } else {
                        Some(aeron_agent_on_start_func_t_callback::<AeronAgentStartFuncHandlerImpl>)
                    };
                    callback
                },
                value
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_agent_on_start_function_once<AeronAgentStartFuncHandlerImpl: FnMut(&str) -> ()>(
        &self,
        mut value: AeronAgentStartFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_set_agent_on_start_function(
                self.get_inner(),
                Some(
                    aeron_agent_on_start_func_t_callback_for_once_closure::<
                        AeronAgentStartFuncHandlerImpl,
                    >,
                ),
                &mut value as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_agent_on_start_function(&self) -> aeron_agent_on_start_func_t {
        unsafe {
            let result = aeron_context_get_agent_on_start_function(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_agent_on_start_state(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_context_get_agent_on_start_state(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Close and delete `AeronContext` struct."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_context_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Request the media driver terminates operation and closes all resources."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `directory`    in which the media driver is running."]
    #[doc = " \n - `token_buffer` containing the authentication token confirming the client is allowed to terminate the driver."]
    #[doc = " \n - `token_length` of the token in the buffer."]
    #[doc = " \n# Return\n"]
    pub fn request_driver_termination(
        directory: &std::ffi::CStr,
        token_buffer: *const u8,
        token_length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_context_request_driver_termination(
                directory.as_ptr(),
                token_buffer.into(),
                token_length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_context_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_context_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_context_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronContext {
    type Target = aeron_context_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_context_t> for AeronContext {
    #[inline]
    fn from(value: *mut aeron_context_t) -> Self {
        AeronContext {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronContext> for *mut aeron_context_t {
    #[inline]
    fn from(value: AeronContext) -> Self {
        value.get_inner()
    }
}
impl From<&AeronContext> for *mut aeron_context_t {
    #[inline]
    fn from(value: &AeronContext) -> Self {
        value.get_inner()
    }
}
impl From<AeronContext> for aeron_context_t {
    #[inline]
    fn from(value: AeronContext) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_context_t> for AeronContext {
    #[inline]
    fn from(value: *const aeron_context_t) -> Self {
        AeronContext {
            inner: CResource::Borrowed(value as *mut aeron_context_t),
        }
    }
}
impl From<aeron_context_t> for AeronContext {
    #[inline]
    fn from(value: aeron_context_t) -> Self {
        AeronContext {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronControlledFragmentAssembler {
    inner: CResource<aeron_controlled_fragment_assembler_t>,
}
impl core::fmt::Debug for AeronControlledFragmentAssembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronControlledFragmentAssembler))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronControlledFragmentAssembler))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronControlledFragmentAssembler {
    #[doc = "Create a controlled fragment assembler for use with a subscription."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `delegate` to call on completed"]
    #[doc = " \n - `delegate_clientd` to pass to delegate handler."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        delegate: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let (delegate, delegate_clientd) = (
            {
                let callback: aeron_controlled_fragment_handler_t = if delegate.is_none() {
                    None
                } else {
                    Some(
                        aeron_controlled_fragment_handler_t_callback::<
                            AeronControlledFragmentHandlerHandlerImpl,
                        >,
                    )
                };
                callback
            },
            delegate
                .map(|m| m.as_raw())
                .unwrap_or_else(|| std::ptr::null_mut()),
        );
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_controlled_fragment_assembler_create(ctx_field, delegate, delegate_clientd)
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_controlled_fragment_assembler_delete(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    #[doc = "Delete a controlled fragment assembler."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_controlled_fragment_assembler_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Handler function to be passed for handling fragment assembly."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `clientd` passed in the poll call (must be a `AeronControlledFragmentAssembler`)"]
    #[doc = " \n - `buffer` containing the data."]
    #[doc = " \n - `header` representing the meta data for the data."]
    #[doc = " \n# Return\n The action to be taken with regard to the stream position after the callback."]
    pub fn handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: &[u8],
        header: &AeronHeader,
    ) -> aeron_controlled_fragment_handler_action_t {
        unsafe {
            let result = aeron_controlled_fragment_assembler_handler(
                clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                header.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_controlled_fragment_assembler_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_controlled_fragment_assembler_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_controlled_fragment_assembler_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronControlledFragmentAssembler {
    type Target = aeron_controlled_fragment_assembler_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_controlled_fragment_assembler_t> for AeronControlledFragmentAssembler {
    #[inline]
    fn from(value: *mut aeron_controlled_fragment_assembler_t) -> Self {
        AeronControlledFragmentAssembler {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronControlledFragmentAssembler> for *mut aeron_controlled_fragment_assembler_t {
    #[inline]
    fn from(value: AeronControlledFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<&AeronControlledFragmentAssembler> for *mut aeron_controlled_fragment_assembler_t {
    #[inline]
    fn from(value: &AeronControlledFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<AeronControlledFragmentAssembler> for aeron_controlled_fragment_assembler_t {
    #[inline]
    fn from(value: AeronControlledFragmentAssembler) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_controlled_fragment_assembler_t> for AeronControlledFragmentAssembler {
    #[inline]
    fn from(value: *const aeron_controlled_fragment_assembler_t) -> Self {
        AeronControlledFragmentAssembler {
            inner: CResource::Borrowed(value as *mut aeron_controlled_fragment_assembler_t),
        }
    }
}
impl From<aeron_controlled_fragment_assembler_t> for AeronControlledFragmentAssembler {
    #[inline]
    fn from(value: aeron_controlled_fragment_assembler_t) -> Self {
        AeronControlledFragmentAssembler {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronCorrelatedCommand {
    inner: CResource<aeron_correlated_command_t>,
}
impl core::fmt::Debug for AeronCorrelatedCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCorrelatedCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCorrelatedCommand))
                .field("inner", &self.inner)
                .field(stringify!(client_id), &self.client_id())
                .field(stringify!(correlation_id), &self.correlation_id())
                .finish()
        }
    }
}
impl AeronCorrelatedCommand {
    #[inline]
    pub fn new(client_id: i64, correlation_id: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_correlated_command_t {
                    client_id: client_id.into(),
                    correlation_id: correlation_id.into(),
                };
                let inner_ptr: *mut aeron_correlated_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_correlated_command_t)
                );
                let inst: aeron_correlated_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_correlated_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_correlated_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn client_id(&self) -> i64 {
        self.client_id.into()
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_correlated_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_correlated_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_correlated_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCorrelatedCommand {
    type Target = aeron_correlated_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_correlated_command_t> for AeronCorrelatedCommand {
    #[inline]
    fn from(value: *mut aeron_correlated_command_t) -> Self {
        AeronCorrelatedCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCorrelatedCommand> for *mut aeron_correlated_command_t {
    #[inline]
    fn from(value: AeronCorrelatedCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCorrelatedCommand> for *mut aeron_correlated_command_t {
    #[inline]
    fn from(value: &AeronCorrelatedCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronCorrelatedCommand> for aeron_correlated_command_t {
    #[inline]
    fn from(value: AeronCorrelatedCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_correlated_command_t> for AeronCorrelatedCommand {
    #[inline]
    fn from(value: *const aeron_correlated_command_t) -> Self {
        AeronCorrelatedCommand {
            inner: CResource::Borrowed(value as *mut aeron_correlated_command_t),
        }
    }
}
impl From<aeron_correlated_command_t> for AeronCorrelatedCommand {
    #[inline]
    fn from(value: aeron_correlated_command_t) -> Self {
        AeronCorrelatedCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCorrelatedCommand {
    fn default() -> Self {
        AeronCorrelatedCommand::new_zeroed_on_heap()
    }
}
impl AeronCorrelatedCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCounterCommand {
    inner: CResource<aeron_counter_command_t>,
}
impl core::fmt::Debug for AeronCounterCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(type_id), &self.type_id())
                .finish()
        }
    }
}
impl AeronCounterCommand {
    #[inline]
    pub fn new(correlated: AeronCorrelatedCommand, type_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_command_t {
                    correlated: correlated.into(),
                    type_id: type_id.into(),
                };
                let inner_ptr: *mut aeron_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_command_t)
                );
                let inst: aeron_counter_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn type_id(&self) -> i32 {
        self.type_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterCommand {
    type Target = aeron_counter_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_command_t> for AeronCounterCommand {
    #[inline]
    fn from(value: *mut aeron_counter_command_t) -> Self {
        AeronCounterCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterCommand> for *mut aeron_counter_command_t {
    #[inline]
    fn from(value: AeronCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterCommand> for *mut aeron_counter_command_t {
    #[inline]
    fn from(value: &AeronCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterCommand> for aeron_counter_command_t {
    #[inline]
    fn from(value: AeronCounterCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_command_t> for AeronCounterCommand {
    #[inline]
    fn from(value: *const aeron_counter_command_t) -> Self {
        AeronCounterCommand {
            inner: CResource::Borrowed(value as *mut aeron_counter_command_t),
        }
    }
}
impl From<aeron_counter_command_t> for AeronCounterCommand {
    #[inline]
    fn from(value: aeron_counter_command_t) -> Self {
        AeronCounterCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterCommand {
    fn default() -> Self {
        AeronCounterCommand::new_zeroed_on_heap()
    }
}
impl AeronCounterCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[doc = "Configuration for a counter that does not change during it's lifetime."]
#[derive(Clone)]
pub struct AeronCounterConstants {
    inner: CResource<aeron_counter_constants_t>,
}
impl core::fmt::Debug for AeronCounterConstants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterConstants))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterConstants))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(counter_id), &self.counter_id())
                .finish()
        }
    }
}
impl AeronCounterConstants {
    #[inline]
    pub fn new(registration_id: i64, counter_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_constants_t {
                    registration_id: registration_id.into(),
                    counter_id: counter_id.into(),
                };
                let inner_ptr: *mut aeron_counter_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_constants_t)
                );
                let inst: aeron_counter_constants_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_constants_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_constants_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_constants_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_constants_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterConstants {
    type Target = aeron_counter_constants_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_constants_t> for AeronCounterConstants {
    #[inline]
    fn from(value: *mut aeron_counter_constants_t) -> Self {
        AeronCounterConstants {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterConstants> for *mut aeron_counter_constants_t {
    #[inline]
    fn from(value: AeronCounterConstants) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterConstants> for *mut aeron_counter_constants_t {
    #[inline]
    fn from(value: &AeronCounterConstants) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterConstants> for aeron_counter_constants_t {
    #[inline]
    fn from(value: AeronCounterConstants) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_constants_t> for AeronCounterConstants {
    #[inline]
    fn from(value: *const aeron_counter_constants_t) -> Self {
        AeronCounterConstants {
            inner: CResource::Borrowed(value as *mut aeron_counter_constants_t),
        }
    }
}
impl From<aeron_counter_constants_t> for AeronCounterConstants {
    #[inline]
    fn from(value: aeron_counter_constants_t) -> Self {
        AeronCounterConstants {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterConstants {
    fn default() -> Self {
        AeronCounterConstants::new_zeroed_on_heap()
    }
}
impl AeronCounterConstants {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCounterLink {
    inner: CResource<aeron_counter_link_t>,
}
impl core::fmt::Debug for AeronCounterLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterLink))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterLink))
                .field("inner", &self.inner)
                .field(stringify!(counter_id), &self.counter_id())
                .field(stringify!(registration_id), &self.registration_id())
                .finish()
        }
    }
}
impl AeronCounterLink {
    #[inline]
    pub fn new(counter_id: i32, registration_id: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_link_t {
                    counter_id: counter_id.into(),
                    registration_id: registration_id.into(),
                };
                let inner_ptr: *mut aeron_counter_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_link_t)
                );
                let inst: aeron_counter_link_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_link_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_link_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_link_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_link_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterLink {
    type Target = aeron_counter_link_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_link_t> for AeronCounterLink {
    #[inline]
    fn from(value: *mut aeron_counter_link_t) -> Self {
        AeronCounterLink {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterLink> for *mut aeron_counter_link_t {
    #[inline]
    fn from(value: AeronCounterLink) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterLink> for *mut aeron_counter_link_t {
    #[inline]
    fn from(value: &AeronCounterLink) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterLink> for aeron_counter_link_t {
    #[inline]
    fn from(value: AeronCounterLink) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_link_t> for AeronCounterLink {
    #[inline]
    fn from(value: *const aeron_counter_link_t) -> Self {
        AeronCounterLink {
            inner: CResource::Borrowed(value as *mut aeron_counter_link_t),
        }
    }
}
impl From<aeron_counter_link_t> for AeronCounterLink {
    #[inline]
    fn from(value: aeron_counter_link_t) -> Self {
        AeronCounterLink {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterLink {
    fn default() -> Self {
        AeronCounterLink::new_zeroed_on_heap()
    }
}
impl AeronCounterLink {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCounterMetadataDescriptor {
    inner: CResource<aeron_counter_metadata_descriptor_t>,
}
impl core::fmt::Debug for AeronCounterMetadataDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterMetadataDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterMetadataDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(state), &self.state())
                .field(stringify!(type_id), &self.type_id())
                .field(
                    stringify!(free_for_reuse_deadline_ms),
                    &self.free_for_reuse_deadline_ms(),
                )
                .field(stringify!(label_length), &self.label_length())
                .finish()
        }
    }
}
impl AeronCounterMetadataDescriptor {
    #[inline]
    pub fn new(
        state: i32,
        type_id: i32,
        free_for_reuse_deadline_ms: i64,
        key: [u8; 112usize],
        label_length: i32,
        label: [u8; 380usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_metadata_descriptor_t {
                    state: state.into(),
                    type_id: type_id.into(),
                    free_for_reuse_deadline_ms: free_for_reuse_deadline_ms.into(),
                    key: key.into(),
                    label_length: label_length.into(),
                    label: label.into(),
                };
                let inner_ptr: *mut aeron_counter_metadata_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_metadata_descriptor_t)
                );
                let inst: aeron_counter_metadata_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_metadata_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_metadata_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn state(&self) -> i32 {
        self.state.into()
    }
    #[inline]
    pub fn type_id(&self) -> i32 {
        self.type_id.into()
    }
    #[inline]
    pub fn free_for_reuse_deadline_ms(&self) -> i64 {
        self.free_for_reuse_deadline_ms.into()
    }
    #[inline]
    pub fn key(&self) -> [u8; 112usize] {
        self.key.into()
    }
    #[inline]
    pub fn label_length(&self) -> i32 {
        self.label_length.into()
    }
    #[inline]
    pub fn label(&self) -> [u8; 380usize] {
        self.label.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_metadata_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_metadata_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_metadata_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterMetadataDescriptor {
    type Target = aeron_counter_metadata_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_metadata_descriptor_t> for AeronCounterMetadataDescriptor {
    #[inline]
    fn from(value: *mut aeron_counter_metadata_descriptor_t) -> Self {
        AeronCounterMetadataDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterMetadataDescriptor> for *mut aeron_counter_metadata_descriptor_t {
    #[inline]
    fn from(value: AeronCounterMetadataDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterMetadataDescriptor> for *mut aeron_counter_metadata_descriptor_t {
    #[inline]
    fn from(value: &AeronCounterMetadataDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterMetadataDescriptor> for aeron_counter_metadata_descriptor_t {
    #[inline]
    fn from(value: AeronCounterMetadataDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_metadata_descriptor_t> for AeronCounterMetadataDescriptor {
    #[inline]
    fn from(value: *const aeron_counter_metadata_descriptor_t) -> Self {
        AeronCounterMetadataDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_counter_metadata_descriptor_t),
        }
    }
}
impl From<aeron_counter_metadata_descriptor_t> for AeronCounterMetadataDescriptor {
    #[inline]
    fn from(value: aeron_counter_metadata_descriptor_t) -> Self {
        AeronCounterMetadataDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterMetadataDescriptor {
    fn default() -> Self {
        AeronCounterMetadataDescriptor::new_zeroed_on_heap()
    }
}
impl AeronCounterMetadataDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCounter {
    inner: CResource<aeron_counter_t>,
}
impl core::fmt::Debug for AeronCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounter))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronCounter {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_t)
                );
                let inst: aeron_counter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            Some(|c| unsafe { aeron_counter_is_closed(c) }),
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Return a pointer to the counter value."]
    #[doc = ""]
    #[doc = " \n# Return\n pointer to the counter value."]
    pub fn addr(&self) -> &mut i64 {
        unsafe {
            let result = aeron_counter_addr(self.get_inner());
            unsafe { &mut *result }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a counter."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `counter` to get the constants for."]
    #[doc = " \n - `constants` structure to fill in with the constants."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn constants(&self, constants: &AeronCounterConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_counter_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a counter."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronCounterConstants, AeronCError> {
        let result = AeronCounterConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Asynchronously close the counter."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn close<AeronNotificationHandlerImpl: AeronNotificationCallback>(
        &self,
        on_close_complete: Option<&Handler<AeronNotificationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_counter_close(
                self.get_inner(),
                {
                    let callback: aeron_notification_t = if on_close_complete.is_none() {
                        None
                    } else {
                        Some(aeron_notification_t_callback::<AeronNotificationHandlerImpl>)
                    };
                    callback
                },
                on_close_complete
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Asynchronously close the counter."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn close_once<AeronNotificationHandlerImpl: FnMut() -> ()>(
        &self,
        mut on_close_complete: AeronNotificationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_counter_close(
                self.get_inner(),
                Some(
                    aeron_notification_t_callback_for_once_closure::<AeronNotificationHandlerImpl>,
                ),
                &mut on_close_complete as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Check if the counter is closed"]
    #[doc = " \n# Return\n true if closed, false otherwise."]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_counter_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounter {
    type Target = aeron_counter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_t> for AeronCounter {
    #[inline]
    fn from(value: *mut aeron_counter_t) -> Self {
        AeronCounter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounter> for *mut aeron_counter_t {
    #[inline]
    fn from(value: AeronCounter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounter> for *mut aeron_counter_t {
    #[inline]
    fn from(value: &AeronCounter) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounter> for aeron_counter_t {
    #[inline]
    fn from(value: AeronCounter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_t> for AeronCounter {
    #[inline]
    fn from(value: *const aeron_counter_t) -> Self {
        AeronCounter {
            inner: CResource::Borrowed(value as *mut aeron_counter_t),
        }
    }
}
impl From<aeron_counter_t> for AeronCounter {
    #[inline]
    fn from(value: aeron_counter_t) -> Self {
        AeronCounter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronCounter {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronCounter));
                    let result = self.close_with_no_args();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronCounter));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronCounterUpdate {
    inner: CResource<aeron_counter_update_t>,
}
impl core::fmt::Debug for AeronCounterUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterUpdate))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterUpdate))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(counter_id), &self.counter_id())
                .finish()
        }
    }
}
impl AeronCounterUpdate {
    #[inline]
    pub fn new(correlation_id: i64, counter_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_update_t {
                    correlation_id: correlation_id.into(),
                    counter_id: counter_id.into(),
                };
                let inner_ptr: *mut aeron_counter_update_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_update_t)
                );
                let inst: aeron_counter_update_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_update_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_update_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_update_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_update_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_update_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterUpdate {
    type Target = aeron_counter_update_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_update_t> for AeronCounterUpdate {
    #[inline]
    fn from(value: *mut aeron_counter_update_t) -> Self {
        AeronCounterUpdate {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterUpdate> for *mut aeron_counter_update_t {
    #[inline]
    fn from(value: AeronCounterUpdate) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterUpdate> for *mut aeron_counter_update_t {
    #[inline]
    fn from(value: &AeronCounterUpdate) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterUpdate> for aeron_counter_update_t {
    #[inline]
    fn from(value: AeronCounterUpdate) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_update_t> for AeronCounterUpdate {
    #[inline]
    fn from(value: *const aeron_counter_update_t) -> Self {
        AeronCounterUpdate {
            inner: CResource::Borrowed(value as *mut aeron_counter_update_t),
        }
    }
}
impl From<aeron_counter_update_t> for AeronCounterUpdate {
    #[inline]
    fn from(value: aeron_counter_update_t) -> Self {
        AeronCounterUpdate {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterUpdate {
    fn default() -> Self {
        AeronCounterUpdate::new_zeroed_on_heap()
    }
}
impl AeronCounterUpdate {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCounterValueDescriptor {
    inner: CResource<aeron_counter_value_descriptor_t>,
}
impl core::fmt::Debug for AeronCounterValueDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCounterValueDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCounterValueDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(counter_value), &self.counter_value())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(owner_id), &self.owner_id())
                .field(stringify!(reference_id), &self.reference_id())
                .finish()
        }
    }
}
impl AeronCounterValueDescriptor {
    #[inline]
    pub fn new(
        counter_value: i64,
        registration_id: i64,
        owner_id: i64,
        reference_id: i64,
        pad1: [u8; 96usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counter_value_descriptor_t {
                    counter_value: counter_value.into(),
                    registration_id: registration_id.into(),
                    owner_id: owner_id.into(),
                    reference_id: reference_id.into(),
                    pad1: pad1.into(),
                };
                let inner_ptr: *mut aeron_counter_value_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counter_value_descriptor_t)
                );
                let inst: aeron_counter_value_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counter_value_descriptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counter_value_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn counter_value(&self) -> i64 {
        self.counter_value.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn owner_id(&self) -> i64 {
        self.owner_id.into()
    }
    #[inline]
    pub fn reference_id(&self) -> i64 {
        self.reference_id.into()
    }
    #[inline]
    pub fn pad1(&self) -> [u8; 96usize] {
        self.pad1.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counter_value_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counter_value_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counter_value_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCounterValueDescriptor {
    type Target = aeron_counter_value_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counter_value_descriptor_t> for AeronCounterValueDescriptor {
    #[inline]
    fn from(value: *mut aeron_counter_value_descriptor_t) -> Self {
        AeronCounterValueDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCounterValueDescriptor> for *mut aeron_counter_value_descriptor_t {
    #[inline]
    fn from(value: AeronCounterValueDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCounterValueDescriptor> for *mut aeron_counter_value_descriptor_t {
    #[inline]
    fn from(value: &AeronCounterValueDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronCounterValueDescriptor> for aeron_counter_value_descriptor_t {
    #[inline]
    fn from(value: AeronCounterValueDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counter_value_descriptor_t> for AeronCounterValueDescriptor {
    #[inline]
    fn from(value: *const aeron_counter_value_descriptor_t) -> Self {
        AeronCounterValueDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_counter_value_descriptor_t),
        }
    }
}
impl From<aeron_counter_value_descriptor_t> for AeronCounterValueDescriptor {
    #[inline]
    fn from(value: aeron_counter_value_descriptor_t) -> Self {
        AeronCounterValueDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCounterValueDescriptor {
    fn default() -> Self {
        AeronCounterValueDescriptor::new_zeroed_on_heap()
    }
}
impl AeronCounterValueDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCountersManager {
    inner: CResource<aeron_counters_manager_t>,
}
impl core::fmt::Debug for AeronCountersManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCountersManager))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCountersManager))
                .field("inner", &self.inner)
                .field(stringify!(values_length), &self.values_length())
                .field(stringify!(metadata_length), &self.metadata_length())
                .field(stringify!(max_counter_id), &self.max_counter_id())
                .field(stringify!(id_high_water_mark), &self.id_high_water_mark())
                .field(stringify!(free_list_index), &self.free_list_index())
                .field(stringify!(free_list_length), &self.free_list_length())
                .field(
                    stringify!(free_to_reuse_timeout_ms),
                    &self.free_to_reuse_timeout_ms(),
                )
                .finish()
        }
    }
}
impl AeronCountersManager {
    #[inline]
    pub fn new(
        values: *mut u8,
        metadata: *mut u8,
        values_length: usize,
        metadata_length: usize,
        max_counter_id: i32,
        id_high_water_mark: i32,
        free_list: &mut i32,
        free_list_index: i32,
        free_list_length: usize,
        cached_clock: &AeronClockCache,
        free_to_reuse_timeout_ms: i64,
    ) -> Result<Self, AeronCError> {
        let cached_clock_copy = cached_clock.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counters_manager_t {
                    values: values.into(),
                    metadata: metadata.into(),
                    values_length: values_length.into(),
                    metadata_length: metadata_length.into(),
                    max_counter_id: max_counter_id.into(),
                    id_high_water_mark: id_high_water_mark.into(),
                    free_list: free_list as *mut _,
                    free_list_index: free_list_index.into(),
                    free_list_length: free_list_length.into(),
                    cached_clock: cached_clock.into(),
                    free_to_reuse_timeout_ms: free_to_reuse_timeout_ms.into(),
                };
                let inner_ptr: *mut aeron_counters_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counters_manager_t)
                );
                let inst: aeron_counters_manager_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counters_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counters_manager_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn values(&self) -> *mut u8 {
        self.values.into()
    }
    #[inline]
    pub fn metadata(&self) -> *mut u8 {
        self.metadata.into()
    }
    #[inline]
    pub fn values_length(&self) -> usize {
        self.values_length.into()
    }
    #[inline]
    pub fn metadata_length(&self) -> usize {
        self.metadata_length.into()
    }
    #[inline]
    pub fn max_counter_id(&self) -> i32 {
        self.max_counter_id.into()
    }
    #[inline]
    pub fn id_high_water_mark(&self) -> i32 {
        self.id_high_water_mark.into()
    }
    #[inline]
    pub fn free_list(&self) -> &mut i32 {
        unsafe { &mut *self.free_list }
    }
    #[inline]
    pub fn free_list_index(&self) -> i32 {
        self.free_list_index.into()
    }
    #[inline]
    pub fn free_list_length(&self) -> usize {
        self.free_list_length.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn free_to_reuse_timeout_ms(&self) -> i64 {
        self.free_to_reuse_timeout_ms.into()
    }
    #[inline]
    pub fn init(
        &self,
        metadata_buffer: *mut u8,
        metadata_length: usize,
        values_buffer: *mut u8,
        values_length: usize,
        cached_clock: &AeronClockCache,
        free_to_reuse_timeout_ms: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_counters_manager_init(
                self.get_inner(),
                metadata_buffer.into(),
                metadata_length.into(),
                values_buffer.into(),
                values_length.into(),
                cached_clock.get_inner(),
                free_to_reuse_timeout_ms.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_counters_manager_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn allocate(&self, type_id: i32, key: &[u8], label: &str) -> i32 {
        unsafe {
            let result = aeron_counters_manager_allocate(
                self.get_inner(),
                type_id.into(),
                key.as_ptr() as *mut _,
                key.len(),
                label.as_ptr() as *const _,
                label.len(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn counter_registration_id(&self, counter_id: i32, registration_id: i64) -> () {
        unsafe {
            let result = aeron_counters_manager_counter_registration_id(
                self.get_inner(),
                counter_id.into(),
                registration_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn counter_owner_id(&self, counter_id: i32, owner_id: i64) -> () {
        unsafe {
            let result = aeron_counters_manager_counter_owner_id(
                self.get_inner(),
                counter_id.into(),
                owner_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn counter_reference_id(&self, counter_id: i32, reference_id: i64) -> () {
        unsafe {
            let result = aeron_counters_manager_counter_reference_id(
                self.get_inner(),
                counter_id.into(),
                reference_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn update_label(&self, counter_id: i32, label_length: usize, label: &std::ffi::CStr) -> () {
        unsafe {
            let result = aeron_counters_manager_update_label(
                self.get_inner(),
                counter_id.into(),
                label_length.into(),
                label.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn append_to_label(&self, counter_id: i32, length: usize, value: &std::ffi::CStr) -> () {
        unsafe {
            let result = aeron_counters_manager_append_to_label(
                self.get_inner(),
                counter_id.into(),
                length.into(),
                value.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn next_counter_id(&self) -> i32 {
        unsafe {
            let result = aeron_counters_manager_next_counter_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn free(&self, counter_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_counters_manager_free(self.get_inner(), counter_id.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_ipc_publication_close(&self, publication: &AeronIpcPublication) -> () {
        unsafe {
            let result = aeron_ipc_publication_close(self.get_inner(), publication.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_close(&self, publication: &AeronNetworkPublication) -> () {
        unsafe {
            let result = aeron_network_publication_close(self.get_inner(), publication.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_delete(
        &self,
        endpoint: &AeronSendChannelEndpoint,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_delete(self.get_inner(), endpoint.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_receive_channel_endpoint_delete(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_receive_channel_endpoint_delete(self.get_inner(), endpoint.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_publication_image_close(
        &self,
        image: &AeronPublicationImage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_close(self.get_inner(), image.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counters_manager_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counters_manager_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counters_manager_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCountersManager {
    type Target = aeron_counters_manager_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counters_manager_t> for AeronCountersManager {
    #[inline]
    fn from(value: *mut aeron_counters_manager_t) -> Self {
        AeronCountersManager {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCountersManager> for *mut aeron_counters_manager_t {
    #[inline]
    fn from(value: AeronCountersManager) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCountersManager> for *mut aeron_counters_manager_t {
    #[inline]
    fn from(value: &AeronCountersManager) -> Self {
        value.get_inner()
    }
}
impl From<AeronCountersManager> for aeron_counters_manager_t {
    #[inline]
    fn from(value: AeronCountersManager) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counters_manager_t> for AeronCountersManager {
    #[inline]
    fn from(value: *const aeron_counters_manager_t) -> Self {
        AeronCountersManager {
            inner: CResource::Borrowed(value as *mut aeron_counters_manager_t),
        }
    }
}
impl From<aeron_counters_manager_t> for AeronCountersManager {
    #[inline]
    fn from(value: aeron_counters_manager_t) -> Self {
        AeronCountersManager {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCountersManager {
    fn default() -> Self {
        AeronCountersManager::new_zeroed_on_heap()
    }
}
impl AeronCountersManager {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCountersReaderBuffers {
    inner: CResource<aeron_counters_reader_buffers_t>,
}
impl core::fmt::Debug for AeronCountersReaderBuffers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCountersReaderBuffers))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCountersReaderBuffers))
                .field("inner", &self.inner)
                .field(stringify!(values_length), &self.values_length())
                .field(stringify!(metadata_length), &self.metadata_length())
                .finish()
        }
    }
}
impl AeronCountersReaderBuffers {
    #[inline]
    pub fn new(
        values: *mut u8,
        metadata: *mut u8,
        values_length: usize,
        metadata_length: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_counters_reader_buffers_t {
                    values: values.into(),
                    metadata: metadata.into(),
                    values_length: values_length.into(),
                    metadata_length: metadata_length.into(),
                };
                let inner_ptr: *mut aeron_counters_reader_buffers_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counters_reader_buffers_t)
                );
                let inst: aeron_counters_reader_buffers_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counters_reader_buffers_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counters_reader_buffers_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn values(&self) -> *mut u8 {
        self.values.into()
    }
    #[inline]
    pub fn metadata(&self) -> *mut u8 {
        self.metadata.into()
    }
    #[inline]
    pub fn values_length(&self) -> usize {
        self.values_length.into()
    }
    #[inline]
    pub fn metadata_length(&self) -> usize {
        self.metadata_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counters_reader_buffers_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counters_reader_buffers_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counters_reader_buffers_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCountersReaderBuffers {
    type Target = aeron_counters_reader_buffers_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counters_reader_buffers_t> for AeronCountersReaderBuffers {
    #[inline]
    fn from(value: *mut aeron_counters_reader_buffers_t) -> Self {
        AeronCountersReaderBuffers {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCountersReaderBuffers> for *mut aeron_counters_reader_buffers_t {
    #[inline]
    fn from(value: AeronCountersReaderBuffers) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCountersReaderBuffers> for *mut aeron_counters_reader_buffers_t {
    #[inline]
    fn from(value: &AeronCountersReaderBuffers) -> Self {
        value.get_inner()
    }
}
impl From<AeronCountersReaderBuffers> for aeron_counters_reader_buffers_t {
    #[inline]
    fn from(value: AeronCountersReaderBuffers) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counters_reader_buffers_t> for AeronCountersReaderBuffers {
    #[inline]
    fn from(value: *const aeron_counters_reader_buffers_t) -> Self {
        AeronCountersReaderBuffers {
            inner: CResource::Borrowed(value as *mut aeron_counters_reader_buffers_t),
        }
    }
}
impl From<aeron_counters_reader_buffers_t> for AeronCountersReaderBuffers {
    #[inline]
    fn from(value: aeron_counters_reader_buffers_t) -> Self {
        AeronCountersReaderBuffers {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCountersReaderBuffers {
    fn default() -> Self {
        AeronCountersReaderBuffers::new_zeroed_on_heap()
    }
}
impl AeronCountersReaderBuffers {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCountersReader {
    inner: CResource<aeron_counters_reader_t>,
}
impl core::fmt::Debug for AeronCountersReader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCountersReader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCountersReader))
                .field("inner", &self.inner)
                .field(stringify!(values_length), &self.values_length())
                .field(stringify!(metadata_length), &self.metadata_length())
                .finish()
        }
    }
}
impl AeronCountersReader {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_counters_reader_t)
                );
                let inst: aeron_counters_reader_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_counters_reader_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_counters_reader_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn values(&self) -> *mut u8 {
        self.values.into()
    }
    #[inline]
    pub fn metadata(&self) -> *mut u8 {
        self.metadata.into()
    }
    #[inline]
    pub fn values_length(&self) -> usize {
        self.values_length.into()
    }
    #[inline]
    pub fn metadata_length(&self) -> usize {
        self.metadata_length.into()
    }
    #[inline]
    #[doc = "Get buffer pointers and lengths for the counters reader."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `reader` reader containing the buffers."]
    #[doc = " \n - `buffers` output structure to return the buffers."]
    #[doc = " \n# Return\n -1 on failure, 0 on success."]
    pub fn get_buffers(&self, buffers: &AeronCountersReaderBuffers) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_counters_reader_get_buffers(self.get_inner(), buffers.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Iterate over the counters in the counters_reader and call the given function for each counter."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `func` to call for each counter."]
    #[doc = " \n - `clientd` to pass for each call to func."]
    pub fn foreach_counter<
        AeronCountersReaderForeachCounterFuncHandlerImpl: AeronCountersReaderForeachCounterFuncCallback,
    >(
        &self,
        func: Option<&Handler<AeronCountersReaderForeachCounterFuncHandlerImpl>>,
    ) -> () {
        unsafe {
            let result = aeron_counters_reader_foreach_counter(
                self.get_inner(),
                {
                    let callback: aeron_counters_reader_foreach_counter_func_t = if func.is_none() {
                        None
                    } else {
                        Some(
                            aeron_counters_reader_foreach_counter_func_t_callback::<
                                AeronCountersReaderForeachCounterFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                func.map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Iterate over the counters in the counters_reader and call the given function for each counter."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `func` to call for each counter."]
    #[doc = " \n - `clientd` to pass for each call to func."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn foreach_counter_once<
        AeronCountersReaderForeachCounterFuncHandlerImpl: FnMut(i64, i32, i32, &[u8], &str) -> (),
    >(
        &self,
        mut func: AeronCountersReaderForeachCounterFuncHandlerImpl,
    ) -> () {
        unsafe {
            let result = aeron_counters_reader_foreach_counter(
                self.get_inner(),
                Some(
                    aeron_counters_reader_foreach_counter_func_t_callback_for_once_closure::<
                        AeronCountersReaderForeachCounterFuncHandlerImpl,
                    >,
                ),
                &mut func as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Iterate over allocated counters and find the first matching a given type id and registration id."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `type_id` to find."]
    #[doc = " \n - `registration_id` to find."]
    #[doc = " \n# Return\n the counter id if found otherwise AERON_NULL_COUNTER_ID."]
    pub fn find_by_type_id_and_registration_id(&self, type_id: i32, registration_id: i64) -> i32 {
        unsafe {
            let result = aeron_counters_reader_find_by_type_id_and_registration_id(
                self.get_inner(),
                type_id.into(),
                registration_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the current max counter id."]
    #[doc = ""]
    #[doc = " \n# Return\n -1 on failure, max counter id on success."]
    pub fn max_counter_id(&self) -> i32 {
        unsafe {
            let result = aeron_counters_reader_max_counter_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the address for a counter."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `counter_id` to find"]
    #[doc = " \n# Return\n address of the counter value"]
    pub fn addr(&self, counter_id: i32) -> &mut i64 {
        unsafe {
            let result = aeron_counters_reader_addr(self.get_inner(), counter_id.into());
            unsafe { &mut *result }
        }
    }
    #[inline]
    #[doc = "Get the registration id assigned to a counter."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id`      for which the registration id is requested."]
    #[doc = " \n - `registration_id` pointer for value to be set on success."]
    pub fn counter_registration_id(&self, counter_id: i32) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_counters_reader_counter_registration_id(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    #[doc = "Get the owner id assigned to a counter which will typically be the client id."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id`      for which the owner id is requested."]
    #[doc = " \n - `owner_id`        pointer for value to be set on success."]
    pub fn counter_owner_id(&self, counter_id: i32) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_counters_reader_counter_owner_id(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    #[doc = "Get the reference id assigned to a counter which will typically be the registration id of an associated Image,"]
    #[doc = " Subscription, Publication, etc."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id`      for which the reference id is requested."]
    #[doc = " \n - `reference_id`    pointer for value to be set on success."]
    pub fn counter_reference_id(&self, counter_id: i32) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_counters_reader_counter_reference_id(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    #[doc = "Get the state for a counter."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id` to find"]
    #[doc = " \n - `state` out pointer for the current state to be stored in."]
    pub fn counter_state(&self, counter_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let mut mut_result: i32 = Default::default();
            let err_code = aeron_counters_reader_counter_state(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    #[doc = "Get the type id for a counter."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id` to find"]
    pub fn counter_type_id(&self, counter_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let mut mut_result: i32 = Default::default();
            let err_code = aeron_counters_reader_counter_type_id(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    #[doc = "Get the label for a counter."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `counter_id` to find"]
    #[doc = " \n - `buffer` to store the counter in."]
    #[doc = " \n - `buffer_length` length of the output buffer"]
    #[doc = " \n# Return\n -1 on failure, number of characters copied to buffer on success."]
    pub fn counter_label(
        &self,
        counter_id: i32,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_counters_reader_counter_label(
                self.get_inner(),
                counter_id.into(),
                buffer.into(),
                buffer_length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Get the free for reuse deadline (ms) for a counter."]
    #[doc = ""]
    #[doc = "\n \n # Parameters
- `counter_id` to find."]
    #[doc = " \n - `deadline_ms` output value to store the deadline."]
    pub fn free_for_reuse_deadline_ms(&self, counter_id: i32) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_counters_reader_free_for_reuse_deadline_ms(
                self.get_inner(),
                counter_id.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn foreach_metadata<
        AeronCountersReaderForeachMetadataFuncHandlerImpl: AeronCountersReaderForeachMetadataFuncCallback,
    >(
        metadata_buffer: *mut u8,
        metadata_length: usize,
        func: Option<&Handler<AeronCountersReaderForeachMetadataFuncHandlerImpl>>,
    ) -> () {
        unsafe {
            let result = aeron_counters_reader_foreach_metadata(
                metadata_buffer.into(),
                metadata_length.into(),
                {
                    let callback: aeron_counters_reader_foreach_metadata_func_t = if func.is_none()
                    {
                        None
                    } else {
                        Some(
                            aeron_counters_reader_foreach_metadata_func_t_callback::<
                                AeronCountersReaderForeachMetadataFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                func.map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn foreach_metadata_once<
        AeronCountersReaderForeachMetadataFuncHandlerImpl: FnMut(i32, i32, &[u8], &[u8]) -> (),
    >(
        metadata_buffer: *mut u8,
        metadata_length: usize,
        mut func: AeronCountersReaderForeachMetadataFuncHandlerImpl,
    ) -> () {
        unsafe {
            let result = aeron_counters_reader_foreach_metadata(
                metadata_buffer.into(),
                metadata_length.into(),
                Some(
                    aeron_counters_reader_foreach_metadata_func_t_callback_for_once_closure::<
                        AeronCountersReaderForeachMetadataFuncHandlerImpl,
                    >,
                ),
                &mut func as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_counters_reader_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_counters_reader_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_counters_reader_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCountersReader {
    type Target = aeron_counters_reader_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_counters_reader_t> for AeronCountersReader {
    #[inline]
    fn from(value: *mut aeron_counters_reader_t) -> Self {
        AeronCountersReader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCountersReader> for *mut aeron_counters_reader_t {
    #[inline]
    fn from(value: AeronCountersReader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCountersReader> for *mut aeron_counters_reader_t {
    #[inline]
    fn from(value: &AeronCountersReader) -> Self {
        value.get_inner()
    }
}
impl From<AeronCountersReader> for aeron_counters_reader_t {
    #[inline]
    fn from(value: AeronCountersReader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_counters_reader_t> for AeronCountersReader {
    #[inline]
    fn from(value: *const aeron_counters_reader_t) -> Self {
        AeronCountersReader {
            inner: CResource::Borrowed(value as *mut aeron_counters_reader_t),
        }
    }
}
impl From<aeron_counters_reader_t> for AeronCountersReader {
    #[inline]
    fn from(value: aeron_counters_reader_t) -> Self {
        AeronCountersReader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronDataHeaderAsLongs {
    inner: CResource<aeron_data_header_as_longs_t>,
}
impl core::fmt::Debug for AeronDataHeaderAsLongs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDataHeaderAsLongs))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDataHeaderAsLongs))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDataHeaderAsLongs {
    #[inline]
    pub fn new(hdr: [u64; 4usize]) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_data_header_as_longs_t { hdr: hdr.into() };
                let inner_ptr: *mut aeron_data_header_as_longs_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_data_header_as_longs_t)
                );
                let inst: aeron_data_header_as_longs_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_data_header_as_longs_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_data_header_as_longs_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn hdr(&self) -> [u64; 4usize] {
        self.hdr.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_data_header_as_longs_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_data_header_as_longs_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_data_header_as_longs_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDataHeaderAsLongs {
    type Target = aeron_data_header_as_longs_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_data_header_as_longs_t> for AeronDataHeaderAsLongs {
    #[inline]
    fn from(value: *mut aeron_data_header_as_longs_t) -> Self {
        AeronDataHeaderAsLongs {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDataHeaderAsLongs> for *mut aeron_data_header_as_longs_t {
    #[inline]
    fn from(value: AeronDataHeaderAsLongs) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDataHeaderAsLongs> for *mut aeron_data_header_as_longs_t {
    #[inline]
    fn from(value: &AeronDataHeaderAsLongs) -> Self {
        value.get_inner()
    }
}
impl From<AeronDataHeaderAsLongs> for aeron_data_header_as_longs_t {
    #[inline]
    fn from(value: AeronDataHeaderAsLongs) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_data_header_as_longs_t> for AeronDataHeaderAsLongs {
    #[inline]
    fn from(value: *const aeron_data_header_as_longs_t) -> Self {
        AeronDataHeaderAsLongs {
            inner: CResource::Borrowed(value as *mut aeron_data_header_as_longs_t),
        }
    }
}
impl From<aeron_data_header_as_longs_t> for AeronDataHeaderAsLongs {
    #[inline]
    fn from(value: aeron_data_header_as_longs_t) -> Self {
        AeronDataHeaderAsLongs {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDataHeaderAsLongs {
    fn default() -> Self {
        AeronDataHeaderAsLongs::new_zeroed_on_heap()
    }
}
impl AeronDataHeaderAsLongs {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDataHeader {
    inner: CResource<aeron_data_header_t>,
}
impl core::fmt::Debug for AeronDataHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDataHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDataHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(reserved_value), &self.reserved_value())
                .finish()
        }
    }
}
impl AeronDataHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        term_offset: i32,
        session_id: i32,
        stream_id: i32,
        term_id: i32,
        reserved_value: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_data_header_t {
                    frame_header: frame_header.into(),
                    term_offset: term_offset.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    term_id: term_id.into(),
                    reserved_value: reserved_value.into(),
                };
                let inner_ptr: *mut aeron_data_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_data_header_t)
                );
                let inst: aeron_data_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_data_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_data_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn reserved_value(&self) -> i64 {
        self.reserved_value.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_data_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_data_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_data_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDataHeader {
    type Target = aeron_data_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_data_header_t> for AeronDataHeader {
    #[inline]
    fn from(value: *mut aeron_data_header_t) -> Self {
        AeronDataHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDataHeader> for *mut aeron_data_header_t {
    #[inline]
    fn from(value: AeronDataHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDataHeader> for *mut aeron_data_header_t {
    #[inline]
    fn from(value: &AeronDataHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronDataHeader> for aeron_data_header_t {
    #[inline]
    fn from(value: AeronDataHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_data_header_t> for AeronDataHeader {
    #[inline]
    fn from(value: *const aeron_data_header_t) -> Self {
        AeronDataHeader {
            inner: CResource::Borrowed(value as *mut aeron_data_header_t),
        }
    }
}
impl From<aeron_data_header_t> for AeronDataHeader {
    #[inline]
    fn from(value: aeron_data_header_t) -> Self {
        AeronDataHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDataHeader {
    fn default() -> Self {
        AeronDataHeader::new_zeroed_on_heap()
    }
}
impl AeronDataHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDataPacketDispatcherStreamInterest {
    inner: CResource<aeron_data_packet_dispatcher_stream_interest_t>,
}
impl core::fmt::Debug for AeronDataPacketDispatcherStreamInterest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDataPacketDispatcherStreamInterest))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDataPacketDispatcherStreamInterest))
                .field("inner", &self.inner)
                .field(stringify!(is_all_sessions), &self.is_all_sessions())
                .field(stringify!(subscribed_sessions), &self.subscribed_sessions())
                .field(
                    stringify!(image_by_session_id_map),
                    &self.image_by_session_id_map(),
                )
                .field(
                    stringify!(state_by_session_id_map),
                    &self.state_by_session_id_map(),
                )
                .finish()
        }
    }
}
impl AeronDataPacketDispatcherStreamInterest {
    #[inline]
    pub fn new(
        is_all_sessions: bool,
        subscribed_sessions: AeronInt64ToPtrHashMap,
        image_by_session_id_map: AeronInt64ToPtrHashMap,
        state_by_session_id_map: AeronInt64CounterMap,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_data_packet_dispatcher_stream_interest_t {
                    is_all_sessions: is_all_sessions.into(),
                    subscribed_sessions: subscribed_sessions.into(),
                    image_by_session_id_map: image_by_session_id_map.into(),
                    state_by_session_id_map: state_by_session_id_map.into(),
                };
                let inner_ptr: *mut aeron_data_packet_dispatcher_stream_interest_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_data_packet_dispatcher_stream_interest_t)
                );
                let inst: aeron_data_packet_dispatcher_stream_interest_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_data_packet_dispatcher_stream_interest_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_data_packet_dispatcher_stream_interest_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn is_all_sessions(&self) -> bool {
        self.is_all_sessions.into()
    }
    #[inline]
    pub fn subscribed_sessions(&self) -> AeronInt64ToPtrHashMap {
        self.subscribed_sessions.into()
    }
    #[inline]
    pub fn image_by_session_id_map(&self) -> AeronInt64ToPtrHashMap {
        self.image_by_session_id_map.into()
    }
    #[inline]
    pub fn state_by_session_id_map(&self) -> AeronInt64CounterMap {
        self.state_by_session_id_map.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_data_packet_dispatcher_stream_interest_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_data_packet_dispatcher_stream_interest_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_data_packet_dispatcher_stream_interest_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDataPacketDispatcherStreamInterest {
    type Target = aeron_data_packet_dispatcher_stream_interest_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_data_packet_dispatcher_stream_interest_t>
    for AeronDataPacketDispatcherStreamInterest
{
    #[inline]
    fn from(value: *mut aeron_data_packet_dispatcher_stream_interest_t) -> Self {
        AeronDataPacketDispatcherStreamInterest {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDataPacketDispatcherStreamInterest>
    for *mut aeron_data_packet_dispatcher_stream_interest_t
{
    #[inline]
    fn from(value: AeronDataPacketDispatcherStreamInterest) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDataPacketDispatcherStreamInterest>
    for *mut aeron_data_packet_dispatcher_stream_interest_t
{
    #[inline]
    fn from(value: &AeronDataPacketDispatcherStreamInterest) -> Self {
        value.get_inner()
    }
}
impl From<AeronDataPacketDispatcherStreamInterest>
    for aeron_data_packet_dispatcher_stream_interest_t
{
    #[inline]
    fn from(value: AeronDataPacketDispatcherStreamInterest) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_data_packet_dispatcher_stream_interest_t>
    for AeronDataPacketDispatcherStreamInterest
{
    #[inline]
    fn from(value: *const aeron_data_packet_dispatcher_stream_interest_t) -> Self {
        AeronDataPacketDispatcherStreamInterest {
            inner: CResource::Borrowed(
                value as *mut aeron_data_packet_dispatcher_stream_interest_t,
            ),
        }
    }
}
impl From<aeron_data_packet_dispatcher_stream_interest_t>
    for AeronDataPacketDispatcherStreamInterest
{
    #[inline]
    fn from(value: aeron_data_packet_dispatcher_stream_interest_t) -> Self {
        AeronDataPacketDispatcherStreamInterest {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDataPacketDispatcherStreamInterest {
    fn default() -> Self {
        AeronDataPacketDispatcherStreamInterest::new_zeroed_on_heap()
    }
}
impl AeronDataPacketDispatcherStreamInterest {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDataPacketDispatcher {
    inner: CResource<aeron_data_packet_dispatcher_t>,
}
impl core::fmt::Debug for AeronDataPacketDispatcher {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDataPacketDispatcher))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDataPacketDispatcher))
                .field("inner", &self.inner)
                .field(
                    stringify!(ignored_sessions_map),
                    &self.ignored_sessions_map(),
                )
                .field(
                    stringify!(session_by_stream_id_map),
                    &self.session_by_stream_id_map(),
                )
                .field(
                    stringify!(stream_session_limit),
                    &self.stream_session_limit(),
                )
                .finish()
        }
    }
}
impl AeronDataPacketDispatcher {
    #[inline]
    pub fn new(
        ignored_sessions_map: AeronInt64ToPtrHashMap,
        session_by_stream_id_map: AeronInt64ToPtrHashMap,
        tokens: aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct,
        conductor_proxy: &AeronDriverConductorProxy,
        receiver: &AeronDriverReceiver,
        stream_session_limit: i32,
    ) -> Result<Self, AeronCError> {
        let conductor_proxy_copy = conductor_proxy.clone();
        let receiver_copy = receiver.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_data_packet_dispatcher_t {
                    ignored_sessions_map: ignored_sessions_map.into(),
                    session_by_stream_id_map: session_by_stream_id_map.into(),
                    tokens: tokens.into(),
                    conductor_proxy: conductor_proxy.into(),
                    receiver: receiver.into(),
                    stream_session_limit: stream_session_limit.into(),
                };
                let inner_ptr: *mut aeron_data_packet_dispatcher_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_data_packet_dispatcher_t)
                );
                let inst: aeron_data_packet_dispatcher_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_data_packet_dispatcher_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_data_packet_dispatcher_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn ignored_sessions_map(&self) -> AeronInt64ToPtrHashMap {
        self.ignored_sessions_map.into()
    }
    #[inline]
    pub fn session_by_stream_id_map(&self) -> AeronInt64ToPtrHashMap {
        self.session_by_stream_id_map.into()
    }
    #[inline]
    pub fn tokens(
        &self,
    ) -> aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct {
        self.tokens.into()
    }
    #[inline]
    pub fn conductor_proxy(&self) -> AeronDriverConductorProxy {
        self.conductor_proxy.into()
    }
    #[inline]
    pub fn receiver(&self) -> AeronDriverReceiver {
        self.receiver.into()
    }
    #[inline]
    pub fn stream_session_limit(&self) -> i32 {
        self.stream_session_limit.into()
    }
    #[inline]
    pub fn init(
        &self,
        conductor_proxy: &AeronDriverConductorProxy,
        receiver: &AeronDriverReceiver,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_init(
                self.get_inner(),
                conductor_proxy.get_inner(),
                receiver.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_data_packet_dispatcher_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_subscription(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_data_packet_dispatcher_add_subscription(self.get_inner(), stream_id.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_subscription_by_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_add_subscription_by_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_subscription(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_remove_subscription(
                self.get_inner(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_subscription_by_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_remove_subscription_by_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_publication_image(&self, image: &AeronPublicationImage) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_add_publication_image(
                self.get_inner(),
                image.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_publication_image(
        &self,
        image: &AeronPublicationImage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_remove_publication_image(
                self.get_inner(),
                image.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn has_interest_in(&self, stream_id: i32, session_id: i32) -> bool {
        unsafe {
            let result = aeron_data_packet_dispatcher_has_interest_in(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_data(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        header: &AeronDataHeader,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_on_data(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                header.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_setup(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        header: &AeronSetupHeader,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_on_setup(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                header.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_rttm(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        header: &AeronRttmHeader,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_on_rttm(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                header.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn try_connect_stream(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        stream_id: i32,
        session_id: i32,
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_try_connect_stream(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                stream_id.into(),
                session_id.into(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn elicit_setup_from_source(
        &self,
        stream_interest: &AeronDataPacketDispatcherStreamInterest,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        addr: &SockaddrStorage,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_data_packet_dispatcher_elicit_setup_from_source(
                self.get_inner(),
                stream_interest.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                addr.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_pending_setup(&self, session_id: i32, stream_id: i32) -> () {
        unsafe {
            let result = aeron_data_packet_dispatcher_remove_pending_setup(
                self.get_inner(),
                session_id.into(),
                stream_id.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_data_packet_dispatcher_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_data_packet_dispatcher_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_data_packet_dispatcher_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDataPacketDispatcher {
    type Target = aeron_data_packet_dispatcher_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_data_packet_dispatcher_t> for AeronDataPacketDispatcher {
    #[inline]
    fn from(value: *mut aeron_data_packet_dispatcher_t) -> Self {
        AeronDataPacketDispatcher {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDataPacketDispatcher> for *mut aeron_data_packet_dispatcher_t {
    #[inline]
    fn from(value: AeronDataPacketDispatcher) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDataPacketDispatcher> for *mut aeron_data_packet_dispatcher_t {
    #[inline]
    fn from(value: &AeronDataPacketDispatcher) -> Self {
        value.get_inner()
    }
}
impl From<AeronDataPacketDispatcher> for aeron_data_packet_dispatcher_t {
    #[inline]
    fn from(value: AeronDataPacketDispatcher) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_data_packet_dispatcher_t> for AeronDataPacketDispatcher {
    #[inline]
    fn from(value: *const aeron_data_packet_dispatcher_t) -> Self {
        AeronDataPacketDispatcher {
            inner: CResource::Borrowed(value as *mut aeron_data_packet_dispatcher_t),
        }
    }
}
impl From<aeron_data_packet_dispatcher_t> for AeronDataPacketDispatcher {
    #[inline]
    fn from(value: aeron_data_packet_dispatcher_t) -> Self {
        AeronDataPacketDispatcher {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDataPacketDispatcher {
    fn default() -> Self {
        AeronDataPacketDispatcher::new_zeroed_on_heap()
    }
}
impl AeronDataPacketDispatcher {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDeque {
    inner: CResource<aeron_deque_t>,
}
impl core::fmt::Debug for AeronDeque {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDeque))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDeque))
                .field("inner", &self.inner)
                .field(stringify!(element_count), &self.element_count())
                .field(stringify!(element_size), &self.element_size())
                .field(stringify!(first_element), &self.first_element())
                .field(stringify!(last_element), &self.last_element())
                .finish()
        }
    }
}
impl AeronDeque {
    #[inline]
    pub fn new(
        data: *mut u8,
        element_count: usize,
        element_size: usize,
        first_element: usize,
        last_element: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_deque_t {
                    data: data.into(),
                    element_count: element_count.into(),
                    element_size: element_size.into(),
                    first_element: first_element.into(),
                    last_element: last_element.into(),
                };
                let inner_ptr: *mut aeron_deque_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_deque_t)
                );
                let inst: aeron_deque_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_deque_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_deque_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn data(&self) -> *mut u8 {
        self.data.into()
    }
    #[inline]
    pub fn element_count(&self) -> usize {
        self.element_count.into()
    }
    #[inline]
    pub fn element_size(&self) -> usize {
        self.element_size.into()
    }
    #[inline]
    pub fn first_element(&self) -> usize {
        self.first_element.into()
    }
    #[inline]
    pub fn last_element(&self) -> usize {
        self.last_element.into()
    }
    #[inline]
    pub fn init(
        &self,
        initial_element_count: usize,
        element_size: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_deque_init(
                self.get_inner(),
                initial_element_count.into(),
                element_size.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_deque_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Add value into the deque as the last element.  Will memcpy into the deque from the void pointer provided using"]
    #[doc = " the specified element size.  May need to allocate in order to increase the size of the dequeue."]
    #[doc = ""]
    #[doc = " Errors:"]
    #[doc = "   ENOMEM if growing the array fails."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `deque` to add the value too."]
    #[doc = " \n - `value` value to be added."]
    #[doc = " \n# Return\n 0 on success, -1 on failure."]
    pub fn add_last(&self, value: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_deque_add_last(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_first(&self, value: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_deque_remove_first(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_deque_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_deque_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_deque_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDeque {
    type Target = aeron_deque_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_deque_t> for AeronDeque {
    #[inline]
    fn from(value: *mut aeron_deque_t) -> Self {
        AeronDeque {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDeque> for *mut aeron_deque_t {
    #[inline]
    fn from(value: AeronDeque) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDeque> for *mut aeron_deque_t {
    #[inline]
    fn from(value: &AeronDeque) -> Self {
        value.get_inner()
    }
}
impl From<AeronDeque> for aeron_deque_t {
    #[inline]
    fn from(value: AeronDeque) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_deque_t> for AeronDeque {
    #[inline]
    fn from(value: *const aeron_deque_t) -> Self {
        AeronDeque {
            inner: CResource::Borrowed(value as *mut aeron_deque_t),
        }
    }
}
impl From<aeron_deque_t> for AeronDeque {
    #[inline]
    fn from(value: aeron_deque_t) -> Self {
        AeronDeque {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDeque {
    fn default() -> Self {
        AeronDeque::new_zeroed_on_heap()
    }
}
impl AeronDeque {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDestinationByIdCommand {
    inner: CResource<aeron_destination_by_id_command_t>,
}
impl core::fmt::Debug for AeronDestinationByIdCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDestinationByIdCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDestinationByIdCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(
                    stringify!(resource_registration_id),
                    &self.resource_registration_id(),
                )
                .field(
                    stringify!(destination_registration_id),
                    &self.destination_registration_id(),
                )
                .finish()
        }
    }
}
impl AeronDestinationByIdCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        resource_registration_id: i64,
        destination_registration_id: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_destination_by_id_command_t {
                    correlated: correlated.into(),
                    resource_registration_id: resource_registration_id.into(),
                    destination_registration_id: destination_registration_id.into(),
                };
                let inner_ptr: *mut aeron_destination_by_id_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_destination_by_id_command_t)
                );
                let inst: aeron_destination_by_id_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_destination_by_id_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_destination_by_id_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn resource_registration_id(&self) -> i64 {
        self.resource_registration_id.into()
    }
    #[inline]
    pub fn destination_registration_id(&self) -> i64 {
        self.destination_registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_destination_by_id_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_destination_by_id_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_destination_by_id_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDestinationByIdCommand {
    type Target = aeron_destination_by_id_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_destination_by_id_command_t> for AeronDestinationByIdCommand {
    #[inline]
    fn from(value: *mut aeron_destination_by_id_command_t) -> Self {
        AeronDestinationByIdCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDestinationByIdCommand> for *mut aeron_destination_by_id_command_t {
    #[inline]
    fn from(value: AeronDestinationByIdCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDestinationByIdCommand> for *mut aeron_destination_by_id_command_t {
    #[inline]
    fn from(value: &AeronDestinationByIdCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronDestinationByIdCommand> for aeron_destination_by_id_command_t {
    #[inline]
    fn from(value: AeronDestinationByIdCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_destination_by_id_command_t> for AeronDestinationByIdCommand {
    #[inline]
    fn from(value: *const aeron_destination_by_id_command_t) -> Self {
        AeronDestinationByIdCommand {
            inner: CResource::Borrowed(value as *mut aeron_destination_by_id_command_t),
        }
    }
}
impl From<aeron_destination_by_id_command_t> for AeronDestinationByIdCommand {
    #[inline]
    fn from(value: aeron_destination_by_id_command_t) -> Self {
        AeronDestinationByIdCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDestinationByIdCommand {
    fn default() -> Self {
        AeronDestinationByIdCommand::new_zeroed_on_heap()
    }
}
impl AeronDestinationByIdCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDestinationCommand {
    inner: CResource<aeron_destination_command_t>,
}
impl core::fmt::Debug for AeronDestinationCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDestinationCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDestinationCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronDestinationCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_id: i64,
        channel_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_destination_command_t {
                    correlated: correlated.into(),
                    registration_id: registration_id.into(),
                    channel_length: channel_length.into(),
                };
                let inner_ptr: *mut aeron_destination_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_destination_command_t)
                );
                let inst: aeron_destination_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_destination_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_destination_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_destination_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_destination_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_destination_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDestinationCommand {
    type Target = aeron_destination_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_destination_command_t> for AeronDestinationCommand {
    #[inline]
    fn from(value: *mut aeron_destination_command_t) -> Self {
        AeronDestinationCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDestinationCommand> for *mut aeron_destination_command_t {
    #[inline]
    fn from(value: AeronDestinationCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDestinationCommand> for *mut aeron_destination_command_t {
    #[inline]
    fn from(value: &AeronDestinationCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronDestinationCommand> for aeron_destination_command_t {
    #[inline]
    fn from(value: AeronDestinationCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_destination_command_t> for AeronDestinationCommand {
    #[inline]
    fn from(value: *const aeron_destination_command_t) -> Self {
        AeronDestinationCommand {
            inner: CResource::Borrowed(value as *mut aeron_destination_command_t),
        }
    }
}
impl From<aeron_destination_command_t> for AeronDestinationCommand {
    #[inline]
    fn from(value: aeron_destination_command_t) -> Self {
        AeronDestinationCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDestinationCommand {
    fn default() -> Self {
        AeronDestinationCommand::new_zeroed_on_heap()
    }
}
impl AeronDestinationCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDistinctErrorLogObservationList {
    inner: CResource<aeron_distinct_error_log_observation_list_t>,
}
impl core::fmt::Debug for AeronDistinctErrorLogObservationList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDistinctErrorLogObservationList))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDistinctErrorLogObservationList))
                .field("inner", &self.inner)
                .field(stringify!(num_observations), &self.num_observations())
                .finish()
        }
    }
}
impl AeronDistinctErrorLogObservationList {
    #[inline]
    pub fn new(
        num_observations: u64,
        observations: &AeronDistinctObservation,
    ) -> Result<Self, AeronCError> {
        let observations_copy = observations.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_distinct_error_log_observation_list_t {
                    num_observations: num_observations.into(),
                    observations: observations.into(),
                };
                let inner_ptr: *mut aeron_distinct_error_log_observation_list_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_distinct_error_log_observation_list_t)
                );
                let inst: aeron_distinct_error_log_observation_list_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_distinct_error_log_observation_list_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_distinct_error_log_observation_list_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn num_observations(&self) -> u64 {
        self.num_observations.into()
    }
    #[inline]
    pub fn observations(&self) -> AeronDistinctObservation {
        self.observations.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_distinct_error_log_observation_list_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_distinct_error_log_observation_list_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_distinct_error_log_observation_list_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDistinctErrorLogObservationList {
    type Target = aeron_distinct_error_log_observation_list_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_distinct_error_log_observation_list_t>
    for AeronDistinctErrorLogObservationList
{
    #[inline]
    fn from(value: *mut aeron_distinct_error_log_observation_list_t) -> Self {
        AeronDistinctErrorLogObservationList {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDistinctErrorLogObservationList>
    for *mut aeron_distinct_error_log_observation_list_t
{
    #[inline]
    fn from(value: AeronDistinctErrorLogObservationList) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDistinctErrorLogObservationList>
    for *mut aeron_distinct_error_log_observation_list_t
{
    #[inline]
    fn from(value: &AeronDistinctErrorLogObservationList) -> Self {
        value.get_inner()
    }
}
impl From<AeronDistinctErrorLogObservationList> for aeron_distinct_error_log_observation_list_t {
    #[inline]
    fn from(value: AeronDistinctErrorLogObservationList) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_distinct_error_log_observation_list_t>
    for AeronDistinctErrorLogObservationList
{
    #[inline]
    fn from(value: *const aeron_distinct_error_log_observation_list_t) -> Self {
        AeronDistinctErrorLogObservationList {
            inner: CResource::Borrowed(value as *mut aeron_distinct_error_log_observation_list_t),
        }
    }
}
impl From<aeron_distinct_error_log_observation_list_t> for AeronDistinctErrorLogObservationList {
    #[inline]
    fn from(value: aeron_distinct_error_log_observation_list_t) -> Self {
        AeronDistinctErrorLogObservationList {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDistinctErrorLogObservationList {
    fn default() -> Self {
        AeronDistinctErrorLogObservationList::new_zeroed_on_heap()
    }
}
impl AeronDistinctErrorLogObservationList {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDistinctErrorLog {
    inner: CResource<aeron_distinct_error_log_t>,
}
impl core::fmt::Debug for AeronDistinctErrorLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDistinctErrorLog))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDistinctErrorLog))
                .field("inner", &self.inner)
                .field(stringify!(buffer_capacity), &self.buffer_capacity())
                .field(stringify!(next_offset), &self.next_offset())
                .finish()
        }
    }
}
impl AeronDistinctErrorLog {
    #[inline]
    pub fn new(
        buffer: *mut u8,
        observation_list: &AeronDistinctErrorLogObservationList,
        buffer_capacity: usize,
        next_offset: usize,
        clock: aeron_clock_func_t,
        mutex: aeron_mutex_t,
    ) -> Result<Self, AeronCError> {
        let observation_list_copy = observation_list.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_distinct_error_log_t {
                    buffer: buffer.into(),
                    observation_list: observation_list.into(),
                    buffer_capacity: buffer_capacity.into(),
                    next_offset: next_offset.into(),
                    clock: clock.into(),
                    mutex: mutex.into(),
                };
                let inner_ptr: *mut aeron_distinct_error_log_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_distinct_error_log_t)
                );
                let inst: aeron_distinct_error_log_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_distinct_error_log_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_distinct_error_log_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn buffer(&self) -> *mut u8 {
        self.buffer.into()
    }
    #[inline]
    pub fn observation_list(&self) -> AeronDistinctErrorLogObservationList {
        self.observation_list.into()
    }
    #[inline]
    pub fn buffer_capacity(&self) -> usize {
        self.buffer_capacity.into()
    }
    #[inline]
    pub fn next_offset(&self) -> usize {
        self.next_offset.into()
    }
    #[inline]
    pub fn clock(&self) -> aeron_clock_func_t {
        self.clock.into()
    }
    #[inline]
    pub fn mutex(&self) -> aeron_mutex_t {
        self.mutex.into()
    }
    #[inline]
    pub fn init(
        &self,
        buffer: *mut u8,
        buffer_size: usize,
        clock: aeron_clock_func_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_distinct_error_log_init(
                self.get_inner(),
                buffer.into(),
                buffer_size.into(),
                clock.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_distinct_error_log_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn record(
        &self,
        error_code: ::std::os::raw::c_int,
        description: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_distinct_error_log_record(
                self.get_inner(),
                error_code.into(),
                description.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn num_observations(&self) -> usize {
        unsafe {
            let result = aeron_distinct_error_log_num_observations(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_distinct_error_log_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_distinct_error_log_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_distinct_error_log_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDistinctErrorLog {
    type Target = aeron_distinct_error_log_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_distinct_error_log_t> for AeronDistinctErrorLog {
    #[inline]
    fn from(value: *mut aeron_distinct_error_log_t) -> Self {
        AeronDistinctErrorLog {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDistinctErrorLog> for *mut aeron_distinct_error_log_t {
    #[inline]
    fn from(value: AeronDistinctErrorLog) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDistinctErrorLog> for *mut aeron_distinct_error_log_t {
    #[inline]
    fn from(value: &AeronDistinctErrorLog) -> Self {
        value.get_inner()
    }
}
impl From<AeronDistinctErrorLog> for aeron_distinct_error_log_t {
    #[inline]
    fn from(value: AeronDistinctErrorLog) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_distinct_error_log_t> for AeronDistinctErrorLog {
    #[inline]
    fn from(value: *const aeron_distinct_error_log_t) -> Self {
        AeronDistinctErrorLog {
            inner: CResource::Borrowed(value as *mut aeron_distinct_error_log_t),
        }
    }
}
impl From<aeron_distinct_error_log_t> for AeronDistinctErrorLog {
    #[inline]
    fn from(value: aeron_distinct_error_log_t) -> Self {
        AeronDistinctErrorLog {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDistinctErrorLog {
    fn default() -> Self {
        AeronDistinctErrorLog::new_zeroed_on_heap()
    }
}
impl AeronDistinctErrorLog {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDistinctObservation {
    inner: CResource<aeron_distinct_observation_t>,
}
impl core::fmt::Debug for AeronDistinctObservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDistinctObservation))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDistinctObservation))
                .field("inner", &self.inner)
                .field(stringify!(offset), &self.offset())
                .field(stringify!(description_length), &self.description_length())
                .finish()
        }
    }
}
impl AeronDistinctObservation {
    #[inline]
    pub fn new(
        description: &std::ffi::CStr,
        error_code: ::std::os::raw::c_int,
        offset: usize,
        description_length: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_distinct_observation_t {
                    description: description.as_ptr(),
                    error_code: error_code.into(),
                    offset: offset.into(),
                    description_length: description_length.into(),
                };
                let inner_ptr: *mut aeron_distinct_observation_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_distinct_observation_t)
                );
                let inst: aeron_distinct_observation_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_distinct_observation_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_distinct_observation_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn description(&self) -> &str {
        if self.description.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.description).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn error_code(&self) -> ::std::os::raw::c_int {
        self.error_code.into()
    }
    #[inline]
    pub fn offset(&self) -> usize {
        self.offset.into()
    }
    #[inline]
    pub fn description_length(&self) -> usize {
        self.description_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_distinct_observation_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_distinct_observation_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_distinct_observation_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDistinctObservation {
    type Target = aeron_distinct_observation_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_distinct_observation_t> for AeronDistinctObservation {
    #[inline]
    fn from(value: *mut aeron_distinct_observation_t) -> Self {
        AeronDistinctObservation {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDistinctObservation> for *mut aeron_distinct_observation_t {
    #[inline]
    fn from(value: AeronDistinctObservation) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDistinctObservation> for *mut aeron_distinct_observation_t {
    #[inline]
    fn from(value: &AeronDistinctObservation) -> Self {
        value.get_inner()
    }
}
impl From<AeronDistinctObservation> for aeron_distinct_observation_t {
    #[inline]
    fn from(value: AeronDistinctObservation) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_distinct_observation_t> for AeronDistinctObservation {
    #[inline]
    fn from(value: *const aeron_distinct_observation_t) -> Self {
        AeronDistinctObservation {
            inner: CResource::Borrowed(value as *mut aeron_distinct_observation_t),
        }
    }
}
impl From<aeron_distinct_observation_t> for AeronDistinctObservation {
    #[inline]
    fn from(value: aeron_distinct_observation_t) -> Self {
        AeronDistinctObservation {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDistinctObservation {
    fn default() -> Self {
        AeronDistinctObservation::new_zeroed_on_heap()
    }
}
impl AeronDistinctObservation {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDlLoadedLibsState {
    inner: CResource<aeron_dl_loaded_libs_state_t>,
}
impl core::fmt::Debug for AeronDlLoadedLibsState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDlLoadedLibsState))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDlLoadedLibsState))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDlLoadedLibsState {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_dl_loaded_libs_state_t)
                );
                let inst: aeron_dl_loaded_libs_state_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_dl_loaded_libs_state_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_dl_loaded_libs_state_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_dl_loaded_libs_state_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_dl_loaded_libs_state_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_dl_loaded_libs_state_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDlLoadedLibsState {
    type Target = aeron_dl_loaded_libs_state_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_dl_loaded_libs_state_t> for AeronDlLoadedLibsState {
    #[inline]
    fn from(value: *mut aeron_dl_loaded_libs_state_t) -> Self {
        AeronDlLoadedLibsState {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDlLoadedLibsState> for *mut aeron_dl_loaded_libs_state_t {
    #[inline]
    fn from(value: AeronDlLoadedLibsState) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDlLoadedLibsState> for *mut aeron_dl_loaded_libs_state_t {
    #[inline]
    fn from(value: &AeronDlLoadedLibsState) -> Self {
        value.get_inner()
    }
}
impl From<AeronDlLoadedLibsState> for aeron_dl_loaded_libs_state_t {
    #[inline]
    fn from(value: AeronDlLoadedLibsState) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_dl_loaded_libs_state_t> for AeronDlLoadedLibsState {
    #[inline]
    fn from(value: *const aeron_dl_loaded_libs_state_t) -> Self {
        AeronDlLoadedLibsState {
            inner: CResource::Borrowed(value as *mut aeron_dl_loaded_libs_state_t),
        }
    }
}
impl From<aeron_dl_loaded_libs_state_t> for AeronDlLoadedLibsState {
    #[inline]
    fn from(value: aeron_dl_loaded_libs_state_t) -> Self {
        AeronDlLoadedLibsState {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronDriverConductorProxy {
    inner: CResource<aeron_driver_conductor_proxy_t>,
}
impl core::fmt::Debug for AeronDriverConductorProxy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverConductorProxy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverConductorProxy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverConductorProxy {
    #[inline]
    pub fn new(
        conductor: &AeronDriverConductor,
        threading_mode: aeron_threading_mode_t,
        command_queue: &AeronMpscRb,
        fail_counter: &mut i64,
    ) -> Result<Self, AeronCError> {
        let conductor_copy = conductor.clone();
        let command_queue_copy = command_queue.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_conductor_proxy_t {
                    conductor: conductor.into(),
                    threading_mode: threading_mode.into(),
                    command_queue: command_queue.into(),
                    fail_counter: fail_counter as *mut _,
                };
                let inner_ptr: *mut aeron_driver_conductor_proxy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_conductor_proxy_t)
                );
                let inst: aeron_driver_conductor_proxy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_conductor_proxy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_conductor_proxy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn conductor(&self) -> AeronDriverConductor {
        self.conductor.into()
    }
    #[inline]
    pub fn threading_mode(&self) -> aeron_threading_mode_t {
        self.threading_mode.into()
    }
    #[inline]
    pub fn command_queue(&self) -> AeronMpscRb {
        self.command_queue.into()
    }
    #[inline]
    pub fn fail_counter(&self) -> &mut i64 {
        unsafe { &mut *self.fail_counter }
    }
    #[inline]
    pub fn on_create_publication_image_cmd(
        &self,
        session_id: i32,
        stream_id: i32,
        initial_term_id: i32,
        active_term_id: i32,
        term_offset: i32,
        term_length: i32,
        mtu_length: i32,
        flags: u8,
        control_address: &SockaddrStorage,
        src_address: &SockaddrStorage,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_create_publication_image_cmd(
                self.get_inner(),
                session_id.into(),
                stream_id.into(),
                initial_term_id.into(),
                active_term_id.into(),
                term_offset.into(),
                term_length.into(),
                mtu_length.into(),
                flags.into(),
                control_address.get_inner(),
                src_address.get_inner(),
                endpoint.into(),
                destination.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_re_resolve_endpoint(
        &self,
        endpoint_name: &std::ffi::CStr,
        endpoint: *mut ::std::os::raw::c_void,
        existing_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_re_resolve_endpoint(
                self.get_inner(),
                endpoint_name.as_ptr(),
                endpoint.into(),
                existing_addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_re_resolve_control(
        &self,
        endpoint_name: &std::ffi::CStr,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
        existing_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_re_resolve_control(
                self.get_inner(),
                endpoint_name.as_ptr(),
                endpoint.into(),
                destination.into(),
                existing_addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_delete_receive_destination(
        &self,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
        channel: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_delete_receive_destination(
                self.get_inner(),
                endpoint.into(),
                destination.into(),
                channel.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_delete_send_destination(&self, removed_uri: *mut ::std::os::raw::c_void) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_delete_send_destination(
                self.get_inner(),
                removed_uri.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_receive_endpoint_removed(&self, endpoint: *mut ::std::os::raw::c_void) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_receive_endpoint_removed(
                self.get_inner(),
                endpoint.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_response_setup(&self, response_correlation_id: i64, response_session_id: i32) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_response_setup(
                self.get_inner(),
                response_correlation_id.into(),
                response_session_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_response_connected(&self, response_correlation_id: i64) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_response_connected(
                self.get_inner(),
                response_correlation_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_release_resource(
        &self,
        managed_resource: *mut ::std::os::raw::c_void,
        resource_type: aeron_driver_conductor_resource_type_t,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_release_resource(
                self.get_inner(),
                managed_resource.into(),
                resource_type.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_publication_error(
        &self,
        registration_id: i64,
        destination_registration_id: i64,
        session_id: i32,
        stream_id: i32,
        receiver_id: i64,
        group_tag: i64,
        src_address: &SockaddrStorage,
        error_code: i32,
        error_length: i32,
        error_text: *const u8,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_proxy_on_publication_error(
                self.get_inner(),
                registration_id.into(),
                destination_registration_id.into(),
                session_id.into(),
                stream_id.into(),
                receiver_id.into(),
                group_tag.into(),
                src_address.get_inner(),
                error_code.into(),
                error_length.into(),
                error_text.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_conductor_proxy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_conductor_proxy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_conductor_proxy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverConductorProxy {
    type Target = aeron_driver_conductor_proxy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_conductor_proxy_t> for AeronDriverConductorProxy {
    #[inline]
    fn from(value: *mut aeron_driver_conductor_proxy_t) -> Self {
        AeronDriverConductorProxy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverConductorProxy> for *mut aeron_driver_conductor_proxy_t {
    #[inline]
    fn from(value: AeronDriverConductorProxy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverConductorProxy> for *mut aeron_driver_conductor_proxy_t {
    #[inline]
    fn from(value: &AeronDriverConductorProxy) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverConductorProxy> for aeron_driver_conductor_proxy_t {
    #[inline]
    fn from(value: AeronDriverConductorProxy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_conductor_proxy_t> for AeronDriverConductorProxy {
    #[inline]
    fn from(value: *const aeron_driver_conductor_proxy_t) -> Self {
        AeronDriverConductorProxy {
            inner: CResource::Borrowed(value as *mut aeron_driver_conductor_proxy_t),
        }
    }
}
impl From<aeron_driver_conductor_proxy_t> for AeronDriverConductorProxy {
    #[inline]
    fn from(value: aeron_driver_conductor_proxy_t) -> Self {
        AeronDriverConductorProxy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverConductorProxy {
    fn default() -> Self {
        AeronDriverConductorProxy::new_zeroed_on_heap()
    }
}
impl AeronDriverConductorProxy {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverConductor {
    inner: CResource<aeron_driver_conductor_t>,
}
impl core::fmt::Debug for AeronDriverConductor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverConductor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverConductor))
                .field("inner", &self.inner)
                .field(stringify!(to_driver_commands), &self.to_driver_commands())
                .field(stringify!(to_clients), &self.to_clients())
                .field(stringify!(error_log), &self.error_log())
                .field(stringify!(counters_manager), &self.counters_manager())
                .field(stringify!(system_counters), &self.system_counters())
                .field(stringify!(conductor_proxy), &self.conductor_proxy())
                .field(stringify!(loss_reporter), &self.loss_reporter())
                .field(
                    stringify!(send_channel_endpoint_by_channel_map),
                    &self.send_channel_endpoint_by_channel_map(),
                )
                .field(
                    stringify!(receive_channel_endpoint_by_channel_map),
                    &self.receive_channel_endpoint_by_channel_map(),
                )
                .field(stringify!(end_of_life_queue), &self.end_of_life_queue())
                .field(
                    stringify!(clock_update_deadline_ns),
                    &self.clock_update_deadline_ns(),
                )
                .field(stringify!(next_session_id), &self.next_session_id())
                .field(
                    stringify!(publication_reserved_session_id_low),
                    &self.publication_reserved_session_id_low(),
                )
                .field(
                    stringify!(publication_reserved_session_id_high),
                    &self.publication_reserved_session_id_high(),
                )
                .field(
                    stringify!(timeout_check_deadline_ns),
                    &self.timeout_check_deadline_ns(),
                )
                .field(
                    stringify!(time_of_last_to_driver_position_change_ns),
                    &self.time_of_last_to_driver_position_change_ns(),
                )
                .field(
                    stringify!(last_command_consumer_position),
                    &self.last_command_consumer_position(),
                )
                .field(
                    stringify!(async_client_command_in_flight),
                    &self.async_client_command_in_flight(),
                )
                .finish()
        }
    }
}
impl AeronDriverConductor {
    #[inline]
    pub fn new(
        context: &AeronDriverContext,
        to_driver_commands: AeronMpscRb,
        to_clients: AeronBroadcastTransmitter,
        error_log: AeronDistinctErrorLog,
        counters_manager: AeronCountersManager,
        system_counters: AeronSystemCounters,
        conductor_proxy: AeronDriverConductorProxy,
        loss_reporter: AeronLossReporter,
        name_resolver: aeron_name_resolver_t,
        executor: aeron_executor_t,
        send_channel_endpoint_by_channel_map: AeronStrToPtrHashMap,
        receive_channel_endpoint_by_channel_map: AeronStrToPtrHashMap,
        clients: aeron_driver_conductor_stct_client_stct,
        ipc_subscriptions: aeron_driver_conductor_stct_ipc_subscriptions_stct,
        ipc_publications: aeron_driver_conductor_stct_ipc_publication_stct,
        network_subscriptions: aeron_driver_conductor_stct_network_subscriptions_stct,
        spy_subscriptions: aeron_driver_conductor_stct_spy_subscriptions_stct,
        network_publications: aeron_driver_conductor_stct_network_publication_stct,
        send_channel_endpoints: aeron_driver_conductor_stct_send_channel_endpoint_stct,
        receive_channel_endpoints: aeron_driver_conductor_stct_receive_channel_endpoint_stct,
        publication_images: aeron_driver_conductor_stct_publication_image_stct,
        lingering_resources : aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct,
        end_of_life_queue: AeronDeque,
        errors_counter: &mut i64,
        images_rejected_counter: &mut i64,
        unblocked_commands_counter: &mut i64,
        client_timeouts_counter: &mut i64,
        clock_update_deadline_ns: i64,
        next_session_id: i32,
        publication_reserved_session_id_low: i32,
        publication_reserved_session_id_high: i32,
        timeout_check_deadline_ns: i64,
        time_of_last_to_driver_position_change_ns: i64,
        last_command_consumer_position: i64,
        async_client_command_in_flight: bool,
        padding: [u8; 64usize],
    ) -> Result<Self, AeronCError> {
        let context_copy = context.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_conductor_t {
                    context: context.into(),
                    to_driver_commands: to_driver_commands.into(),
                    to_clients: to_clients.into(),
                    error_log: error_log.into(),
                    counters_manager: counters_manager.into(),
                    system_counters: system_counters.into(),
                    conductor_proxy: conductor_proxy.into(),
                    loss_reporter: loss_reporter.into(),
                    name_resolver: name_resolver.into(),
                    executor: executor.into(),
                    send_channel_endpoint_by_channel_map: send_channel_endpoint_by_channel_map
                        .into(),
                    receive_channel_endpoint_by_channel_map:
                        receive_channel_endpoint_by_channel_map.into(),
                    clients: clients.into(),
                    ipc_subscriptions: ipc_subscriptions.into(),
                    ipc_publications: ipc_publications.into(),
                    network_subscriptions: network_subscriptions.into(),
                    spy_subscriptions: spy_subscriptions.into(),
                    network_publications: network_publications.into(),
                    send_channel_endpoints: send_channel_endpoints.into(),
                    receive_channel_endpoints: receive_channel_endpoints.into(),
                    publication_images: publication_images.into(),
                    lingering_resources: lingering_resources.into(),
                    end_of_life_queue: end_of_life_queue.into(),
                    errors_counter: errors_counter as *mut _,
                    images_rejected_counter: images_rejected_counter as *mut _,
                    unblocked_commands_counter: unblocked_commands_counter as *mut _,
                    client_timeouts_counter: client_timeouts_counter as *mut _,
                    clock_update_deadline_ns: clock_update_deadline_ns.into(),
                    next_session_id: next_session_id.into(),
                    publication_reserved_session_id_low: publication_reserved_session_id_low.into(),
                    publication_reserved_session_id_high: publication_reserved_session_id_high
                        .into(),
                    timeout_check_deadline_ns: timeout_check_deadline_ns.into(),
                    time_of_last_to_driver_position_change_ns:
                        time_of_last_to_driver_position_change_ns.into(),
                    last_command_consumer_position: last_command_consumer_position.into(),
                    async_client_command_in_flight: async_client_command_in_flight.into(),
                    padding: padding.into(),
                };
                let inner_ptr: *mut aeron_driver_conductor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_conductor_t)
                );
                let inst: aeron_driver_conductor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_conductor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_conductor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn context(&self) -> AeronDriverContext {
        self.context.into()
    }
    #[inline]
    pub fn to_driver_commands(&self) -> AeronMpscRb {
        self.to_driver_commands.into()
    }
    #[inline]
    pub fn to_clients(&self) -> AeronBroadcastTransmitter {
        self.to_clients.into()
    }
    #[inline]
    pub fn error_log(&self) -> AeronDistinctErrorLog {
        self.error_log.into()
    }
    #[inline]
    pub fn counters_manager(&self) -> AeronCountersManager {
        self.counters_manager.into()
    }
    #[inline]
    pub fn system_counters(&self) -> AeronSystemCounters {
        self.system_counters.into()
    }
    #[inline]
    pub fn conductor_proxy(&self) -> AeronDriverConductorProxy {
        self.conductor_proxy.into()
    }
    #[inline]
    pub fn loss_reporter(&self) -> AeronLossReporter {
        self.loss_reporter.into()
    }
    #[inline]
    pub fn name_resolver(&self) -> aeron_name_resolver_t {
        self.name_resolver.into()
    }
    #[inline]
    pub fn executor(&self) -> aeron_executor_t {
        self.executor.into()
    }
    #[inline]
    pub fn send_channel_endpoint_by_channel_map(&self) -> AeronStrToPtrHashMap {
        self.send_channel_endpoint_by_channel_map.into()
    }
    #[inline]
    pub fn receive_channel_endpoint_by_channel_map(&self) -> AeronStrToPtrHashMap {
        self.receive_channel_endpoint_by_channel_map.into()
    }
    #[inline]
    pub fn clients(&self) -> aeron_driver_conductor_stct_client_stct {
        self.clients.into()
    }
    #[inline]
    pub fn ipc_subscriptions(&self) -> aeron_driver_conductor_stct_ipc_subscriptions_stct {
        self.ipc_subscriptions.into()
    }
    #[inline]
    pub fn ipc_publications(&self) -> aeron_driver_conductor_stct_ipc_publication_stct {
        self.ipc_publications.into()
    }
    #[inline]
    pub fn network_subscriptions(&self) -> aeron_driver_conductor_stct_network_subscriptions_stct {
        self.network_subscriptions.into()
    }
    #[inline]
    pub fn spy_subscriptions(&self) -> aeron_driver_conductor_stct_spy_subscriptions_stct {
        self.spy_subscriptions.into()
    }
    #[inline]
    pub fn network_publications(&self) -> aeron_driver_conductor_stct_network_publication_stct {
        self.network_publications.into()
    }
    #[inline]
    pub fn send_channel_endpoints(&self) -> aeron_driver_conductor_stct_send_channel_endpoint_stct {
        self.send_channel_endpoints.into()
    }
    #[inline]
    pub fn receive_channel_endpoints(
        &self,
    ) -> aeron_driver_conductor_stct_receive_channel_endpoint_stct {
        self.receive_channel_endpoints.into()
    }
    #[inline]
    pub fn publication_images(&self) -> aeron_driver_conductor_stct_publication_image_stct {
        self.publication_images.into()
    }
    #[inline]
    pub fn lingering_resources(
        &self,
    ) -> aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct {
        self.lingering_resources.into()
    }
    #[inline]
    pub fn end_of_life_queue(&self) -> AeronDeque {
        self.end_of_life_queue.into()
    }
    #[inline]
    pub fn errors_counter(&self) -> &mut i64 {
        unsafe { &mut *self.errors_counter }
    }
    #[inline]
    pub fn images_rejected_counter(&self) -> &mut i64 {
        unsafe { &mut *self.images_rejected_counter }
    }
    #[inline]
    pub fn unblocked_commands_counter(&self) -> &mut i64 {
        unsafe { &mut *self.unblocked_commands_counter }
    }
    #[inline]
    pub fn client_timeouts_counter(&self) -> &mut i64 {
        unsafe { &mut *self.client_timeouts_counter }
    }
    #[inline]
    pub fn clock_update_deadline_ns(&self) -> i64 {
        self.clock_update_deadline_ns.into()
    }
    #[inline]
    pub fn next_session_id(&self) -> i32 {
        self.next_session_id.into()
    }
    #[inline]
    pub fn publication_reserved_session_id_low(&self) -> i32 {
        self.publication_reserved_session_id_low.into()
    }
    #[inline]
    pub fn publication_reserved_session_id_high(&self) -> i32 {
        self.publication_reserved_session_id_high.into()
    }
    #[inline]
    pub fn timeout_check_deadline_ns(&self) -> i64 {
        self.timeout_check_deadline_ns.into()
    }
    #[inline]
    pub fn time_of_last_to_driver_position_change_ns(&self) -> i64 {
        self.time_of_last_to_driver_position_change_ns.into()
    }
    #[inline]
    pub fn last_command_consumer_position(&self) -> i64 {
        self.last_command_consumer_position.into()
    }
    #[inline]
    pub fn async_client_command_in_flight(&self) -> bool {
        self.async_client_command_in_flight.into()
    }
    #[inline]
    pub fn padding(&self) -> [u8; 64usize] {
        self.padding.into()
    }
    #[inline]
    pub fn aeron_ipc_publication_on_time_event(
        &self,
        publication: &AeronIpcPublication,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_ipc_publication_on_time_event(
                self.get_inner(),
                publication.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_on_time_event(
        &self,
        publication: &AeronNetworkPublication,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_on_time_event(
                self.get_inner(),
                publication.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_publication_image_on_time_event(
        &self,
        image: &AeronPublicationImage,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_publication_image_on_time_event(
                self.get_inner(),
                image.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_client_on_time_event(&self, client: &AeronClient, now_ns: i64, now_ms: i64) -> () {
        unsafe {
            let result = aeron_client_on_time_event(
                self.get_inner(),
                client.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_client_has_reached_end_of_life(&self, client: &AeronClient) -> bool {
        unsafe {
            let result = aeron_client_has_reached_end_of_life(self.get_inner(), client.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn add_end_of_life_resource(
        &self,
        resource: *mut ::std::os::raw::c_void,
        free_func: aeron_end_of_life_resource_free_t,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_add_end_of_life_resource(
                self.get_inner(),
                resource.into(),
                free_func.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_client_delete(&self, arg1: &AeronClient) -> () {
        unsafe {
            let result = aeron_client_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_ipc_publication_entry_on_time_event(
        &self,
        entry: &AeronIpcPublicationEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_ipc_publication_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_ipc_publication_entry_has_reached_end_of_life(
        &self,
        entry: &AeronIpcPublicationEntry,
    ) -> bool {
        unsafe {
            let result = aeron_ipc_publication_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_ipc_publication_entry_delete(&self, arg1: &AeronIpcPublicationEntry) -> () {
        unsafe {
            let result = aeron_ipc_publication_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_ipc_publication_entry_free(&self, entry: &AeronIpcPublicationEntry) -> () {
        unsafe {
            let result = aeron_ipc_publication_entry_free(self.get_inner(), entry.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_entry_on_time_event(
        &self,
        entry: &AeronNetworkPublicationEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_entry_has_reached_end_of_life(
        &self,
        entry: &AeronNetworkPublicationEntry,
    ) -> bool {
        unsafe {
            let result = aeron_network_publication_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_entry_delete(
        &self,
        arg1: &AeronNetworkPublicationEntry,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_network_publication_entry_free(&self, entry: &AeronNetworkPublicationEntry) -> () {
        unsafe {
            let result = aeron_network_publication_entry_free(self.get_inner(), entry.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_entry_on_time_event(
        &self,
        entry: &AeronSendChannelEndpointEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_send_channel_endpoint_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_entry_has_reached_end_of_life(
        &self,
        entry: &AeronSendChannelEndpointEntry,
    ) -> bool {
        unsafe {
            let result = aeron_send_channel_endpoint_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_entry_delete(
        &self,
        arg1: &AeronSendChannelEndpointEntry,
    ) -> () {
        unsafe {
            let result =
                aeron_send_channel_endpoint_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_receive_channel_endpoint_entry_on_time_event(
        &self,
        entry: &AeronReceiveChannelEndpointEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_receive_channel_endpoint_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_receive_channel_endpoint_entry_has_reached_end_of_life(
        &self,
        entry: &AeronReceiveChannelEndpointEntry,
    ) -> bool {
        unsafe {
            let result = aeron_receive_channel_endpoint_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_receive_channel_endpoint_entry_delete(
        &self,
        arg1: &AeronReceiveChannelEndpointEntry,
    ) -> () {
        unsafe {
            let result =
                aeron_receive_channel_endpoint_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_publication_image_entry_on_time_event(
        &self,
        entry: &AeronPublicationImageEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_publication_image_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_publication_image_entry_has_reached_end_of_life(
        &self,
        entry: &AeronPublicationImageEntry,
    ) -> bool {
        unsafe {
            let result = aeron_publication_image_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_publication_image_entry_delete(&self, arg1: &AeronPublicationImageEntry) -> () {
        unsafe {
            let result = aeron_publication_image_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_publication_image_entry_free(&self, entry: &AeronPublicationImageEntry) -> () {
        unsafe {
            let result = aeron_publication_image_entry_free(self.get_inner(), entry.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_linger_resource_entry_on_time_event(
        &self,
        entry: &AeronLingerResourceEntry,
        now_ns: i64,
        now_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_linger_resource_entry_on_time_event(
                self.get_inner(),
                entry.get_inner(),
                now_ns.into(),
                now_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_linger_resource_entry_has_reached_end_of_life(
        &self,
        entry: &AeronLingerResourceEntry,
    ) -> bool {
        unsafe {
            let result = aeron_linger_resource_entry_has_reached_end_of_life(
                self.get_inner(),
                entry.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_linger_resource_entry_delete(&self, arg1: &AeronLingerResourceEntry) -> () {
        unsafe {
            let result = aeron_linger_resource_entry_delete(self.get_inner(), arg1.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn image_transition_to_linger(&self, image: &AeronPublicationImage) -> () {
        unsafe {
            let result = aeron_driver_conductor_image_transition_to_linger(
                self.get_inner(),
                image.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn init(&self, context: &AeronDriverContext) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_init(self.get_inner(), context.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn client_transmit(
        &self,
        msg_type_id: i32,
        message: *const ::std::os::raw::c_void,
        length: usize,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_client_transmit(
                self.get_inner(),
                msg_type_id.into(),
                message.into(),
                length.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_available_image(
        &self,
        correlation_id: i64,
        stream_id: i32,
        session_id: i32,
        log_file_name: &str,
        subscriber_position_id: i32,
        subscriber_registration_id: i64,
        source_identity: &str,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_available_image(
                self.get_inner(),
                correlation_id.into(),
                stream_id.into(),
                session_id.into(),
                log_file_name.as_ptr() as *const _,
                log_file_name.len(),
                subscriber_position_id.into(),
                subscriber_registration_id.into(),
                source_identity.as_ptr() as *const _,
                source_identity.len(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_unavailable_image(
        &self,
        correlation_id: i64,
        subscription_registration_id: i64,
        stream_id: i32,
        channel: &str,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_unavailable_image(
                self.get_inner(),
                correlation_id.into(),
                subscription_registration_id.into(),
                stream_id.into(),
                channel.as_ptr() as *const _,
                channel.len(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_counter_ready(&self, registration_id: i64, counter_id: i32) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_counter_ready(
                self.get_inner(),
                registration_id.into(),
                counter_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_unavailable_counter(&self, registration_id: i64, counter_id: i32) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_unavailable_counter(
                self.get_inner(),
                registration_id.into(),
                counter_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_client_timeout(&self, correlation_id: i64) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_on_client_timeout(self.get_inner(), correlation_id.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_static_counter(&self, correlation_id: i64, counter_id: i32) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_static_counter(
                self.get_inner(),
                correlation_id.into(),
                counter_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn cleanup_spies(&self, publication: &AeronNetworkPublication) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_cleanup_spies(self.get_inner(), publication.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn cleanup_network_publication(&self, publication: &AeronNetworkPublication) -> () {
        unsafe {
            let result = aeron_driver_conductor_cleanup_network_publication(
                self.get_inner(),
                publication.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_command(
        msg_type_id: i32,
        message: *const ::std::os::raw::c_void,
        length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ) -> aeron_rb_read_action_t {
        unsafe {
            let result = aeron_driver_conductor_on_command(
                msg_type_id.into(),
                message.into(),
                length.into(),
                clientd.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn do_work(clientd: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_do_work(clientd.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_close(clientd: *mut ::std::os::raw::c_void) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_close(clientd.into());
            result.into()
        }
    }
    #[inline]
    pub fn link_subscribable(
        &self,
        link: &AeronSubscriptionLink,
        subscribable: &AeronSubscribable,
        original_registration_id: i64,
        session_id: i32,
        stream_id: i32,
        join_position: i64,
        now_ns: i64,
        source_identity_length: usize,
        source_identity: &std::ffi::CStr,
        log_file_name_length: usize,
        log_file_name: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_link_subscribable(
                self.get_inner(),
                link.get_inner(),
                subscribable.get_inner(),
                original_registration_id.into(),
                session_id.into(),
                stream_id.into(),
                join_position.into(),
                now_ns.into(),
                source_identity_length.into(),
                source_identity.as_ptr(),
                log_file_name_length.into(),
                log_file_name.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn unlink_all_subscribable(&self, link: &AeronSubscriptionLink) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_unlink_all_subscribable(self.get_inner(), link.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn link_ipc_subscriptions(
        &self,
        publication: &AeronIpcPublication,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_link_ipc_subscriptions(
                self.get_inner(),
                publication.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_ipc_publication(
        &self,
        command: &AeronPublicationCommand,
        is_exclusive: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_ipc_publication(
                self.get_inner(),
                command.get_inner(),
                is_exclusive.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_network_publication(
        &self,
        command: &AeronPublicationCommand,
        is_exclusive: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_network_publication(
                self.get_inner(),
                command.get_inner(),
                is_exclusive.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_publication(
        &self,
        command: &AeronRemovePublicationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_remove_publication(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_ipc_subscription(
        &self,
        command: &AeronSubscriptionCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_ipc_subscription(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_spy_subscription(
        &self,
        command: &AeronSubscriptionCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_spy_subscription(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_network_subscription(
        &self,
        command: &AeronSubscriptionCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_network_subscription(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_subscription(
        &self,
        command: &AeronRemoveSubscriptionCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_subscription(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_client_keepalive(&self, client_id: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_client_keepalive(self.get_inner(), client_id.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_send_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_send_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_send_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_send_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_receive_send_destination_by_id(
        &self,
        command: &AeronDestinationByIdCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_receive_send_destination_by_id(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_receive_ipc_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_receive_ipc_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_receive_spy_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_receive_spy_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_receive_network_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_add_receive_network_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_receive_ipc_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_receive_ipc_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_receive_spy_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_receive_spy_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_receive_network_destination(
        &self,
        command: &AeronDestinationCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_conductor_on_remove_receive_network_destination(
                self.get_inner(),
                command.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_delete_receive_destination(
        clientd: *mut ::std::os::raw::c_void,
        cmd: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_on_delete_receive_destination(clientd.into(), cmd.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_delete_send_destination(
        clientd: *mut ::std::os::raw::c_void,
        cmd: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_on_delete_send_destination(clientd.into(), cmd.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_counter(&self, command: &AeronCounterCommand) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_add_counter(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_counter(
        &self,
        command: &AeronRemoveCounterCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_remove_counter(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_static_counter(
        &self,
        command: &AeronStaticCounterCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_add_static_counter(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_client_close(&self, command: &AeronCorrelatedCommand) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_client_close(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_terminate_driver(
        &self,
        command: &AeronTerminateDriverCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_terminate_driver(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_invalidate_image(
        &self,
        command: &AeronRejectImageCommand,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_conductor_on_invalidate_image(self.get_inner(), command.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn unlink_ipc_subscriptions(&self, publication: &AeronIpcPublication) -> () {
        unsafe {
            let result = aeron_driver_conductor_unlink_ipc_subscriptions(
                self.get_inner(),
                publication.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_create_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_on_create_publication_image(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_re_resolve_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_re_resolve_endpoint(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_re_resolve_control(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_re_resolve_control(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_receive_endpoint_removed(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_conductor_on_receive_endpoint_removed(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_response_setup(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_response_setup(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_response_connected(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_response_connected(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_publication_error(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_publication_error(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_release_resource(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_on_release_resource(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_conductor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_conductor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_conductor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverConductor {
    type Target = aeron_driver_conductor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_conductor_t> for AeronDriverConductor {
    #[inline]
    fn from(value: *mut aeron_driver_conductor_t) -> Self {
        AeronDriverConductor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverConductor> for *mut aeron_driver_conductor_t {
    #[inline]
    fn from(value: AeronDriverConductor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverConductor> for *mut aeron_driver_conductor_t {
    #[inline]
    fn from(value: &AeronDriverConductor) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverConductor> for aeron_driver_conductor_t {
    #[inline]
    fn from(value: AeronDriverConductor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_conductor_t> for AeronDriverConductor {
    #[inline]
    fn from(value: *const aeron_driver_conductor_t) -> Self {
        AeronDriverConductor {
            inner: CResource::Borrowed(value as *mut aeron_driver_conductor_t),
        }
    }
}
impl From<aeron_driver_conductor_t> for AeronDriverConductor {
    #[inline]
    fn from(value: aeron_driver_conductor_t) -> Self {
        AeronDriverConductor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverConductor {
    fn default() -> Self {
        AeronDriverConductor::new_zeroed_on_heap()
    }
}
impl AeronDriverConductor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverContextBindingsClientdEntry {
    inner: CResource<aeron_driver_context_bindings_clientd_entry_t>,
}
impl core::fmt::Debug for AeronDriverContextBindingsClientdEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverContextBindingsClientdEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverContextBindingsClientdEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverContextBindingsClientdEntry {
    #[inline]
    pub fn new(
        name: &std::ffi::CStr,
        clientd: *mut ::std::os::raw::c_void,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_context_bindings_clientd_entry_t {
                    name: name.as_ptr(),
                    clientd: clientd.into(),
                };
                let inner_ptr: *mut aeron_driver_context_bindings_clientd_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_context_bindings_clientd_entry_t)
                );
                let inst: aeron_driver_context_bindings_clientd_entry_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_context_bindings_clientd_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_context_bindings_clientd_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn name(&self) -> &str {
        if self.name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.name).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_context_bindings_clientd_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_context_bindings_clientd_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_context_bindings_clientd_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverContextBindingsClientdEntry {
    type Target = aeron_driver_context_bindings_clientd_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_context_bindings_clientd_entry_t>
    for AeronDriverContextBindingsClientdEntry
{
    #[inline]
    fn from(value: *mut aeron_driver_context_bindings_clientd_entry_t) -> Self {
        AeronDriverContextBindingsClientdEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverContextBindingsClientdEntry>
    for *mut aeron_driver_context_bindings_clientd_entry_t
{
    #[inline]
    fn from(value: AeronDriverContextBindingsClientdEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverContextBindingsClientdEntry>
    for *mut aeron_driver_context_bindings_clientd_entry_t
{
    #[inline]
    fn from(value: &AeronDriverContextBindingsClientdEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverContextBindingsClientdEntry>
    for aeron_driver_context_bindings_clientd_entry_t
{
    #[inline]
    fn from(value: AeronDriverContextBindingsClientdEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_context_bindings_clientd_entry_t>
    for AeronDriverContextBindingsClientdEntry
{
    #[inline]
    fn from(value: *const aeron_driver_context_bindings_clientd_entry_t) -> Self {
        AeronDriverContextBindingsClientdEntry {
            inner: CResource::Borrowed(value as *mut aeron_driver_context_bindings_clientd_entry_t),
        }
    }
}
impl From<aeron_driver_context_bindings_clientd_entry_t>
    for AeronDriverContextBindingsClientdEntry
{
    #[inline]
    fn from(value: aeron_driver_context_bindings_clientd_entry_t) -> Self {
        AeronDriverContextBindingsClientdEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverContextBindingsClientdEntry {
    fn default() -> Self {
        AeronDriverContextBindingsClientdEntry::new_zeroed_on_heap()
    }
}
impl AeronDriverContextBindingsClientdEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverContext {
    inner: CResource<aeron_driver_context_t>,
}
impl core::fmt::Debug for AeronDriverContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverContext))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverContext))
                .field("inner", &self.inner)
                .field(
                    stringify!(dirs_delete_on_start),
                    &self.dirs_delete_on_start(),
                )
                .field(
                    stringify!(dirs_delete_on_shutdown),
                    &self.dirs_delete_on_shutdown(),
                )
                .field(stringify!(warn_if_dirs_exist), &self.warn_if_dirs_exist())
                .field(
                    stringify!(term_buffer_sparse_file),
                    &self.term_buffer_sparse_file(),
                )
                .field(
                    stringify!(perform_storage_checks),
                    &self.perform_storage_checks(),
                )
                .field(
                    stringify!(spies_simulate_connection),
                    &self.spies_simulate_connection(),
                )
                .field(
                    stringify!(print_configuration_on_start),
                    &self.print_configuration_on_start(),
                )
                .field(stringify!(reliable_stream), &self.reliable_stream())
                .field(
                    stringify!(tether_subscriptions),
                    &self.tether_subscriptions(),
                )
                .field(stringify!(rejoin_stream), &self.rejoin_stream())
                .field(stringify!(ats_enabled), &self.ats_enabled())
                .field(stringify!(connect_enabled), &self.connect_enabled())
                .field(stringify!(driver_timeout_ms), &self.driver_timeout_ms())
                .field(
                    stringify!(client_liveness_timeout_ns),
                    &self.client_liveness_timeout_ns(),
                )
                .field(
                    stringify!(publication_linger_timeout_ns),
                    &self.publication_linger_timeout_ns(),
                )
                .field(
                    stringify!(status_message_timeout_ns),
                    &self.status_message_timeout_ns(),
                )
                .field(
                    stringify!(image_liveness_timeout_ns),
                    &self.image_liveness_timeout_ns(),
                )
                .field(
                    stringify!(publication_unblock_timeout_ns),
                    &self.publication_unblock_timeout_ns(),
                )
                .field(
                    stringify!(publication_connection_timeout_ns),
                    &self.publication_connection_timeout_ns(),
                )
                .field(stringify!(timer_interval_ns), &self.timer_interval_ns())
                .field(
                    stringify!(counter_free_to_reuse_ns),
                    &self.counter_free_to_reuse_ns(),
                )
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .field(
                    stringify!(retransmit_unicast_delay_ns),
                    &self.retransmit_unicast_delay_ns(),
                )
                .field(
                    stringify!(retransmit_unicast_linger_ns),
                    &self.retransmit_unicast_linger_ns(),
                )
                .field(
                    stringify!(nak_unicast_delay_ns),
                    &self.nak_unicast_delay_ns(),
                )
                .field(
                    stringify!(nak_unicast_retry_delay_ratio),
                    &self.nak_unicast_retry_delay_ratio(),
                )
                .field(
                    stringify!(nak_multicast_max_backoff_ns),
                    &self.nak_multicast_max_backoff_ns(),
                )
                .field(
                    stringify!(unicast_flow_control_rrwm),
                    &self.unicast_flow_control_rrwm(),
                )
                .field(
                    stringify!(multicast_flow_control_rrwm),
                    &self.multicast_flow_control_rrwm(),
                )
                .field(
                    stringify!(re_resolution_check_interval_ns),
                    &self.re_resolution_check_interval_ns(),
                )
                .field(
                    stringify!(low_file_store_warning_threshold),
                    &self.low_file_store_warning_threshold(),
                )
                .field(
                    stringify!(to_driver_buffer_length),
                    &self.to_driver_buffer_length(),
                )
                .field(
                    stringify!(to_clients_buffer_length),
                    &self.to_clients_buffer_length(),
                )
                .field(
                    stringify!(counters_values_buffer_length),
                    &self.counters_values_buffer_length(),
                )
                .field(stringify!(error_buffer_length), &self.error_buffer_length())
                .field(stringify!(term_buffer_length), &self.term_buffer_length())
                .field(
                    stringify!(ipc_term_buffer_length),
                    &self.ipc_term_buffer_length(),
                )
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(stringify!(ipc_mtu_length), &self.ipc_mtu_length())
                .field(
                    stringify!(ipc_publication_window_length),
                    &self.ipc_publication_window_length(),
                )
                .field(
                    stringify!(publication_window_length),
                    &self.publication_window_length(),
                )
                .field(stringify!(socket_rcvbuf), &self.socket_rcvbuf())
                .field(stringify!(socket_sndbuf), &self.socket_sndbuf())
                .field(
                    stringify!(send_to_sm_poll_ratio),
                    &self.send_to_sm_poll_ratio(),
                )
                .field(
                    stringify!(initial_window_length),
                    &self.initial_window_length(),
                )
                .field(stringify!(loss_report_length), &self.loss_report_length())
                .field(stringify!(file_page_size), &self.file_page_size())
                .field(
                    stringify!(nak_multicast_group_size),
                    &self.nak_multicast_group_size(),
                )
                .field(
                    stringify!(publication_reserved_session_id_low),
                    &self.publication_reserved_session_id_low(),
                )
                .field(
                    stringify!(publication_reserved_session_id_high),
                    &self.publication_reserved_session_id_high(),
                )
                .field(
                    stringify!(receiver_io_vector_capacity),
                    &self.receiver_io_vector_capacity(),
                )
                .field(
                    stringify!(sender_io_vector_capacity),
                    &self.sender_io_vector_capacity(),
                )
                .field(
                    stringify!(network_publication_max_messages_per_send),
                    &self.network_publication_max_messages_per_send(),
                )
                .field(stringify!(resource_free_limit), &self.resource_free_limit())
                .field(
                    stringify!(async_executor_threads),
                    &self.async_executor_threads(),
                )
                .field(stringify!(max_resend), &self.max_resend())
                .field(
                    stringify!(conductor_cpu_affinity_no),
                    &self.conductor_cpu_affinity_no(),
                )
                .field(
                    stringify!(receiver_cpu_affinity_no),
                    &self.receiver_cpu_affinity_no(),
                )
                .field(
                    stringify!(sender_cpu_affinity_no),
                    &self.sender_cpu_affinity_no(),
                )
                .field(
                    stringify!(stream_session_limit),
                    &self.stream_session_limit(),
                )
                .field(
                    stringify!(enable_experimental_features),
                    &self.enable_experimental_features(),
                )
                .field(stringify!(cnc_map), &self.cnc_map())
                .field(stringify!(loss_report), &self.loss_report())
                .field(
                    stringify!(sender_command_queue),
                    &self.sender_command_queue(),
                )
                .field(
                    stringify!(receiver_command_queue),
                    &self.receiver_command_queue(),
                )
                .field(
                    stringify!(conductor_command_queue),
                    &self.conductor_command_queue(),
                )
                .field(stringify!(next_receiver_id), &self.next_receiver_id())
                .field(
                    stringify!(unicast_delay_feedback_generator),
                    &self.unicast_delay_feedback_generator(),
                )
                .field(
                    stringify!(multicast_delay_feedback_generator),
                    &self.multicast_delay_feedback_generator(),
                )
                .field(
                    stringify!(conductor_duty_cycle_stall_tracker),
                    &self.conductor_duty_cycle_stall_tracker(),
                )
                .field(
                    stringify!(sender_duty_cycle_stall_tracker),
                    &self.sender_duty_cycle_stall_tracker(),
                )
                .field(
                    stringify!(receiver_duty_cycle_stall_tracker),
                    &self.receiver_duty_cycle_stall_tracker(),
                )
                .field(
                    stringify!(name_resolver_time_stall_tracker),
                    &self.name_resolver_time_stall_tracker(),
                )
                .field(
                    stringify!(sender_wildcard_port_manager),
                    &self.sender_wildcard_port_manager(),
                )
                .field(
                    stringify!(receiver_wildcard_port_manager),
                    &self.receiver_wildcard_port_manager(),
                )
                .field(
                    stringify!(num_bindings_clientd_entries),
                    &self.num_bindings_clientd_entries(),
                )
                .finish()
        }
    }
}
impl AeronDriverContext {
    #[doc = "Create a `AeronDriverContext` struct and initialize with default values."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new() -> Result<Self, AeronCError> {
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_driver_context_init(ctx_field) },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_driver_context_close(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    pub fn aeron_dir(&self) -> [::std::os::raw::c_char; 4096usize] {
        self.aeron_dir.into()
    }
    #[inline]
    pub fn threading_mode(&self) -> aeron_threading_mode_t {
        self.threading_mode.into()
    }
    #[inline]
    pub fn receiver_group_consideration(&self) -> aeron_inferable_boolean_t {
        self.receiver_group_consideration.into()
    }
    #[inline]
    pub fn dirs_delete_on_start(&self) -> bool {
        self.dirs_delete_on_start.into()
    }
    #[inline]
    pub fn dirs_delete_on_shutdown(&self) -> bool {
        self.dirs_delete_on_shutdown.into()
    }
    #[inline]
    pub fn warn_if_dirs_exist(&self) -> bool {
        self.warn_if_dirs_exist.into()
    }
    #[inline]
    pub fn term_buffer_sparse_file(&self) -> bool {
        self.term_buffer_sparse_file.into()
    }
    #[inline]
    pub fn perform_storage_checks(&self) -> bool {
        self.perform_storage_checks.into()
    }
    #[inline]
    pub fn spies_simulate_connection(&self) -> bool {
        self.spies_simulate_connection.into()
    }
    #[inline]
    pub fn print_configuration_on_start(&self) -> bool {
        self.print_configuration_on_start.into()
    }
    #[inline]
    pub fn reliable_stream(&self) -> bool {
        self.reliable_stream.into()
    }
    #[inline]
    pub fn tether_subscriptions(&self) -> bool {
        self.tether_subscriptions.into()
    }
    #[inline]
    pub fn rejoin_stream(&self) -> bool {
        self.rejoin_stream.into()
    }
    #[inline]
    pub fn ats_enabled(&self) -> bool {
        self.ats_enabled.into()
    }
    #[inline]
    pub fn connect_enabled(&self) -> bool {
        self.connect_enabled.into()
    }
    #[inline]
    pub fn driver_timeout_ms(&self) -> u64 {
        self.driver_timeout_ms.into()
    }
    #[inline]
    pub fn client_liveness_timeout_ns(&self) -> u64 {
        self.client_liveness_timeout_ns.into()
    }
    #[inline]
    pub fn publication_linger_timeout_ns(&self) -> u64 {
        self.publication_linger_timeout_ns.into()
    }
    #[inline]
    pub fn status_message_timeout_ns(&self) -> u64 {
        self.status_message_timeout_ns.into()
    }
    #[inline]
    pub fn image_liveness_timeout_ns(&self) -> u64 {
        self.image_liveness_timeout_ns.into()
    }
    #[inline]
    pub fn publication_unblock_timeout_ns(&self) -> u64 {
        self.publication_unblock_timeout_ns.into()
    }
    #[inline]
    pub fn publication_connection_timeout_ns(&self) -> u64 {
        self.publication_connection_timeout_ns.into()
    }
    #[inline]
    pub fn timer_interval_ns(&self) -> u64 {
        self.timer_interval_ns.into()
    }
    #[inline]
    pub fn counter_free_to_reuse_ns(&self) -> u64 {
        self.counter_free_to_reuse_ns.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> u64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> u64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline]
    pub fn retransmit_unicast_delay_ns(&self) -> u64 {
        self.retransmit_unicast_delay_ns.into()
    }
    #[inline]
    pub fn retransmit_unicast_linger_ns(&self) -> u64 {
        self.retransmit_unicast_linger_ns.into()
    }
    #[inline]
    pub fn nak_unicast_delay_ns(&self) -> u64 {
        self.nak_unicast_delay_ns.into()
    }
    #[inline]
    pub fn nak_unicast_retry_delay_ratio(&self) -> u64 {
        self.nak_unicast_retry_delay_ratio.into()
    }
    #[inline]
    pub fn nak_multicast_max_backoff_ns(&self) -> u64 {
        self.nak_multicast_max_backoff_ns.into()
    }
    #[inline]
    pub fn unicast_flow_control_rrwm(&self) -> usize {
        self.unicast_flow_control_rrwm.into()
    }
    #[inline]
    pub fn multicast_flow_control_rrwm(&self) -> usize {
        self.multicast_flow_control_rrwm.into()
    }
    #[inline]
    pub fn re_resolution_check_interval_ns(&self) -> u64 {
        self.re_resolution_check_interval_ns.into()
    }
    #[inline]
    pub fn low_file_store_warning_threshold(&self) -> u64 {
        self.low_file_store_warning_threshold.into()
    }
    #[inline]
    pub fn to_driver_buffer_length(&self) -> usize {
        self.to_driver_buffer_length.into()
    }
    #[inline]
    pub fn to_clients_buffer_length(&self) -> usize {
        self.to_clients_buffer_length.into()
    }
    #[inline]
    pub fn counters_values_buffer_length(&self) -> usize {
        self.counters_values_buffer_length.into()
    }
    #[inline]
    pub fn error_buffer_length(&self) -> usize {
        self.error_buffer_length.into()
    }
    #[inline]
    pub fn term_buffer_length(&self) -> usize {
        self.term_buffer_length.into()
    }
    #[inline]
    pub fn ipc_term_buffer_length(&self) -> usize {
        self.ipc_term_buffer_length.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> usize {
        self.mtu_length.into()
    }
    #[inline]
    pub fn ipc_mtu_length(&self) -> usize {
        self.ipc_mtu_length.into()
    }
    #[inline]
    pub fn ipc_publication_window_length(&self) -> usize {
        self.ipc_publication_window_length.into()
    }
    #[inline]
    pub fn publication_window_length(&self) -> usize {
        self.publication_window_length.into()
    }
    #[inline]
    pub fn socket_rcvbuf(&self) -> usize {
        self.socket_rcvbuf.into()
    }
    #[inline]
    pub fn socket_sndbuf(&self) -> usize {
        self.socket_sndbuf.into()
    }
    #[inline]
    pub fn send_to_sm_poll_ratio(&self) -> usize {
        self.send_to_sm_poll_ratio.into()
    }
    #[inline]
    pub fn initial_window_length(&self) -> usize {
        self.initial_window_length.into()
    }
    #[inline]
    pub fn loss_report_length(&self) -> usize {
        self.loss_report_length.into()
    }
    #[inline]
    pub fn file_page_size(&self) -> usize {
        self.file_page_size.into()
    }
    #[inline]
    pub fn nak_multicast_group_size(&self) -> usize {
        self.nak_multicast_group_size.into()
    }
    #[inline]
    pub fn publication_reserved_session_id_low(&self) -> i32 {
        self.publication_reserved_session_id_low.into()
    }
    #[inline]
    pub fn publication_reserved_session_id_high(&self) -> i32 {
        self.publication_reserved_session_id_high.into()
    }
    #[inline]
    pub fn multicast_ttl(&self) -> u8 {
        self.multicast_ttl.into()
    }
    #[inline]
    pub fn receiver_io_vector_capacity(&self) -> u32 {
        self.receiver_io_vector_capacity.into()
    }
    #[inline]
    pub fn sender_io_vector_capacity(&self) -> u32 {
        self.sender_io_vector_capacity.into()
    }
    #[inline]
    pub fn network_publication_max_messages_per_send(&self) -> u32 {
        self.network_publication_max_messages_per_send.into()
    }
    #[inline]
    pub fn resource_free_limit(&self) -> u32 {
        self.resource_free_limit.into()
    }
    #[inline]
    pub fn async_executor_threads(&self) -> u32 {
        self.async_executor_threads.into()
    }
    #[inline]
    pub fn max_resend(&self) -> u32 {
        self.max_resend.into()
    }
    #[inline]
    pub fn conductor_cpu_affinity_no(&self) -> i32 {
        self.conductor_cpu_affinity_no.into()
    }
    #[inline]
    pub fn receiver_cpu_affinity_no(&self) -> i32 {
        self.receiver_cpu_affinity_no.into()
    }
    #[inline]
    pub fn sender_cpu_affinity_no(&self) -> i32 {
        self.sender_cpu_affinity_no.into()
    }
    #[inline]
    pub fn stream_session_limit(&self) -> i32 {
        self.stream_session_limit.into()
    }
    #[inline]
    pub fn enable_experimental_features(&self) -> bool {
        self.enable_experimental_features.into()
    }
    #[inline]
    pub fn receiver_group_tag(&self) -> aeron_driver_context_stct__bindgen_ty_1 {
        self.receiver_group_tag.into()
    }
    #[inline]
    pub fn flow_control(&self) -> aeron_driver_context_stct__bindgen_ty_2 {
        self.flow_control.into()
    }
    #[inline]
    pub fn cnc_map(&self) -> AeronMappedFile {
        self.cnc_map.into()
    }
    #[inline]
    pub fn loss_report(&self) -> AeronMappedFile {
        self.loss_report.into()
    }
    #[inline]
    pub fn to_driver_buffer(&self) -> *mut u8 {
        self.to_driver_buffer.into()
    }
    #[inline]
    pub fn to_clients_buffer(&self) -> *mut u8 {
        self.to_clients_buffer.into()
    }
    #[inline]
    pub fn counters_values_buffer(&self) -> *mut u8 {
        self.counters_values_buffer.into()
    }
    #[inline]
    pub fn counters_metadata_buffer(&self) -> *mut u8 {
        self.counters_metadata_buffer.into()
    }
    #[inline]
    pub fn error_buffer(&self) -> *mut u8 {
        self.error_buffer.into()
    }
    #[inline]
    pub fn nano_clock(&self) -> aeron_clock_func_t {
        self.nano_clock.into()
    }
    #[inline]
    pub fn epoch_clock(&self) -> aeron_clock_func_t {
        self.epoch_clock.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn sender_cached_clock(&self) -> AeronClockCache {
        self.sender_cached_clock.into()
    }
    #[inline]
    pub fn receiver_cached_clock(&self) -> AeronClockCache {
        self.receiver_cached_clock.into()
    }
    #[inline]
    pub fn sender_command_queue(&self) -> AeronMpscRb {
        self.sender_command_queue.into()
    }
    #[inline]
    pub fn receiver_command_queue(&self) -> AeronMpscRb {
        self.receiver_command_queue.into()
    }
    #[inline]
    pub fn conductor_command_queue(&self) -> AeronMpscRb {
        self.conductor_command_queue.into()
    }
    #[inline]
    pub fn agent_on_start_func(&self) -> aeron_agent_on_start_func_t {
        self.agent_on_start_func.into()
    }
    #[inline]
    pub fn agent_on_start_state(&self) -> *mut ::std::os::raw::c_void {
        self.agent_on_start_state.into()
    }
    #[inline]
    pub fn agent_on_start_func_delegate(&self) -> aeron_agent_on_start_func_t {
        self.agent_on_start_func_delegate.into()
    }
    #[inline]
    pub fn agent_on_start_state_delegate(&self) -> *mut ::std::os::raw::c_void {
        self.agent_on_start_state_delegate.into()
    }
    #[inline]
    pub fn conductor_idle_strategy_func(&self) -> aeron_idle_strategy_func_t {
        self.conductor_idle_strategy_func.into()
    }
    #[inline]
    pub fn conductor_idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.conductor_idle_strategy_state.into()
    }
    #[inline]
    pub fn conductor_idle_strategy_init_args(&self) -> &str {
        if self.conductor_idle_strategy_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.conductor_idle_strategy_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn conductor_idle_strategy_name(&self) -> &str {
        if self.conductor_idle_strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.conductor_idle_strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn shared_idle_strategy_func(&self) -> aeron_idle_strategy_func_t {
        self.shared_idle_strategy_func.into()
    }
    #[inline]
    pub fn shared_idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.shared_idle_strategy_state.into()
    }
    #[inline]
    pub fn shared_idle_strategy_init_args(&self) -> &str {
        if self.shared_idle_strategy_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.shared_idle_strategy_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn shared_idle_strategy_name(&self) -> &str {
        if self.shared_idle_strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.shared_idle_strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn shared_network_idle_strategy_func(&self) -> aeron_idle_strategy_func_t {
        self.shared_network_idle_strategy_func.into()
    }
    #[inline]
    pub fn shared_network_idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.shared_network_idle_strategy_state.into()
    }
    #[inline]
    pub fn shared_network_idle_strategy_init_args(&self) -> &str {
        if self.shared_network_idle_strategy_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.shared_network_idle_strategy_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn shared_network_idle_strategy_name(&self) -> &str {
        if self.shared_network_idle_strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.shared_network_idle_strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn sender_idle_strategy_func(&self) -> aeron_idle_strategy_func_t {
        self.sender_idle_strategy_func.into()
    }
    #[inline]
    pub fn sender_idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.sender_idle_strategy_state.into()
    }
    #[inline]
    pub fn sender_idle_strategy_init_args(&self) -> &str {
        if self.sender_idle_strategy_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.sender_idle_strategy_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn sender_idle_strategy_name(&self) -> &str {
        if self.sender_idle_strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.sender_idle_strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn receiver_idle_strategy_func(&self) -> aeron_idle_strategy_func_t {
        self.receiver_idle_strategy_func.into()
    }
    #[inline]
    pub fn receiver_idle_strategy_state(&self) -> *mut ::std::os::raw::c_void {
        self.receiver_idle_strategy_state.into()
    }
    #[inline]
    pub fn receiver_idle_strategy_init_args(&self) -> &str {
        if self.receiver_idle_strategy_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.receiver_idle_strategy_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn receiver_idle_strategy_name(&self) -> &str {
        if self.receiver_idle_strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.receiver_idle_strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn usable_fs_space_func(&self) -> aeron_usable_fs_space_func_t {
        self.usable_fs_space_func.into()
    }
    #[inline]
    pub fn raw_log_map_func(&self) -> aeron_raw_log_map_func_t {
        self.raw_log_map_func.into()
    }
    #[inline]
    pub fn raw_log_close_func(&self) -> aeron_raw_log_close_func_t {
        self.raw_log_close_func.into()
    }
    #[inline]
    pub fn raw_log_free_func(&self) -> aeron_raw_log_free_func_t {
        self.raw_log_free_func.into()
    }
    #[inline]
    pub fn unicast_flow_control_supplier_func(
        &self,
    ) -> aeron_flow_control_strategy_supplier_func_t {
        self.unicast_flow_control_supplier_func.into()
    }
    #[inline]
    pub fn multicast_flow_control_supplier_func(
        &self,
    ) -> aeron_flow_control_strategy_supplier_func_t {
        self.multicast_flow_control_supplier_func.into()
    }
    #[inline]
    pub fn congestion_control_supplier_func(
        &self,
    ) -> aeron_congestion_control_strategy_supplier_func_t {
        self.congestion_control_supplier_func.into()
    }
    #[inline]
    pub fn conductor_proxy(&self) -> AeronDriverConductorProxy {
        self.conductor_proxy.into()
    }
    #[inline]
    pub fn sender_proxy(&self) -> AeronDriverSenderProxy {
        self.sender_proxy.into()
    }
    #[inline]
    pub fn receiver_proxy(&self) -> AeronDriverReceiverProxy {
        self.receiver_proxy.into()
    }
    #[inline]
    pub fn counters_manager(&self) -> AeronCountersManager {
        self.counters_manager.into()
    }
    #[inline]
    pub fn system_counters(&self) -> AeronSystemCounters {
        self.system_counters.into()
    }
    #[inline]
    pub fn error_log(&self) -> AeronDistinctErrorLog {
        self.error_log.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_driver_context_stct__bindgen_ty_3 {
        self.log.into()
    }
    #[inline]
    pub fn termination_validator_func(&self) -> aeron_driver_termination_validator_func_t {
        self.termination_validator_func.into()
    }
    #[inline]
    pub fn termination_validator_state(&self) -> *mut ::std::os::raw::c_void {
        self.termination_validator_state.into()
    }
    #[inline]
    pub fn termination_hook_func(&self) -> aeron_driver_termination_hook_func_t {
        self.termination_hook_func.into()
    }
    #[inline]
    pub fn termination_hook_state(&self) -> *mut ::std::os::raw::c_void {
        self.termination_hook_state.into()
    }
    #[inline]
    pub fn udp_channel_transport_bindings(&self) -> *mut aeron_udp_channel_transport_bindings_t {
        self.udp_channel_transport_bindings.into()
    }
    #[inline]
    pub fn conductor_udp_channel_transport_bindings(
        &self,
    ) -> *mut aeron_udp_channel_transport_bindings_t {
        self.conductor_udp_channel_transport_bindings.into()
    }
    #[inline]
    pub fn udp_channel_outgoing_interceptor_bindings(&self) -> AeronUdpChannelInterceptorBindings {
        self.udp_channel_outgoing_interceptor_bindings.into()
    }
    #[inline]
    pub fn udp_channel_incoming_interceptor_bindings(&self) -> AeronUdpChannelInterceptorBindings {
        self.udp_channel_incoming_interceptor_bindings.into()
    }
    #[inline]
    pub fn next_receiver_id(&self) -> i64 {
        self.next_receiver_id.into()
    }
    #[inline]
    pub fn unicast_delay_feedback_generator(&self) -> AeronFeedbackDelayGeneratorState {
        self.unicast_delay_feedback_generator.into()
    }
    #[inline]
    pub fn multicast_delay_feedback_generator(&self) -> AeronFeedbackDelayGeneratorState {
        self.multicast_delay_feedback_generator.into()
    }
    #[inline]
    pub fn resolver_name(&self) -> &str {
        if self.resolver_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.resolver_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn resolver_interface(&self) -> &str {
        if self.resolver_interface.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.resolver_interface)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn resolver_bootstrap_neighbor(&self) -> &str {
        if self.resolver_bootstrap_neighbor.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.resolver_bootstrap_neighbor)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn name_resolver_init_args(&self) -> &str {
        if self.name_resolver_init_args.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.name_resolver_init_args)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn name_resolver_supplier_func(&self) -> aeron_name_resolver_supplier_func_t {
        self.name_resolver_supplier_func.into()
    }
    #[inline]
    pub fn driver_name_resolver_bootstrap_resolver_supplier_func(
        &self,
    ) -> aeron_name_resolver_supplier_func_t {
        self.driver_name_resolver_bootstrap_resolver_supplier_func
            .into()
    }
    #[inline]
    pub fn conductor_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        self.conductor_duty_cycle_tracker.into()
    }
    #[inline]
    pub fn sender_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        self.sender_duty_cycle_tracker.into()
    }
    #[inline]
    pub fn receiver_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        self.receiver_duty_cycle_tracker.into()
    }
    #[inline]
    pub fn name_resolver_time_tracker(&self) -> AeronDutyCycleTracker {
        self.name_resolver_time_tracker.into()
    }
    #[inline]
    pub fn conductor_duty_cycle_stall_tracker(&self) -> AeronDutyCycleStallTracker {
        self.conductor_duty_cycle_stall_tracker.into()
    }
    #[inline]
    pub fn sender_duty_cycle_stall_tracker(&self) -> AeronDutyCycleStallTracker {
        self.sender_duty_cycle_stall_tracker.into()
    }
    #[inline]
    pub fn receiver_duty_cycle_stall_tracker(&self) -> AeronDutyCycleStallTracker {
        self.receiver_duty_cycle_stall_tracker.into()
    }
    #[inline]
    pub fn name_resolver_time_stall_tracker(&self) -> AeronDutyCycleStallTracker {
        self.name_resolver_time_stall_tracker.into()
    }
    #[inline]
    pub fn sender_port_manager(&self) -> AeronPortManager {
        self.sender_port_manager.into()
    }
    #[inline]
    pub fn receiver_port_manager(&self) -> AeronPortManager {
        self.receiver_port_manager.into()
    }
    #[inline]
    pub fn sender_wildcard_port_manager(&self) -> AeronWildcardPortManager {
        self.sender_wildcard_port_manager.into()
    }
    #[inline]
    pub fn receiver_wildcard_port_manager(&self) -> AeronWildcardPortManager {
        self.receiver_wildcard_port_manager.into()
    }
    #[inline]
    pub fn dynamic_libs(&self) -> AeronDlLoadedLibsState {
        self.dynamic_libs.into()
    }
    #[inline]
    pub fn bindings_clientd_entries(&self) -> AeronDriverContextBindingsClientdEntry {
        self.bindings_clientd_entries.into()
    }
    #[inline]
    pub fn num_bindings_clientd_entries(&self) -> usize {
        self.num_bindings_clientd_entries.into()
    }
    #[inline]
    pub fn os_buffer_lengths(&self) -> aeron_driver_context_stct__bindgen_ty_4 {
        self.os_buffer_lengths.into()
    }
    #[inline]
    pub fn set_dir(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_dir(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_dir(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_dir(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_dir_warn_if_exists(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_dir_warn_if_exists(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_dir_warn_if_exists(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_dir_warn_if_exists(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_threading_mode(&self, mode: aeron_threading_mode_t) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_threading_mode(self.get_inner(), mode.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_threading_mode(&self) -> aeron_threading_mode_t {
        unsafe {
            let result = aeron_driver_context_get_threading_mode(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_dir_delete_on_start(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_dir_delete_on_start(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_dir_delete_on_start(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_dir_delete_on_start(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_dir_delete_on_shutdown(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_dir_delete_on_shutdown(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_dir_delete_on_shutdown(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_dir_delete_on_shutdown(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_to_conductor_buffer_length(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_to_conductor_buffer_length(
                self.get_inner(),
                length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_to_conductor_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_to_conductor_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_to_clients_buffer_length(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_to_clients_buffer_length(self.get_inner(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_to_clients_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_to_clients_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_counters_buffer_length(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_counters_buffer_length(self.get_inner(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_counters_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_counters_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_error_buffer_length(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_error_buffer_length(self.get_inner(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_error_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_error_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_client_liveness_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_client_liveness_timeout_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_client_liveness_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_client_liveness_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_term_buffer_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_term_buffer_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_term_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_term_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_ipc_term_buffer_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_ipc_term_buffer_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_ipc_term_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_ipc_term_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_term_buffer_sparse_file(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_term_buffer_sparse_file(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_term_buffer_sparse_file(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_term_buffer_sparse_file(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_perform_storage_checks(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_perform_storage_checks(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_perform_storage_checks(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_perform_storage_checks(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_low_file_store_warning_threshold(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_low_file_store_warning_threshold(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_low_file_store_warning_threshold(&self) -> u64 {
        unsafe {
            let result =
                aeron_driver_context_get_low_file_store_warning_threshold(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_spies_simulate_connection(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_spies_simulate_connection(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_spies_simulate_connection(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_spies_simulate_connection(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_file_page_size(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_file_page_size(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_file_page_size(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_file_page_size(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_mtu_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_mtu_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_mtu_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_mtu_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_ipc_mtu_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_ipc_mtu_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_ipc_mtu_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_ipc_mtu_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_ipc_publication_term_window_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_ipc_publication_term_window_length(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_ipc_publication_term_window_length(&self) -> usize {
        unsafe {
            let result =
                aeron_driver_context_get_ipc_publication_term_window_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_term_window_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_term_window_length(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_term_window_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_publication_term_window_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_linger_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_linger_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_linger_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_publication_linger_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_socket_so_rcvbuf(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_socket_so_rcvbuf(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_socket_so_rcvbuf(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_socket_so_rcvbuf(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_socket_so_sndbuf(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_socket_so_sndbuf(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_socket_so_sndbuf(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_socket_so_sndbuf(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_socket_multicast_ttl(&self, value: u8) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_socket_multicast_ttl(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_socket_multicast_ttl(&self) -> u8 {
        unsafe {
            let result = aeron_driver_context_get_socket_multicast_ttl(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_send_to_status_poll_ratio(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_send_to_status_poll_ratio(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_send_to_status_poll_ratio(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_send_to_status_poll_ratio(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_rcv_status_message_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_rcv_status_message_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_rcv_status_message_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_rcv_status_message_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_multicast_flowcontrol_supplier(
        &self,
        value: aeron_flow_control_strategy_supplier_func_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_multicast_flowcontrol_supplier(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_multicast_flowcontrol_supplier(
        &self,
    ) -> aeron_flow_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_driver_context_get_multicast_flowcontrol_supplier(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_unicast_flowcontrol_supplier(
        &self,
        value: aeron_flow_control_strategy_supplier_func_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_unicast_flowcontrol_supplier(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_unicast_flowcontrol_supplier(&self) -> aeron_flow_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_driver_context_get_unicast_flowcontrol_supplier(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_image_liveness_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_image_liveness_timeout_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_image_liveness_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_image_liveness_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_rcv_initial_window_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_rcv_initial_window_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_rcv_initial_window_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_rcv_initial_window_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_congestioncontrol_supplier(
        &self,
        value: aeron_congestion_control_strategy_supplier_func_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_congestioncontrol_supplier(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_congestioncontrol_supplier(
        &self,
    ) -> aeron_congestion_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_driver_context_get_congestioncontrol_supplier(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_loss_report_buffer_length(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_loss_report_buffer_length(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_loss_report_buffer_length(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_loss_report_buffer_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_unblock_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_unblock_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_unblock_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_publication_unblock_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_connection_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_connection_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_connection_timeout_ns(&self) -> u64 {
        unsafe {
            let result =
                aeron_driver_context_get_publication_connection_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_timer_interval_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_timer_interval_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_timer_interval_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_timer_interval_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_idle_strategy(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_sender_idle_strategy(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_idle_strategy(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_sender_idle_strategy(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_conductor_idle_strategy(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_conductor_idle_strategy(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_conductor_idle_strategy(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_conductor_idle_strategy(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_receiver_idle_strategy(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_receiver_idle_strategy(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_idle_strategy(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_receiver_idle_strategy(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_sharednetwork_idle_strategy(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_sharednetwork_idle_strategy(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sharednetwork_idle_strategy(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_sharednetwork_idle_strategy(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_shared_idle_strategy(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_shared_idle_strategy(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_shared_idle_strategy(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_shared_idle_strategy(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_sender_idle_strategy_init_args(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_sender_idle_strategy_init_args(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_idle_strategy_init_args(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_sender_idle_strategy_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_conductor_idle_strategy_init_args(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_conductor_idle_strategy_init_args(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_conductor_idle_strategy_init_args(&self) -> &str {
        unsafe {
            let result =
                aeron_driver_context_get_conductor_idle_strategy_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_receiver_idle_strategy_init_args(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_idle_strategy_init_args(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_idle_strategy_init_args(&self) -> &str {
        unsafe {
            let result =
                aeron_driver_context_get_receiver_idle_strategy_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_sharednetwork_idle_strategy_init_args(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_sharednetwork_idle_strategy_init_args(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sharednetwork_idle_strategy_init_args(&self) -> &str {
        unsafe {
            let result =
                aeron_driver_context_get_sharednetwork_idle_strategy_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_shared_idle_strategy_init_args(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_shared_idle_strategy_init_args(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_shared_idle_strategy_init_args(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_shared_idle_strategy_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_agent_on_start_function<
        AeronAgentStartFuncHandlerImpl: AeronAgentStartFuncCallback,
    >(
        &self,
        value: Option<&Handler<AeronAgentStartFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_agent_on_start_function(
                self.get_inner(),
                {
                    let callback: aeron_agent_on_start_func_t = if value.is_none() {
                        None
                    } else {
                        Some(aeron_agent_on_start_func_t_callback::<AeronAgentStartFuncHandlerImpl>)
                    };
                    callback
                },
                value
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_agent_on_start_function_once<AeronAgentStartFuncHandlerImpl: FnMut(&str) -> ()>(
        &self,
        mut value: AeronAgentStartFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_agent_on_start_function(
                self.get_inner(),
                Some(
                    aeron_agent_on_start_func_t_callback_for_once_closure::<
                        AeronAgentStartFuncHandlerImpl,
                    >,
                ),
                &mut value as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_agent_on_start_function(&self) -> aeron_agent_on_start_func_t {
        unsafe {
            let result = aeron_driver_context_get_agent_on_start_function(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_agent_on_start_state(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_driver_context_get_agent_on_start_state(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_counters_free_to_reuse_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_counters_free_to_reuse_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_counters_free_to_reuse_timeout_ns(&self) -> u64 {
        unsafe {
            let result =
                aeron_driver_context_get_counters_free_to_reuse_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_flow_control_receiver_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_flow_control_receiver_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_flow_control_receiver_timeout_ns(&self) -> u64 {
        unsafe {
            let result =
                aeron_driver_context_get_flow_control_receiver_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_flow_control_group_tag(&self, value: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_flow_control_group_tag(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_flow_control_group_tag(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_flow_control_group_tag(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_flow_control_group_min_size(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_flow_control_group_min_size(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_flow_control_group_min_size(&self) -> i32 {
        unsafe {
            let result = aeron_driver_context_get_flow_control_group_min_size(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_group_tag(&self, is_present: bool, value: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_group_tag(
                self.get_inner(),
                is_present.into(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_group_tag_is_present(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_receiver_group_tag_is_present(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_receiver_group_tag_value(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_receiver_group_tag_value(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_driver_termination_validator<
        AeronDriverTerminationValidatorFuncHandlerImpl: AeronDriverTerminationValidatorFuncCallback,
    >(
        &self,
        value: Option<&Handler<AeronDriverTerminationValidatorFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_driver_termination_validator(
                self.get_inner(),
                {
                    let callback: aeron_driver_termination_validator_func_t = if value.is_none() {
                        None
                    } else {
                        Some(
                            aeron_driver_termination_validator_func_t_callback::<
                                AeronDriverTerminationValidatorFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                value
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_driver_termination_validator_once<
        AeronDriverTerminationValidatorFuncHandlerImpl: FnMut(&mut [u8]) -> bool,
    >(
        &self,
        mut value: AeronDriverTerminationValidatorFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_driver_termination_validator(
                self.get_inner(),
                Some(
                    aeron_driver_termination_validator_func_t_callback_for_once_closure::<
                        AeronDriverTerminationValidatorFuncHandlerImpl,
                    >,
                ),
                &mut value as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_driver_termination_validator(&self) -> aeron_driver_termination_validator_func_t {
        unsafe {
            let result = aeron_driver_context_get_driver_termination_validator(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_driver_termination_validator_state(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result =
                aeron_driver_context_get_driver_termination_validator_state(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_driver_termination_hook<
        AeronDriverTerminationHookFuncHandlerImpl: AeronDriverTerminationHookFuncCallback,
    >(
        &self,
        value: Option<&Handler<AeronDriverTerminationHookFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_driver_termination_hook(
                self.get_inner(),
                {
                    let callback: aeron_driver_termination_hook_func_t = if value.is_none() {
                        None
                    } else {
                        Some(
                            aeron_driver_termination_hook_func_t_callback::<
                                AeronDriverTerminationHookFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                value
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn set_driver_termination_hook_once<
        AeronDriverTerminationHookFuncHandlerImpl: FnMut() -> (),
    >(
        &self,
        mut value: AeronDriverTerminationHookFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_driver_termination_hook(
                self.get_inner(),
                Some(
                    aeron_driver_termination_hook_func_t_callback_for_once_closure::<
                        AeronDriverTerminationHookFuncHandlerImpl,
                    >,
                ),
                &mut value as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_driver_termination_hook(&self) -> aeron_driver_termination_hook_func_t {
        unsafe {
            let result = aeron_driver_context_get_driver_termination_hook(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn get_driver_termination_hook_state(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_driver_context_get_driver_termination_hook_state(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_print_configuration(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_print_configuration(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_print_configuration(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_print_configuration(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_reliable_stream(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_reliable_stream(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_reliable_stream(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_reliable_stream(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_tether_subscriptions(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_tether_subscriptions(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_tether_subscriptions(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_tether_subscriptions(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_untethered_window_limit_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_untethered_window_limit_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_untethered_window_limit_timeout_ns(&self) -> u64 {
        unsafe {
            let result =
                aeron_driver_context_get_untethered_window_limit_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_untethered_linger_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_untethered_linger_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_untethered_linger_timeout_ns(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_untethered_linger_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_untethered_resting_timeout_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_untethered_resting_timeout_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_untethered_resting_timeout_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_untethered_resting_timeout_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_driver_timeout_ms(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_driver_timeout_ms(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_driver_timeout_ms(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_driver_timeout_ms(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_nak_multicast_group_size(&self, value: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_nak_multicast_group_size(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_nak_multicast_group_size(&self) -> usize {
        unsafe {
            let result = aeron_driver_context_get_nak_multicast_group_size(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_nak_multicast_max_backoff_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_nak_multicast_max_backoff_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_nak_multicast_max_backoff_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_nak_multicast_max_backoff_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_nak_unicast_delay_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_nak_unicast_delay_ns(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_nak_unicast_delay_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_nak_unicast_delay_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_nak_unicast_retry_delay_ratio(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_nak_unicast_retry_delay_ratio(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_nak_unicast_retry_delay_ratio(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_nak_unicast_retry_delay_ratio(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_max_resend(&self, value: u32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_max_resend(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_max_resend(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_max_resend(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_retransmit_unicast_delay_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_retransmit_unicast_delay_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_retransmit_unicast_delay_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_retransmit_unicast_delay_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_retransmit_unicast_linger_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_retransmit_unicast_linger_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_retransmit_unicast_linger_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_retransmit_unicast_linger_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_group_consideration(
        &self,
        value: aeron_inferable_boolean_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_group_consideration(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_group_consideration(&self) -> aeron_inferable_boolean_t {
        unsafe {
            let result = aeron_driver_context_get_receiver_group_consideration(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_rejoin_stream(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_rejoin_stream(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_rejoin_stream(&self) -> bool {
        unsafe {
            let result = aeron_driver_context_get_rejoin_stream(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_connect_enabled(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_connect_enabled(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_connect_enabled(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_get_connect_enabled(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_udp_channel_transport_bindings(
        &self,
        value: *mut aeron_udp_channel_transport_bindings_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_udp_channel_transport_bindings(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_udp_channel_transport_bindings(
        &self,
    ) -> *mut aeron_udp_channel_transport_bindings_t {
        unsafe {
            let result = aeron_driver_context_get_udp_channel_transport_bindings(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_udp_channel_outgoing_interceptors(
        &self,
        value: &AeronUdpChannelInterceptorBindings,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_udp_channel_outgoing_interceptors(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_udp_channel_outgoing_interceptors(&self) -> AeronUdpChannelInterceptorBindings {
        unsafe {
            let result =
                aeron_driver_context_get_udp_channel_outgoing_interceptors(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_udp_channel_incoming_interceptors(
        &self,
        value: &AeronUdpChannelInterceptorBindings,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_udp_channel_incoming_interceptors(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_udp_channel_incoming_interceptors(&self) -> AeronUdpChannelInterceptorBindings {
        unsafe {
            let result =
                aeron_driver_context_get_udp_channel_incoming_interceptors(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_reserved_session_id_low(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_reserved_session_id_low(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_reserved_session_id_low(&self) -> i32 {
        unsafe {
            let result =
                aeron_driver_context_get_publication_reserved_session_id_low(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_publication_reserved_session_id_high(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_publication_reserved_session_id_high(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_publication_reserved_session_id_high(&self) -> i32 {
        unsafe {
            let result =
                aeron_driver_context_get_publication_reserved_session_id_high(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_resolver_name(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_resolver_name(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_resolver_name(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_resolver_name(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_resolver_interface(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_resolver_interface(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_resolver_interface(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_resolver_interface(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_resolver_bootstrap_neighbor(
        &self,
        value: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_resolver_bootstrap_neighbor(
                self.get_inner(),
                value.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_resolver_bootstrap_neighbor(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_resolver_bootstrap_neighbor(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_name_resolver_supplier(
        &self,
        value: aeron_name_resolver_supplier_func_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_name_resolver_supplier(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_name_resolver_supplier(&self) -> aeron_name_resolver_supplier_func_t {
        unsafe {
            let result = aeron_driver_context_get_name_resolver_supplier(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_name_resolver_init_args(&self, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_name_resolver_init_args(self.get_inner(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_name_resolver_init_args(&self) -> &str {
        unsafe {
            let result = aeron_driver_context_get_name_resolver_init_args(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn set_re_resolution_check_interval_ns(&self, value: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_re_resolution_check_interval_ns(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_re_resolution_check_interval_ns(&self) -> u64 {
        unsafe {
            let result = aeron_driver_context_get_re_resolution_check_interval_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_conductor_duty_cycle_tracker(
        &self,
        value: &AeronDutyCycleTracker,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_conductor_duty_cycle_tracker(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_conductor_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        unsafe {
            let result = aeron_driver_context_get_conductor_duty_cycle_tracker(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_duty_cycle_tracker(
        &self,
        value: &AeronDutyCycleTracker,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_sender_duty_cycle_tracker(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        unsafe {
            let result = aeron_driver_context_get_sender_duty_cycle_tracker(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_duty_cycle_tracker(
        &self,
        value: &AeronDutyCycleTracker,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_duty_cycle_tracker(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_duty_cycle_tracker(&self) -> AeronDutyCycleTracker {
        unsafe {
            let result = aeron_driver_context_get_receiver_duty_cycle_tracker(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_name_resolver_time_tracker(
        &self,
        value: &AeronDutyCycleTracker,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_name_resolver_time_tracker(
                self.get_inner(),
                value.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_name_resolver_time_tracker(&self) -> AeronDutyCycleTracker {
        unsafe {
            let result = aeron_driver_context_get_name_resolver_time_tracker(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_wildcard_port_range(
        &self,
        low_port: u16,
        high_port: u16,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_sender_wildcard_port_range(
                self.get_inner(),
                low_port.into(),
                high_port.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_wildcard_port_range(
        &self,
        low_port: &mut u16,
        high_port: &mut u16,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_get_sender_wildcard_port_range(
                self.get_inner(),
                low_port as *mut _,
                high_port as *mut _,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_receiver_wildcard_port_range(
        &self,
        low_port: u16,
        high_port: u16,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_wildcard_port_range(
                self.get_inner(),
                low_port.into(),
                high_port.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_wildcard_port_range(
        &self,
        low_port: &mut u16,
        high_port: &mut u16,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_get_receiver_wildcard_port_range(
                self.get_inner(),
                low_port as *mut _,
                high_port as *mut _,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_sender_port_manager(&self, value: &AeronPortManager) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_sender_port_manager(self.get_inner(), value.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_port_manager(&self) -> AeronPortManager {
        unsafe {
            let result = aeron_driver_context_get_sender_port_manager(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_port_manager(&self, value: &AeronPortManager) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_receiver_port_manager(self.get_inner(), value.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_port_manager(&self) -> AeronPortManager {
        unsafe {
            let result = aeron_driver_context_get_receiver_port_manager(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_conductor_cycle_threshold_ns(&self, value: u64) -> i64 {
        unsafe {
            let result = aeron_driver_context_set_conductor_cycle_threshold_ns(
                self.get_inner(),
                value.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn get_conductor_cycle_threshold_ns(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_conductor_cycle_threshold_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_cycle_threshold_ns(&self, value: u64) -> i64 {
        unsafe {
            let result =
                aeron_driver_context_set_sender_cycle_threshold_ns(self.get_inner(), value.into());
            result.into()
        }
    }
    #[inline]
    pub fn get_sender_cycle_threshold_ns(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_sender_cycle_threshold_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_cycle_threshold_ns(&self, value: u64) -> i64 {
        unsafe {
            let result = aeron_driver_context_set_receiver_cycle_threshold_ns(
                self.get_inner(),
                value.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn get_receiver_cycle_threshold_ns(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_receiver_cycle_threshold_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_name_resolver_threshold_ns(&self, value: u64) -> i64 {
        unsafe {
            let result =
                aeron_driver_context_set_name_resolver_threshold_ns(self.get_inner(), value.into());
            result.into()
        }
    }
    #[inline]
    pub fn get_name_resolver_threshold_ns(&self) -> i64 {
        unsafe {
            let result = aeron_driver_context_get_name_resolver_threshold_ns(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_io_vector_capacity(&self, value: u32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_receiver_io_vector_capacity(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_io_vector_capacity(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_receiver_io_vector_capacity(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_io_vector_capacity(&self, value: u32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_sender_io_vector_capacity(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_io_vector_capacity(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_sender_io_vector_capacity(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_network_publication_max_messages_per_send(
        &self,
        value: u32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_network_publication_max_messages_per_send(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_network_publication_max_messages_per_send(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_network_publication_max_messages_per_send(
                self.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn set_resource_free_limit(&self, value: u32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_resource_free_limit(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_resource_free_limit(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_resource_free_limit(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_async_executor_threads(&self, value: u32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_async_executor_threads(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_async_executor_threads(&self) -> u32 {
        unsafe {
            let result = aeron_driver_context_get_async_executor_threads(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_conductor_cpu_affinity(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_conductor_cpu_affinity(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_conductor_cpu_affinity(&self) -> i32 {
        unsafe {
            let result = aeron_driver_context_get_conductor_cpu_affinity(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_receiver_cpu_affinity(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_receiver_cpu_affinity(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_receiver_cpu_affinity(&self) -> i32 {
        unsafe {
            let result = aeron_driver_context_get_receiver_cpu_affinity(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_sender_cpu_affinity(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_sender_cpu_affinity(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_sender_cpu_affinity(&self) -> i32 {
        unsafe {
            let result = aeron_driver_context_get_sender_cpu_affinity(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn set_enable_experimental_features(&self, value: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_set_enable_experimental_features(
                self.get_inner(),
                value.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_enable_experimental_features(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_get_enable_experimental_features(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_stream_session_limit(&self, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_set_stream_session_limit(self.get_inner(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get_stream_session_limit(&self) -> i32 {
        unsafe {
            let result = aeron_driver_context_get_stream_session_limit(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Close and delete `AeronDriverContext` struct."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_driver_context_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn print_configuration(&self) -> () {
        unsafe {
            let result = aeron_driver_context_print_configuration(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_driver_fill_cnc_metadata(&self) -> () {
        unsafe {
            let result = aeron_driver_fill_cnc_metadata(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_driver_validate_unblock_timeout(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_validate_unblock_timeout(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_driver_validate_untethered_timeouts(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_validate_untethered_timeouts(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn validate_mtu_length(mtu_length: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_validate_mtu_length(mtu_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_cnc_length(&self) -> usize {
        unsafe {
            let result = aeron_cnc_length(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn run_storage_checks(&self, log_length: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_run_storage_checks(self.get_inner(), log_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bindings_clientd_create_entries(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_bindings_clientd_create_entries(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bindings_clientd_delete_entries(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_context_bindings_clientd_delete_entries(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bindings_clientd_find_first_free_index(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_bindings_clientd_find_first_free_index(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bindings_clientd_find(&self, name: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_driver_context_bindings_clientd_find(self.get_inner(), name.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bindings_clientd_get_or_find_first_free_entry(
        &self,
        name: &std::ffi::CStr,
    ) -> AeronDriverContextBindingsClientdEntry {
        unsafe {
            let result = aeron_driver_context_bindings_clientd_get_or_find_first_free_entry(
                self.get_inner(),
                name.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_resolution_change(
        &self,
        endpoint: &AeronSendChannelEndpoint,
        endpoint_name: &std::ffi::CStr,
        new_addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_resolution_change(
                self.get_inner(),
                endpoint.get_inner(),
                endpoint_name.as_ptr(),
                new_addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_context_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_context_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_context_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverContext {
    type Target = aeron_driver_context_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_context_t> for AeronDriverContext {
    #[inline]
    fn from(value: *mut aeron_driver_context_t) -> Self {
        AeronDriverContext {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverContext> for *mut aeron_driver_context_t {
    #[inline]
    fn from(value: AeronDriverContext) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverContext> for *mut aeron_driver_context_t {
    #[inline]
    fn from(value: &AeronDriverContext) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverContext> for aeron_driver_context_t {
    #[inline]
    fn from(value: AeronDriverContext) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_context_t> for AeronDriverContext {
    #[inline]
    fn from(value: *const aeron_driver_context_t) -> Self {
        AeronDriverContext {
            inner: CResource::Borrowed(value as *mut aeron_driver_context_t),
        }
    }
}
impl From<aeron_driver_context_t> for AeronDriverContext {
    #[inline]
    fn from(value: aeron_driver_context_t) -> Self {
        AeronDriverContext {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronDriverManagedResource {
    inner: CResource<aeron_driver_managed_resource_t>,
}
impl core::fmt::Debug for AeronDriverManagedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverManagedResource))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverManagedResource))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(
                    stringify!(time_of_last_state_change_ns),
                    &self.time_of_last_state_change_ns(),
                )
                .finish()
        }
    }
}
impl AeronDriverManagedResource {
    #[inline]
    pub fn new(
        registration_id: i64,
        time_of_last_state_change_ns: i64,
        clientd: *mut ::std::os::raw::c_void,
        handle_event: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: aeron_driver_managed_resource_event_t,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_managed_resource_t {
                    registration_id: registration_id.into(),
                    time_of_last_state_change_ns: time_of_last_state_change_ns.into(),
                    clientd: clientd.into(),
                    handle_event: handle_event.into(),
                };
                let inner_ptr: *mut aeron_driver_managed_resource_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_managed_resource_t)
                );
                let inst: aeron_driver_managed_resource_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_managed_resource_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_managed_resource_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn time_of_last_state_change_ns(&self) -> i64 {
        self.time_of_last_state_change_ns.into()
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline]
    pub fn handle_event(
        &self,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: aeron_driver_managed_resource_event_t,
            arg2: *mut ::std::os::raw::c_void,
        ),
    > {
        self.handle_event.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_managed_resource_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_managed_resource_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_managed_resource_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverManagedResource {
    type Target = aeron_driver_managed_resource_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_managed_resource_t> for AeronDriverManagedResource {
    #[inline]
    fn from(value: *mut aeron_driver_managed_resource_t) -> Self {
        AeronDriverManagedResource {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverManagedResource> for *mut aeron_driver_managed_resource_t {
    #[inline]
    fn from(value: AeronDriverManagedResource) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverManagedResource> for *mut aeron_driver_managed_resource_t {
    #[inline]
    fn from(value: &AeronDriverManagedResource) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverManagedResource> for aeron_driver_managed_resource_t {
    #[inline]
    fn from(value: AeronDriverManagedResource) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_managed_resource_t> for AeronDriverManagedResource {
    #[inline]
    fn from(value: *const aeron_driver_managed_resource_t) -> Self {
        AeronDriverManagedResource {
            inner: CResource::Borrowed(value as *mut aeron_driver_managed_resource_t),
        }
    }
}
impl From<aeron_driver_managed_resource_t> for AeronDriverManagedResource {
    #[inline]
    fn from(value: aeron_driver_managed_resource_t) -> Self {
        AeronDriverManagedResource {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverManagedResource {
    fn default() -> Self {
        AeronDriverManagedResource::new_zeroed_on_heap()
    }
}
impl AeronDriverManagedResource {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverReceiverImageEntry {
    inner: CResource<aeron_driver_receiver_image_entry_t>,
}
impl core::fmt::Debug for AeronDriverReceiverImageEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverReceiverImageEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverReceiverImageEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverReceiverImageEntry {
    #[inline]
    pub fn new(image: &AeronPublicationImage) -> Result<Self, AeronCError> {
        let image_copy = image.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_receiver_image_entry_t {
                    image: image.into(),
                };
                let inner_ptr: *mut aeron_driver_receiver_image_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_receiver_image_entry_t)
                );
                let inst: aeron_driver_receiver_image_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_receiver_image_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_receiver_image_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn image(&self) -> AeronPublicationImage {
        self.image.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_receiver_image_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_receiver_image_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_receiver_image_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverReceiverImageEntry {
    type Target = aeron_driver_receiver_image_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_receiver_image_entry_t> for AeronDriverReceiverImageEntry {
    #[inline]
    fn from(value: *mut aeron_driver_receiver_image_entry_t) -> Self {
        AeronDriverReceiverImageEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverReceiverImageEntry> for *mut aeron_driver_receiver_image_entry_t {
    #[inline]
    fn from(value: AeronDriverReceiverImageEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverReceiverImageEntry> for *mut aeron_driver_receiver_image_entry_t {
    #[inline]
    fn from(value: &AeronDriverReceiverImageEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverReceiverImageEntry> for aeron_driver_receiver_image_entry_t {
    #[inline]
    fn from(value: AeronDriverReceiverImageEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_receiver_image_entry_t> for AeronDriverReceiverImageEntry {
    #[inline]
    fn from(value: *const aeron_driver_receiver_image_entry_t) -> Self {
        AeronDriverReceiverImageEntry {
            inner: CResource::Borrowed(value as *mut aeron_driver_receiver_image_entry_t),
        }
    }
}
impl From<aeron_driver_receiver_image_entry_t> for AeronDriverReceiverImageEntry {
    #[inline]
    fn from(value: aeron_driver_receiver_image_entry_t) -> Self {
        AeronDriverReceiverImageEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverReceiverImageEntry {
    fn default() -> Self {
        AeronDriverReceiverImageEntry::new_zeroed_on_heap()
    }
}
impl AeronDriverReceiverImageEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverReceiverPendingSetupEntry {
    inner: CResource<aeron_driver_receiver_pending_setup_entry_t>,
}
impl core::fmt::Debug for AeronDriverReceiverPendingSetupEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverReceiverPendingSetupEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverReceiverPendingSetupEntry))
                .field("inner", &self.inner)
                .field(stringify!(is_periodic), &self.is_periodic())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(
                    stringify!(time_of_status_message_ns),
                    &self.time_of_status_message_ns(),
                )
                .field(stringify!(control_addr), &self.control_addr())
                .finish()
        }
    }
}
impl AeronDriverReceiverPendingSetupEntry {
    #[inline]
    pub fn new(
        is_periodic: bool,
        session_id: i32,
        stream_id: i32,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        time_of_status_message_ns: i64,
        control_addr: SockaddrStorage,
    ) -> Result<Self, AeronCError> {
        let endpoint_copy = endpoint.clone();
        let destination_copy = destination.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_receiver_pending_setup_entry_t {
                    is_periodic: is_periodic.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    endpoint: endpoint.into(),
                    destination: destination.into(),
                    time_of_status_message_ns: time_of_status_message_ns.into(),
                    control_addr: control_addr.into(),
                };
                let inner_ptr: *mut aeron_driver_receiver_pending_setup_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_receiver_pending_setup_entry_t)
                );
                let inst: aeron_driver_receiver_pending_setup_entry_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_receiver_pending_setup_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_receiver_pending_setup_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn is_periodic(&self) -> bool {
        self.is_periodic.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn endpoint(&self) -> AeronReceiveChannelEndpoint {
        self.endpoint.into()
    }
    #[inline]
    pub fn destination(&self) -> AeronReceiveDestination {
        self.destination.into()
    }
    #[inline]
    pub fn time_of_status_message_ns(&self) -> i64 {
        self.time_of_status_message_ns.into()
    }
    #[inline]
    pub fn control_addr(&self) -> SockaddrStorage {
        self.control_addr.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_receiver_pending_setup_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_receiver_pending_setup_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_receiver_pending_setup_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverReceiverPendingSetupEntry {
    type Target = aeron_driver_receiver_pending_setup_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_receiver_pending_setup_entry_t>
    for AeronDriverReceiverPendingSetupEntry
{
    #[inline]
    fn from(value: *mut aeron_driver_receiver_pending_setup_entry_t) -> Self {
        AeronDriverReceiverPendingSetupEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverReceiverPendingSetupEntry>
    for *mut aeron_driver_receiver_pending_setup_entry_t
{
    #[inline]
    fn from(value: AeronDriverReceiverPendingSetupEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverReceiverPendingSetupEntry>
    for *mut aeron_driver_receiver_pending_setup_entry_t
{
    #[inline]
    fn from(value: &AeronDriverReceiverPendingSetupEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverReceiverPendingSetupEntry> for aeron_driver_receiver_pending_setup_entry_t {
    #[inline]
    fn from(value: AeronDriverReceiverPendingSetupEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_receiver_pending_setup_entry_t>
    for AeronDriverReceiverPendingSetupEntry
{
    #[inline]
    fn from(value: *const aeron_driver_receiver_pending_setup_entry_t) -> Self {
        AeronDriverReceiverPendingSetupEntry {
            inner: CResource::Borrowed(value as *mut aeron_driver_receiver_pending_setup_entry_t),
        }
    }
}
impl From<aeron_driver_receiver_pending_setup_entry_t> for AeronDriverReceiverPendingSetupEntry {
    #[inline]
    fn from(value: aeron_driver_receiver_pending_setup_entry_t) -> Self {
        AeronDriverReceiverPendingSetupEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverReceiverPendingSetupEntry {
    fn default() -> Self {
        AeronDriverReceiverPendingSetupEntry::new_zeroed_on_heap()
    }
}
impl AeronDriverReceiverPendingSetupEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverReceiverProxy {
    inner: CResource<aeron_driver_receiver_proxy_t>,
}
impl core::fmt::Debug for AeronDriverReceiverProxy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverReceiverProxy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverReceiverProxy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverReceiverProxy {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_receiver_proxy_t)
                );
                let inst: aeron_driver_receiver_proxy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_receiver_proxy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_receiver_proxy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn receiver(&self) -> AeronDriverReceiver {
        self.receiver.into()
    }
    #[inline]
    pub fn threading_mode(&self) -> aeron_threading_mode_t {
        self.threading_mode.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_driver_receiver_proxy_stct__bindgen_ty_1 {
        self.log.into()
    }
    #[inline]
    pub fn command_queue(&self) -> AeronMpscRb {
        self.command_queue.into()
    }
    #[inline]
    pub fn fail_counter(&self) -> &mut i64 {
        unsafe { &mut *self.fail_counter }
    }
    #[inline]
    pub fn on_add_endpoint(&self, endpoint: &AeronReceiveChannelEndpoint) -> () {
        unsafe {
            let result =
                aeron_driver_receiver_proxy_on_add_endpoint(self.get_inner(), endpoint.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_endpoint(&self, endpoint: &AeronReceiveChannelEndpoint) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_endpoint(
                self.get_inner(),
                endpoint.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_subscription(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        stream_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_add_subscription(
                self.get_inner(),
                endpoint.get_inner(),
                stream_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_subscription(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        stream_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_subscription(
                self.get_inner(),
                endpoint.get_inner(),
                stream_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_subscription_by_session(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        stream_id: i32,
        session_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_add_subscription_by_session(
                self.get_inner(),
                endpoint.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_request_setup(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        stream_id: i32,
        session_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_request_setup(
                self.get_inner(),
                endpoint.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_subscription_by_session(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        stream_id: i32,
        session_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_subscription_by_session(
                self.get_inner(),
                endpoint.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_destination(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_add_destination(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        channel: &AeronUdpChannel,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_destination(
                self.get_inner(),
                endpoint.get_inner(),
                channel.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_publication_image(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        image: &AeronPublicationImage,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_add_publication_image(
                self.get_inner(),
                endpoint.get_inner(),
                image.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_publication_image(&self, image: &AeronPublicationImage) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_publication_image(
                self.get_inner(),
                image.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_cool_down(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        session_id: i32,
        stream_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_cool_down(
                self.get_inner(),
                endpoint.get_inner(),
                session_id.into(),
                stream_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_init_in_progress(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        session_id: i32,
        stream_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_remove_init_in_progress(
                self.get_inner(),
                endpoint.get_inner(),
                session_id.into(),
                stream_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_invalidate_image(
        &self,
        image_correlation_id: i64,
        position: i64,
        reason_length: i32,
        reason: &std::ffi::CStr,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_invalidate_image(
                self.get_inner(),
                image_correlation_id.into(),
                position.into(),
                reason_length.into(),
                reason.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_resolution_change(
        &self,
        endpoint_name: &std::ffi::CStr,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
        new_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_proxy_on_resolution_change(
                self.get_inner(),
                endpoint_name.as_ptr(),
                endpoint.into(),
                destination.into(),
                new_addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_receiver_proxy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_receiver_proxy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_receiver_proxy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverReceiverProxy {
    type Target = aeron_driver_receiver_proxy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_receiver_proxy_t> for AeronDriverReceiverProxy {
    #[inline]
    fn from(value: *mut aeron_driver_receiver_proxy_t) -> Self {
        AeronDriverReceiverProxy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverReceiverProxy> for *mut aeron_driver_receiver_proxy_t {
    #[inline]
    fn from(value: AeronDriverReceiverProxy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverReceiverProxy> for *mut aeron_driver_receiver_proxy_t {
    #[inline]
    fn from(value: &AeronDriverReceiverProxy) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverReceiverProxy> for aeron_driver_receiver_proxy_t {
    #[inline]
    fn from(value: AeronDriverReceiverProxy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_receiver_proxy_t> for AeronDriverReceiverProxy {
    #[inline]
    fn from(value: *const aeron_driver_receiver_proxy_t) -> Self {
        AeronDriverReceiverProxy {
            inner: CResource::Borrowed(value as *mut aeron_driver_receiver_proxy_t),
        }
    }
}
impl From<aeron_driver_receiver_proxy_t> for AeronDriverReceiverProxy {
    #[inline]
    fn from(value: aeron_driver_receiver_proxy_t) -> Self {
        AeronDriverReceiverProxy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronDriverReceiver {
    inner: CResource<aeron_driver_receiver_t>,
}
impl core::fmt::Debug for AeronDriverReceiver {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverReceiver))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverReceiver))
                .field("inner", &self.inner)
                .field(stringify!(receiver_proxy), &self.receiver_proxy())
                .field(stringify!(data_paths), &self.data_paths())
                .field(
                    stringify!(re_resolution_deadline_ns),
                    &self.re_resolution_deadline_ns(),
                )
                .finish()
        }
    }
}
impl AeronDriverReceiver {
    #[inline]
    pub fn new(
        receiver_proxy: AeronDriverReceiverProxy,
        poller: aeron_udp_transport_poller_t,
        recv_buffers: aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct,
        images: aeron_driver_receiver_stct_aeron_driver_receiver_images_stct,
        pending_setups: aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct,
        data_paths: AeronUdpChannelDataPaths,
        context: &AeronDriverContext,
        poller_poll_func: aeron_udp_transport_poller_poll_func_t,
        recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
        error_log: &AeronDistinctErrorLog,
        re_resolution_deadline_ns: i64,
        errors_counter: &mut i64,
        invalid_frames_counter: &mut i64,
        total_bytes_received_counter: &mut i64,
        resolution_changes_counter: &mut i64,
    ) -> Result<Self, AeronCError> {
        let context_copy = context.clone();
        let error_log_copy = error_log.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_receiver_t {
                    receiver_proxy: receiver_proxy.into(),
                    poller: poller.into(),
                    recv_buffers: recv_buffers.into(),
                    images: images.into(),
                    pending_setups: pending_setups.into(),
                    data_paths: data_paths.into(),
                    context: context.into(),
                    poller_poll_func: poller_poll_func.into(),
                    recvmmsg_func: recvmmsg_func.into(),
                    error_log: error_log.into(),
                    re_resolution_deadline_ns: re_resolution_deadline_ns.into(),
                    errors_counter: errors_counter as *mut _,
                    invalid_frames_counter: invalid_frames_counter as *mut _,
                    total_bytes_received_counter: total_bytes_received_counter as *mut _,
                    resolution_changes_counter: resolution_changes_counter as *mut _,
                };
                let inner_ptr: *mut aeron_driver_receiver_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_receiver_t)
                );
                let inst: aeron_driver_receiver_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_receiver_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_receiver_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn receiver_proxy(&self) -> AeronDriverReceiverProxy {
        self.receiver_proxy.into()
    }
    #[inline]
    pub fn poller(&self) -> aeron_udp_transport_poller_t {
        self.poller.into()
    }
    #[inline]
    pub fn recv_buffers(&self) -> aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct {
        self.recv_buffers.into()
    }
    #[inline]
    pub fn images(&self) -> aeron_driver_receiver_stct_aeron_driver_receiver_images_stct {
        self.images.into()
    }
    #[inline]
    pub fn pending_setups(
        &self,
    ) -> aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct {
        self.pending_setups.into()
    }
    #[inline]
    pub fn data_paths(&self) -> AeronUdpChannelDataPaths {
        self.data_paths.into()
    }
    #[inline]
    pub fn context(&self) -> AeronDriverContext {
        self.context.into()
    }
    #[inline]
    pub fn poller_poll_func(&self) -> aeron_udp_transport_poller_poll_func_t {
        self.poller_poll_func.into()
    }
    #[inline]
    pub fn recvmmsg_func(&self) -> aeron_udp_channel_transport_recvmmsg_func_t {
        self.recvmmsg_func.into()
    }
    #[inline]
    pub fn error_log(&self) -> AeronDistinctErrorLog {
        self.error_log.into()
    }
    #[inline]
    pub fn re_resolution_deadline_ns(&self) -> i64 {
        self.re_resolution_deadline_ns.into()
    }
    #[inline]
    pub fn errors_counter(&self) -> &mut i64 {
        unsafe { &mut *self.errors_counter }
    }
    #[inline]
    pub fn invalid_frames_counter(&self) -> &mut i64 {
        unsafe { &mut *self.invalid_frames_counter }
    }
    #[inline]
    pub fn total_bytes_received_counter(&self) -> &mut i64 {
        unsafe { &mut *self.total_bytes_received_counter }
    }
    #[inline]
    pub fn resolution_changes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.resolution_changes_counter }
    }
    #[inline]
    pub fn init(
        &self,
        context: &AeronDriverContext,
        system_counters: &AeronSystemCounters,
        error_log: &AeronDistinctErrorLog,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_receiver_init(
                self.get_inner(),
                context.get_inner(),
                system_counters.get_inner(),
                error_log.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn do_work(clientd: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_receiver_do_work(clientd.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_close(clientd: *mut ::std::os::raw::c_void) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_close(clientd.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_add_endpoint(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_remove_endpoint(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_subscription(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_add_subscription(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_subscription(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_remove_subscription(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_subscription_by_session(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_receiver_on_add_subscription_by_session(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_request_setup(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_request_setup(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_subscription_by_session(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_remove_subscription_by_session(
                clientd.into(),
                item.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_destination(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_add_destination(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_remove_destination(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_receiver_on_add_publication_image(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_receiver_on_remove_publication_image(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_matching_state(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_receiver_on_remove_matching_state(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_resolution_change(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_resolution_change(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_invalidate_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_receiver_on_invalidate_image(clientd.into(), item.into());
            result.into()
        }
    }
    #[inline]
    pub fn add_pending_setup(
        &self,
        endpoint: &AeronReceiveChannelEndpoint,
        destination: &AeronReceiveDestination,
        session_id: i32,
        stream_id: i32,
        control_addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_receiver_add_pending_setup(
                self.get_inner(),
                endpoint.get_inner(),
                destination.get_inner(),
                session_id.into(),
                stream_id.into(),
                control_addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_receiver_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_receiver_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_receiver_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverReceiver {
    type Target = aeron_driver_receiver_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_receiver_t> for AeronDriverReceiver {
    #[inline]
    fn from(value: *mut aeron_driver_receiver_t) -> Self {
        AeronDriverReceiver {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverReceiver> for *mut aeron_driver_receiver_t {
    #[inline]
    fn from(value: AeronDriverReceiver) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverReceiver> for *mut aeron_driver_receiver_t {
    #[inline]
    fn from(value: &AeronDriverReceiver) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverReceiver> for aeron_driver_receiver_t {
    #[inline]
    fn from(value: AeronDriverReceiver) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_receiver_t> for AeronDriverReceiver {
    #[inline]
    fn from(value: *const aeron_driver_receiver_t) -> Self {
        AeronDriverReceiver {
            inner: CResource::Borrowed(value as *mut aeron_driver_receiver_t),
        }
    }
}
impl From<aeron_driver_receiver_t> for AeronDriverReceiver {
    #[inline]
    fn from(value: aeron_driver_receiver_t) -> Self {
        AeronDriverReceiver {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverReceiver {
    fn default() -> Self {
        AeronDriverReceiver::new_zeroed_on_heap()
    }
}
impl AeronDriverReceiver {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverSenderNetworkPublicationEntry {
    inner: CResource<aeron_driver_sender_network_publication_entry_t>,
}
impl core::fmt::Debug for AeronDriverSenderNetworkPublicationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverSenderNetworkPublicationEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverSenderNetworkPublicationEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverSenderNetworkPublicationEntry {
    #[inline]
    pub fn new(publication: &AeronNetworkPublication) -> Result<Self, AeronCError> {
        let publication_copy = publication.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_sender_network_publication_entry_t {
                    publication: publication.into(),
                };
                let inner_ptr: *mut aeron_driver_sender_network_publication_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_sender_network_publication_entry_t)
                );
                let inst: aeron_driver_sender_network_publication_entry_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_sender_network_publication_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_sender_network_publication_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn publication(&self) -> AeronNetworkPublication {
        self.publication.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_sender_network_publication_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_sender_network_publication_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_sender_network_publication_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverSenderNetworkPublicationEntry {
    type Target = aeron_driver_sender_network_publication_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_sender_network_publication_entry_t>
    for AeronDriverSenderNetworkPublicationEntry
{
    #[inline]
    fn from(value: *mut aeron_driver_sender_network_publication_entry_t) -> Self {
        AeronDriverSenderNetworkPublicationEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverSenderNetworkPublicationEntry>
    for *mut aeron_driver_sender_network_publication_entry_t
{
    #[inline]
    fn from(value: AeronDriverSenderNetworkPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverSenderNetworkPublicationEntry>
    for *mut aeron_driver_sender_network_publication_entry_t
{
    #[inline]
    fn from(value: &AeronDriverSenderNetworkPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverSenderNetworkPublicationEntry>
    for aeron_driver_sender_network_publication_entry_t
{
    #[inline]
    fn from(value: AeronDriverSenderNetworkPublicationEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_sender_network_publication_entry_t>
    for AeronDriverSenderNetworkPublicationEntry
{
    #[inline]
    fn from(value: *const aeron_driver_sender_network_publication_entry_t) -> Self {
        AeronDriverSenderNetworkPublicationEntry {
            inner: CResource::Borrowed(
                value as *mut aeron_driver_sender_network_publication_entry_t,
            ),
        }
    }
}
impl From<aeron_driver_sender_network_publication_entry_t>
    for AeronDriverSenderNetworkPublicationEntry
{
    #[inline]
    fn from(value: aeron_driver_sender_network_publication_entry_t) -> Self {
        AeronDriverSenderNetworkPublicationEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverSenderNetworkPublicationEntry {
    fn default() -> Self {
        AeronDriverSenderNetworkPublicationEntry::new_zeroed_on_heap()
    }
}
impl AeronDriverSenderNetworkPublicationEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverSenderProxy {
    inner: CResource<aeron_driver_sender_proxy_t>,
}
impl core::fmt::Debug for AeronDriverSenderProxy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverSenderProxy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverSenderProxy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDriverSenderProxy {
    #[inline]
    pub fn new(
        sender: &AeronDriverSender,
        threading_mode: aeron_threading_mode_t,
        log: aeron_driver_sender_proxy_stct__bindgen_ty_1,
        command_queue: &AeronMpscRb,
        fail_counter: &mut i64,
    ) -> Result<Self, AeronCError> {
        let sender_copy = sender.clone();
        let command_queue_copy = command_queue.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_sender_proxy_t {
                    sender: sender.into(),
                    threading_mode: threading_mode.into(),
                    log: log.into(),
                    command_queue: command_queue.into(),
                    fail_counter: fail_counter as *mut _,
                };
                let inner_ptr: *mut aeron_driver_sender_proxy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_sender_proxy_t)
                );
                let inst: aeron_driver_sender_proxy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_sender_proxy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_sender_proxy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn sender(&self) -> AeronDriverSender {
        self.sender.into()
    }
    #[inline]
    pub fn threading_mode(&self) -> aeron_threading_mode_t {
        self.threading_mode.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_driver_sender_proxy_stct__bindgen_ty_1 {
        self.log.into()
    }
    #[inline]
    pub fn command_queue(&self) -> AeronMpscRb {
        self.command_queue.into()
    }
    #[inline]
    pub fn fail_counter(&self) -> &mut i64 {
        unsafe { &mut *self.fail_counter }
    }
    #[inline]
    pub fn on_add_endpoint(&self, endpoint: &AeronSendChannelEndpoint) -> () {
        unsafe {
            let result =
                aeron_driver_sender_proxy_on_add_endpoint(self.get_inner(), endpoint.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_endpoint(&self, endpoint: &AeronSendChannelEndpoint) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_remove_endpoint(
                self.get_inner(),
                endpoint.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_publication(&self, publication: &AeronNetworkPublication) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_add_publication(
                self.get_inner(),
                publication.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_publication(&self, publication: &AeronNetworkPublication) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_remove_publication(
                self.get_inner(),
                publication.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_resolution_change(
        &self,
        endpoint_name: &std::ffi::CStr,
        endpoint: &AeronSendChannelEndpoint,
        new_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_resolution_change(
                self.get_inner(),
                endpoint_name.as_ptr(),
                endpoint.get_inner(),
                new_addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_add_destination(
        &self,
        endpoint: &AeronSendChannelEndpoint,
        uri: &AeronUri,
        addr: &SockaddrStorage,
        destination_registration_id: i64,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_add_destination(
                self.get_inner(),
                endpoint.get_inner(),
                uri.get_inner(),
                addr.get_inner(),
                destination_registration_id.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination(
        &self,
        endpoint: &AeronSendChannelEndpoint,
        addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_remove_destination(
                self.get_inner(),
                endpoint.get_inner(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination_by_id(
        &self,
        endpoint: &AeronSendChannelEndpoint,
        destination_registration_id: i64,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_proxy_on_remove_destination_by_id(
                self.get_inner(),
                endpoint.get_inner(),
                destination_registration_id.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_sender_proxy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_sender_proxy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_sender_proxy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverSenderProxy {
    type Target = aeron_driver_sender_proxy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_sender_proxy_t> for AeronDriverSenderProxy {
    #[inline]
    fn from(value: *mut aeron_driver_sender_proxy_t) -> Self {
        AeronDriverSenderProxy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverSenderProxy> for *mut aeron_driver_sender_proxy_t {
    #[inline]
    fn from(value: AeronDriverSenderProxy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverSenderProxy> for *mut aeron_driver_sender_proxy_t {
    #[inline]
    fn from(value: &AeronDriverSenderProxy) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverSenderProxy> for aeron_driver_sender_proxy_t {
    #[inline]
    fn from(value: AeronDriverSenderProxy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_sender_proxy_t> for AeronDriverSenderProxy {
    #[inline]
    fn from(value: *const aeron_driver_sender_proxy_t) -> Self {
        AeronDriverSenderProxy {
            inner: CResource::Borrowed(value as *mut aeron_driver_sender_proxy_t),
        }
    }
}
impl From<aeron_driver_sender_proxy_t> for AeronDriverSenderProxy {
    #[inline]
    fn from(value: aeron_driver_sender_proxy_t) -> Self {
        AeronDriverSenderProxy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverSenderProxy {
    fn default() -> Self {
        AeronDriverSenderProxy::new_zeroed_on_heap()
    }
}
impl AeronDriverSenderProxy {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverSender {
    inner: CResource<aeron_driver_sender_t>,
}
impl core::fmt::Debug for AeronDriverSender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverSender))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverSender))
                .field("inner", &self.inner)
                .field(stringify!(sender_proxy), &self.sender_proxy())
                .field(stringify!(data_paths), &self.data_paths())
                .field(
                    stringify!(status_message_read_timeout_ns),
                    &self.status_message_read_timeout_ns(),
                )
                .field(
                    stringify!(control_poll_timeout_ns),
                    &self.control_poll_timeout_ns(),
                )
                .field(
                    stringify!(re_resolution_deadline_ns),
                    &self.re_resolution_deadline_ns(),
                )
                .field(stringify!(round_robin_index), &self.round_robin_index())
                .field(stringify!(duty_cycle_counter), &self.duty_cycle_counter())
                .field(stringify!(duty_cycle_ratio), &self.duty_cycle_ratio())
                .finish()
        }
    }
}
impl AeronDriverSender {
    #[inline]
    pub fn new(
        sender_proxy: AeronDriverSenderProxy,
        poller: aeron_udp_transport_poller_t,
        network_publications : aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct,
        recv_buffers: aeron_driver_sender_stct_aeron_driver_sender_buffers_stct,
        data_paths: AeronUdpChannelDataPaths,
        total_bytes_sent_counter: &mut i64,
        errors_counter: &mut i64,
        invalid_frames_counter: &mut i64,
        status_messages_received_counter: &mut i64,
        nak_messages_received_counter: &mut i64,
        error_messages_received_counter: &mut i64,
        resolution_changes_counter: &mut i64,
        short_sends_counter: &mut i64,
        context: &AeronDriverContext,
        poller_poll_func: aeron_udp_transport_poller_poll_func_t,
        recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
        error_log: &AeronDistinctErrorLog,
        status_message_read_timeout_ns: i64,
        control_poll_timeout_ns: i64,
        re_resolution_deadline_ns: i64,
        round_robin_index: usize,
        duty_cycle_counter: usize,
        duty_cycle_ratio: usize,
        padding: [u8; 64usize],
    ) -> Result<Self, AeronCError> {
        let context_copy = context.clone();
        let error_log_copy = error_log.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_sender_t {
                    sender_proxy: sender_proxy.into(),
                    poller: poller.into(),
                    network_publications: network_publications.into(),
                    recv_buffers: recv_buffers.into(),
                    data_paths: data_paths.into(),
                    total_bytes_sent_counter: total_bytes_sent_counter as *mut _,
                    errors_counter: errors_counter as *mut _,
                    invalid_frames_counter: invalid_frames_counter as *mut _,
                    status_messages_received_counter: status_messages_received_counter as *mut _,
                    nak_messages_received_counter: nak_messages_received_counter as *mut _,
                    error_messages_received_counter: error_messages_received_counter as *mut _,
                    resolution_changes_counter: resolution_changes_counter as *mut _,
                    short_sends_counter: short_sends_counter as *mut _,
                    context: context.into(),
                    poller_poll_func: poller_poll_func.into(),
                    recvmmsg_func: recvmmsg_func.into(),
                    error_log: error_log.into(),
                    status_message_read_timeout_ns: status_message_read_timeout_ns.into(),
                    control_poll_timeout_ns: control_poll_timeout_ns.into(),
                    re_resolution_deadline_ns: re_resolution_deadline_ns.into(),
                    round_robin_index: round_robin_index.into(),
                    duty_cycle_counter: duty_cycle_counter.into(),
                    duty_cycle_ratio: duty_cycle_ratio.into(),
                    padding: padding.into(),
                };
                let inner_ptr: *mut aeron_driver_sender_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_sender_t)
                );
                let inst: aeron_driver_sender_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_sender_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_sender_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn sender_proxy(&self) -> AeronDriverSenderProxy {
        self.sender_proxy.into()
    }
    #[inline]
    pub fn poller(&self) -> aeron_udp_transport_poller_t {
        self.poller.into()
    }
    #[inline]
    pub fn network_publications(
        &self,
    ) -> aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct {
        self.network_publications.into()
    }
    #[inline]
    pub fn recv_buffers(&self) -> aeron_driver_sender_stct_aeron_driver_sender_buffers_stct {
        self.recv_buffers.into()
    }
    #[inline]
    pub fn data_paths(&self) -> AeronUdpChannelDataPaths {
        self.data_paths.into()
    }
    #[inline]
    pub fn total_bytes_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.total_bytes_sent_counter }
    }
    #[inline]
    pub fn errors_counter(&self) -> &mut i64 {
        unsafe { &mut *self.errors_counter }
    }
    #[inline]
    pub fn invalid_frames_counter(&self) -> &mut i64 {
        unsafe { &mut *self.invalid_frames_counter }
    }
    #[inline]
    pub fn status_messages_received_counter(&self) -> &mut i64 {
        unsafe { &mut *self.status_messages_received_counter }
    }
    #[inline]
    pub fn nak_messages_received_counter(&self) -> &mut i64 {
        unsafe { &mut *self.nak_messages_received_counter }
    }
    #[inline]
    pub fn error_messages_received_counter(&self) -> &mut i64 {
        unsafe { &mut *self.error_messages_received_counter }
    }
    #[inline]
    pub fn resolution_changes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.resolution_changes_counter }
    }
    #[inline]
    pub fn short_sends_counter(&self) -> &mut i64 {
        unsafe { &mut *self.short_sends_counter }
    }
    #[inline]
    pub fn context(&self) -> AeronDriverContext {
        self.context.into()
    }
    #[inline]
    pub fn poller_poll_func(&self) -> aeron_udp_transport_poller_poll_func_t {
        self.poller_poll_func.into()
    }
    #[inline]
    pub fn recvmmsg_func(&self) -> aeron_udp_channel_transport_recvmmsg_func_t {
        self.recvmmsg_func.into()
    }
    #[inline]
    pub fn error_log(&self) -> AeronDistinctErrorLog {
        self.error_log.into()
    }
    #[inline]
    pub fn status_message_read_timeout_ns(&self) -> i64 {
        self.status_message_read_timeout_ns.into()
    }
    #[inline]
    pub fn control_poll_timeout_ns(&self) -> i64 {
        self.control_poll_timeout_ns.into()
    }
    #[inline]
    pub fn re_resolution_deadline_ns(&self) -> i64 {
        self.re_resolution_deadline_ns.into()
    }
    #[inline]
    pub fn round_robin_index(&self) -> usize {
        self.round_robin_index.into()
    }
    #[inline]
    pub fn duty_cycle_counter(&self) -> usize {
        self.duty_cycle_counter.into()
    }
    #[inline]
    pub fn duty_cycle_ratio(&self) -> usize {
        self.duty_cycle_ratio.into()
    }
    #[inline]
    pub fn padding(&self) -> [u8; 64usize] {
        self.padding.into()
    }
    #[inline]
    pub fn init(
        &self,
        context: &AeronDriverContext,
        system_counters: &AeronSystemCounters,
        error_log: &AeronDistinctErrorLog,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_sender_init(
                self.get_inner(),
                context.get_inner(),
                system_counters.get_inner(),
                error_log.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn do_work(clientd: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_sender_do_work(clientd.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_close(clientd: *mut ::std::os::raw::c_void) -> () {
        unsafe {
            let result = aeron_driver_sender_on_close(clientd.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_add_endpoint(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_remove_endpoint(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_publication(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_add_publication(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_publication(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_remove_publication(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_add_destination(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_add_destination(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_remove_destination(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_remove_destination_by_id(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_driver_sender_on_remove_destination_by_id(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_resolution_change(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result = aeron_driver_sender_on_resolution_change(clientd.into(), command.into());
            result.into()
        }
    }
    #[inline]
    pub fn do_send(&self, now_ns: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_sender_do_send(self.get_inner(), now_ns.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_sender_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_sender_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_sender_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverSender {
    type Target = aeron_driver_sender_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_sender_t> for AeronDriverSender {
    #[inline]
    fn from(value: *mut aeron_driver_sender_t) -> Self {
        AeronDriverSender {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverSender> for *mut aeron_driver_sender_t {
    #[inline]
    fn from(value: AeronDriverSender) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverSender> for *mut aeron_driver_sender_t {
    #[inline]
    fn from(value: &AeronDriverSender) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverSender> for aeron_driver_sender_t {
    #[inline]
    fn from(value: AeronDriverSender) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_sender_t> for AeronDriverSender {
    #[inline]
    fn from(value: *const aeron_driver_sender_t) -> Self {
        AeronDriverSender {
            inner: CResource::Borrowed(value as *mut aeron_driver_sender_t),
        }
    }
}
impl From<aeron_driver_sender_t> for AeronDriverSender {
    #[inline]
    fn from(value: aeron_driver_sender_t) -> Self {
        AeronDriverSender {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverSender {
    fn default() -> Self {
        AeronDriverSender::new_zeroed_on_heap()
    }
}
impl AeronDriverSender {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriver {
    inner: CResource<aeron_driver_t>,
    _context: Option<AeronDriverContext>,
}
impl core::fmt::Debug for AeronDriver {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriver))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriver))
                .field("inner", &self.inner)
                .field(stringify!(conductor), &self.conductor())
                .field(stringify!(sender), &self.sender())
                .field(stringify!(receiver), &self.receiver())
                .finish()
        }
    }
}
impl AeronDriver {
    #[doc = "Create a `AeronDriver` struct and initialize from the `AeronDriverContext` struct."]
    #[doc = ""]
    #[doc = " The given `AeronDriverContext` struct will be used exclusively by the driver. Do not reuse between drivers."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `context` to use for initialization."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new(context: &AeronDriverContext) -> Result<Self, AeronCError> {
        let context_copy = context.clone();
        let context: *mut aeron_driver_context_t = context.into();
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_driver_init(ctx_field, context) },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_driver_close(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
            _context: Some(context_copy),
        })
    }
    #[inline]
    pub fn context(&self) -> AeronDriverContext {
        self.context.into()
    }
    #[inline]
    pub fn conductor(&self) -> AeronDriverConductor {
        self.conductor.into()
    }
    #[inline]
    pub fn sender(&self) -> AeronDriverSender {
        self.sender.into()
    }
    #[inline]
    pub fn receiver(&self) -> AeronDriverReceiver {
        self.receiver.into()
    }
    #[inline]
    pub fn runners(&self) -> [aeron_agent_runner_t; 3usize] {
        self.runners.into()
    }
    #[inline]
    #[doc = "Start an `AeronDriver` given the threading mode. This may spawn threads for the Sender, Receiver, and Conductor"]
    #[doc = " depending on threading mode used."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `manual_main_loop` to be called by the caller for the Conductor do_work cycle."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn start(&self, manual_main_loop: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_start(self.get_inner(), manual_main_loop.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Call the Conductor (or Shared) main do_work duty cycle once."]
    #[doc = ""]
    #[doc = " Driver must have been created with manual_main_loop set to true."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn main_do_work(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_main_do_work(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Call the Conductor (or Shared) Idle Strategy."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `work_count` to pass to idle strategy."]
    pub fn main_idle_strategy(&self, work_count: ::std::os::raw::c_int) -> () {
        unsafe {
            let result = aeron_driver_main_idle_strategy(self.get_inner(), work_count.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Close and delete `AeronDriver` struct."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_driver_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn uri_get_offset_info(offset: i32) -> &'static str {
        unsafe {
            let result = aeron_driver_uri_get_offset_info(offset.into());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn threading_mode_to_string(mode: aeron_threading_mode_t) -> &'static str {
        unsafe {
            let result = aeron_driver_threading_mode_to_string(mode.into());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriver {
    type Target = aeron_driver_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_t> for AeronDriver {
    #[inline]
    fn from(value: *mut aeron_driver_t) -> Self {
        AeronDriver {
            inner: CResource::Borrowed(value),
            _context: None,
        }
    }
}
impl From<AeronDriver> for *mut aeron_driver_t {
    #[inline]
    fn from(value: AeronDriver) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriver> for *mut aeron_driver_t {
    #[inline]
    fn from(value: &AeronDriver) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriver> for aeron_driver_t {
    #[inline]
    fn from(value: AeronDriver) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_t> for AeronDriver {
    #[inline]
    fn from(value: *const aeron_driver_t) -> Self {
        AeronDriver {
            inner: CResource::Borrowed(value as *mut aeron_driver_t),
            _context: None,
        }
    }
}
impl From<aeron_driver_t> for AeronDriver {
    #[inline]
    fn from(value: aeron_driver_t) -> Self {
        AeronDriver {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
            _context: None,
        }
    }
}
#[derive(Clone)]
pub struct AeronDriverUriPublicationParams {
    inner: CResource<aeron_driver_uri_publication_params_t>,
}
impl core::fmt::Debug for AeronDriverUriPublicationParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverUriPublicationParams))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverUriPublicationParams))
                .field("inner", &self.inner)
                .field(stringify!(has_position), &self.has_position())
                .field(stringify!(is_sparse), &self.is_sparse())
                .field(stringify!(signal_eos), &self.signal_eos())
                .field(
                    stringify!(spies_simulate_connection),
                    &self.spies_simulate_connection(),
                )
                .field(stringify!(has_mtu_length), &self.has_mtu_length())
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(stringify!(has_term_length), &self.has_term_length())
                .field(stringify!(term_length), &self.term_length())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(linger_timeout_ns), &self.linger_timeout_ns())
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .field(stringify!(has_session_id), &self.has_session_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(entity_tag), &self.entity_tag())
                .field(
                    stringify!(response_correlation_id),
                    &self.response_correlation_id(),
                )
                .field(stringify!(has_max_resend), &self.has_max_resend())
                .field(stringify!(max_resend), &self.max_resend())
                .field(
                    stringify!(has_publication_window_length),
                    &self.has_publication_window_length(),
                )
                .field(
                    stringify!(publication_window_length),
                    &self.publication_window_length(),
                )
                .field(stringify!(is_response), &self.is_response())
                .finish()
        }
    }
}
impl AeronDriverUriPublicationParams {
    #[inline]
    pub fn new(
        has_position: bool,
        is_sparse: bool,
        signal_eos: bool,
        spies_simulate_connection: bool,
        has_mtu_length: bool,
        mtu_length: usize,
        has_term_length: bool,
        term_length: usize,
        term_offset: usize,
        initial_term_id: i32,
        term_id: i32,
        linger_timeout_ns: u64,
        untethered_window_limit_timeout_ns: u64,
        untethered_linger_timeout_ns: i64,
        untethered_resting_timeout_ns: u64,
        has_session_id: bool,
        session_id: i32,
        entity_tag: i64,
        response_correlation_id: i64,
        has_max_resend: bool,
        max_resend: u32,
        has_publication_window_length: bool,
        publication_window_length: i32,
        is_response: bool,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_uri_publication_params_t {
                    has_position: has_position.into(),
                    is_sparse: is_sparse.into(),
                    signal_eos: signal_eos.into(),
                    spies_simulate_connection: spies_simulate_connection.into(),
                    has_mtu_length: has_mtu_length.into(),
                    mtu_length: mtu_length.into(),
                    has_term_length: has_term_length.into(),
                    term_length: term_length.into(),
                    term_offset: term_offset.into(),
                    initial_term_id: initial_term_id.into(),
                    term_id: term_id.into(),
                    linger_timeout_ns: linger_timeout_ns.into(),
                    untethered_window_limit_timeout_ns: untethered_window_limit_timeout_ns.into(),
                    untethered_linger_timeout_ns: untethered_linger_timeout_ns.into(),
                    untethered_resting_timeout_ns: untethered_resting_timeout_ns.into(),
                    has_session_id: has_session_id.into(),
                    session_id: session_id.into(),
                    entity_tag: entity_tag.into(),
                    response_correlation_id: response_correlation_id.into(),
                    has_max_resend: has_max_resend.into(),
                    max_resend: max_resend.into(),
                    has_publication_window_length: has_publication_window_length.into(),
                    publication_window_length: publication_window_length.into(),
                    is_response: is_response.into(),
                };
                let inner_ptr: *mut aeron_driver_uri_publication_params_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_uri_publication_params_t)
                );
                let inst: aeron_driver_uri_publication_params_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_uri_publication_params_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_uri_publication_params_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn has_position(&self) -> bool {
        self.has_position.into()
    }
    #[inline]
    pub fn is_sparse(&self) -> bool {
        self.is_sparse.into()
    }
    #[inline]
    pub fn signal_eos(&self) -> bool {
        self.signal_eos.into()
    }
    #[inline]
    pub fn spies_simulate_connection(&self) -> bool {
        self.spies_simulate_connection.into()
    }
    #[inline]
    pub fn has_mtu_length(&self) -> bool {
        self.has_mtu_length.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> usize {
        self.mtu_length.into()
    }
    #[inline]
    pub fn has_term_length(&self) -> bool {
        self.has_term_length.into()
    }
    #[inline]
    pub fn term_length(&self) -> usize {
        self.term_length.into()
    }
    #[inline]
    pub fn term_offset(&self) -> usize {
        self.term_offset.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn linger_timeout_ns(&self) -> u64 {
        self.linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> u64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> u64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline]
    pub fn has_session_id(&self) -> bool {
        self.has_session_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn entity_tag(&self) -> i64 {
        self.entity_tag.into()
    }
    #[inline]
    pub fn response_correlation_id(&self) -> i64 {
        self.response_correlation_id.into()
    }
    #[inline]
    pub fn has_max_resend(&self) -> bool {
        self.has_max_resend.into()
    }
    #[inline]
    pub fn max_resend(&self) -> u32 {
        self.max_resend.into()
    }
    #[inline]
    pub fn has_publication_window_length(&self) -> bool {
        self.has_publication_window_length.into()
    }
    #[inline]
    pub fn publication_window_length(&self) -> i32 {
        self.publication_window_length.into()
    }
    #[inline]
    pub fn is_response(&self) -> bool {
        self.is_response.into()
    }
    #[inline]
    pub fn aeron_publication_params_validate_mtu_for_sndbuf(
        &self,
        endpoint_socket_sndbuf: usize,
        channel_socket_sndbuf: usize,
        context_socket_sndbuf: usize,
        os_default_socket_sndbuf: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_params_validate_mtu_for_sndbuf(
                self.get_inner(),
                endpoint_socket_sndbuf.into(),
                channel_socket_sndbuf.into(),
                context_socket_sndbuf.into(),
                os_default_socket_sndbuf.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_uri_publication_params_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_uri_publication_params_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_uri_publication_params_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverUriPublicationParams {
    type Target = aeron_driver_uri_publication_params_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_uri_publication_params_t> for AeronDriverUriPublicationParams {
    #[inline]
    fn from(value: *mut aeron_driver_uri_publication_params_t) -> Self {
        AeronDriverUriPublicationParams {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverUriPublicationParams> for *mut aeron_driver_uri_publication_params_t {
    #[inline]
    fn from(value: AeronDriverUriPublicationParams) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverUriPublicationParams> for *mut aeron_driver_uri_publication_params_t {
    #[inline]
    fn from(value: &AeronDriverUriPublicationParams) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverUriPublicationParams> for aeron_driver_uri_publication_params_t {
    #[inline]
    fn from(value: AeronDriverUriPublicationParams) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_uri_publication_params_t> for AeronDriverUriPublicationParams {
    #[inline]
    fn from(value: *const aeron_driver_uri_publication_params_t) -> Self {
        AeronDriverUriPublicationParams {
            inner: CResource::Borrowed(value as *mut aeron_driver_uri_publication_params_t),
        }
    }
}
impl From<aeron_driver_uri_publication_params_t> for AeronDriverUriPublicationParams {
    #[inline]
    fn from(value: aeron_driver_uri_publication_params_t) -> Self {
        AeronDriverUriPublicationParams {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverUriPublicationParams {
    fn default() -> Self {
        AeronDriverUriPublicationParams::new_zeroed_on_heap()
    }
}
impl AeronDriverUriPublicationParams {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDriverUriSubscriptionParams {
    inner: CResource<aeron_driver_uri_subscription_params_t>,
}
impl core::fmt::Debug for AeronDriverUriSubscriptionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDriverUriSubscriptionParams))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDriverUriSubscriptionParams))
                .field("inner", &self.inner)
                .field(stringify!(is_reliable), &self.is_reliable())
                .field(stringify!(is_sparse), &self.is_sparse())
                .field(stringify!(is_tether), &self.is_tether())
                .field(stringify!(is_rejoin), &self.is_rejoin())
                .field(stringify!(has_session_id), &self.has_session_id())
                .field(stringify!(is_response), &self.is_response())
                .field(stringify!(session_id), &self.session_id())
                .field(
                    stringify!(initial_window_length),
                    &self.initial_window_length(),
                )
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .finish()
        }
    }
}
impl AeronDriverUriSubscriptionParams {
    #[inline]
    pub fn new(
        is_reliable: bool,
        is_sparse: bool,
        is_tether: bool,
        is_rejoin: bool,
        has_session_id: bool,
        is_response: bool,
        group: aeron_inferable_boolean_t,
        session_id: i32,
        initial_window_length: usize,
        untethered_window_limit_timeout_ns: u64,
        untethered_linger_timeout_ns: i64,
        untethered_resting_timeout_ns: u64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_driver_uri_subscription_params_t {
                    is_reliable: is_reliable.into(),
                    is_sparse: is_sparse.into(),
                    is_tether: is_tether.into(),
                    is_rejoin: is_rejoin.into(),
                    has_session_id: has_session_id.into(),
                    is_response: is_response.into(),
                    group: group.into(),
                    session_id: session_id.into(),
                    initial_window_length: initial_window_length.into(),
                    untethered_window_limit_timeout_ns: untethered_window_limit_timeout_ns.into(),
                    untethered_linger_timeout_ns: untethered_linger_timeout_ns.into(),
                    untethered_resting_timeout_ns: untethered_resting_timeout_ns.into(),
                };
                let inner_ptr: *mut aeron_driver_uri_subscription_params_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_driver_uri_subscription_params_t)
                );
                let inst: aeron_driver_uri_subscription_params_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_driver_uri_subscription_params_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_driver_uri_subscription_params_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn is_reliable(&self) -> bool {
        self.is_reliable.into()
    }
    #[inline]
    pub fn is_sparse(&self) -> bool {
        self.is_sparse.into()
    }
    #[inline]
    pub fn is_tether(&self) -> bool {
        self.is_tether.into()
    }
    #[inline]
    pub fn is_rejoin(&self) -> bool {
        self.is_rejoin.into()
    }
    #[inline]
    pub fn has_session_id(&self) -> bool {
        self.has_session_id.into()
    }
    #[inline]
    pub fn is_response(&self) -> bool {
        self.is_response.into()
    }
    #[inline]
    pub fn group(&self) -> aeron_inferable_boolean_t {
        self.group.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn initial_window_length(&self) -> usize {
        self.initial_window_length.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> u64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> u64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_driver_uri_subscription_params_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_driver_uri_subscription_params_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_driver_uri_subscription_params_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDriverUriSubscriptionParams {
    type Target = aeron_driver_uri_subscription_params_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_driver_uri_subscription_params_t> for AeronDriverUriSubscriptionParams {
    #[inline]
    fn from(value: *mut aeron_driver_uri_subscription_params_t) -> Self {
        AeronDriverUriSubscriptionParams {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDriverUriSubscriptionParams> for *mut aeron_driver_uri_subscription_params_t {
    #[inline]
    fn from(value: AeronDriverUriSubscriptionParams) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDriverUriSubscriptionParams> for *mut aeron_driver_uri_subscription_params_t {
    #[inline]
    fn from(value: &AeronDriverUriSubscriptionParams) -> Self {
        value.get_inner()
    }
}
impl From<AeronDriverUriSubscriptionParams> for aeron_driver_uri_subscription_params_t {
    #[inline]
    fn from(value: AeronDriverUriSubscriptionParams) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_driver_uri_subscription_params_t> for AeronDriverUriSubscriptionParams {
    #[inline]
    fn from(value: *const aeron_driver_uri_subscription_params_t) -> Self {
        AeronDriverUriSubscriptionParams {
            inner: CResource::Borrowed(value as *mut aeron_driver_uri_subscription_params_t),
        }
    }
}
impl From<aeron_driver_uri_subscription_params_t> for AeronDriverUriSubscriptionParams {
    #[inline]
    fn from(value: aeron_driver_uri_subscription_params_t) -> Self {
        AeronDriverUriSubscriptionParams {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDriverUriSubscriptionParams {
    fn default() -> Self {
        AeronDriverUriSubscriptionParams::new_zeroed_on_heap()
    }
}
impl AeronDriverUriSubscriptionParams {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDutyCycleStallTracker {
    inner: CResource<aeron_duty_cycle_stall_tracker_t>,
}
impl core::fmt::Debug for AeronDutyCycleStallTracker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDutyCycleStallTracker))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDutyCycleStallTracker))
                .field("inner", &self.inner)
                .field(
                    stringify!(last_time_of_update_ns),
                    &self.last_time_of_update_ns(),
                )
                .field(stringify!(cycle_threshold_ns), &self.cycle_threshold_ns())
                .finish()
        }
    }
}
impl AeronDutyCycleStallTracker {
    #[inline]
    pub fn new(
        tracker: aeron_duty_cycle_tracker_stct,
        lhs_padding: [::std::os::raw::c_char; 56usize],
        last_time_of_update_ns: i64,
        rhs_padding: [::std::os::raw::c_char; 56usize],
        cycle_threshold_ns: u64,
        max_cycle_time_counter: &mut i64,
        cycle_time_threshold_exceeded_counter: &mut i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_duty_cycle_stall_tracker_t {
                    tracker: tracker.into(),
                    lhs_padding: lhs_padding.into(),
                    last_time_of_update_ns: last_time_of_update_ns.into(),
                    rhs_padding: rhs_padding.into(),
                    cycle_threshold_ns: cycle_threshold_ns.into(),
                    max_cycle_time_counter: max_cycle_time_counter as *mut _,
                    cycle_time_threshold_exceeded_counter: cycle_time_threshold_exceeded_counter
                        as *mut _,
                };
                let inner_ptr: *mut aeron_duty_cycle_stall_tracker_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_duty_cycle_stall_tracker_t)
                );
                let inst: aeron_duty_cycle_stall_tracker_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_duty_cycle_stall_tracker_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_duty_cycle_stall_tracker_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn tracker(&self) -> aeron_duty_cycle_tracker_stct {
        self.tracker.into()
    }
    #[inline]
    pub fn lhs_padding(&self) -> [::std::os::raw::c_char; 56usize] {
        self.lhs_padding.into()
    }
    #[inline]
    pub fn last_time_of_update_ns(&self) -> i64 {
        self.last_time_of_update_ns.into()
    }
    #[inline]
    pub fn rhs_padding(&self) -> [::std::os::raw::c_char; 56usize] {
        self.rhs_padding.into()
    }
    #[inline]
    pub fn cycle_threshold_ns(&self) -> u64 {
        self.cycle_threshold_ns.into()
    }
    #[inline]
    pub fn max_cycle_time_counter(&self) -> &mut i64 {
        unsafe { &mut *self.max_cycle_time_counter }
    }
    #[inline]
    pub fn cycle_time_threshold_exceeded_counter(&self) -> &mut i64 {
        unsafe { &mut *self.cycle_time_threshold_exceeded_counter }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_duty_cycle_stall_tracker_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_duty_cycle_stall_tracker_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_duty_cycle_stall_tracker_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDutyCycleStallTracker {
    type Target = aeron_duty_cycle_stall_tracker_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_duty_cycle_stall_tracker_t> for AeronDutyCycleStallTracker {
    #[inline]
    fn from(value: *mut aeron_duty_cycle_stall_tracker_t) -> Self {
        AeronDutyCycleStallTracker {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDutyCycleStallTracker> for *mut aeron_duty_cycle_stall_tracker_t {
    #[inline]
    fn from(value: AeronDutyCycleStallTracker) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDutyCycleStallTracker> for *mut aeron_duty_cycle_stall_tracker_t {
    #[inline]
    fn from(value: &AeronDutyCycleStallTracker) -> Self {
        value.get_inner()
    }
}
impl From<AeronDutyCycleStallTracker> for aeron_duty_cycle_stall_tracker_t {
    #[inline]
    fn from(value: AeronDutyCycleStallTracker) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_duty_cycle_stall_tracker_t> for AeronDutyCycleStallTracker {
    #[inline]
    fn from(value: *const aeron_duty_cycle_stall_tracker_t) -> Self {
        AeronDutyCycleStallTracker {
            inner: CResource::Borrowed(value as *mut aeron_duty_cycle_stall_tracker_t),
        }
    }
}
impl From<aeron_duty_cycle_stall_tracker_t> for AeronDutyCycleStallTracker {
    #[inline]
    fn from(value: aeron_duty_cycle_stall_tracker_t) -> Self {
        AeronDutyCycleStallTracker {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDutyCycleStallTracker {
    fn default() -> Self {
        AeronDutyCycleStallTracker::new_zeroed_on_heap()
    }
}
impl AeronDutyCycleStallTracker {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronDutyCycleTracker {
    inner: CResource<aeron_duty_cycle_tracker_t>,
}
impl core::fmt::Debug for AeronDutyCycleTracker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronDutyCycleTracker))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronDutyCycleTracker))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronDutyCycleTracker {
    #[inline]
    pub fn new<
        AeronDutyCycleTrackerMeasureAndUpdateFuncHandlerImpl: AeronDutyCycleTrackerMeasureAndUpdateFuncCallback,
    >(
        update: aeron_duty_cycle_tracker_update_func_t,
        measure_and_update: Option<&Handler<AeronDutyCycleTrackerMeasureAndUpdateFuncHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_duty_cycle_tracker_t {
                    update: update.into(),
                    measure_and_update: {
                        let callback: aeron_duty_cycle_tracker_measure_and_update_func_t =
                            if measure_and_update.is_none() {
                                None
                            } else {
                                Some(
                                    aeron_duty_cycle_tracker_measure_and_update_func_t_callback::<
                                        AeronDutyCycleTrackerMeasureAndUpdateFuncHandlerImpl,
                                    >,
                                )
                            };
                        callback
                    },
                    state: measure_and_update
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                };
                let inner_ptr: *mut aeron_duty_cycle_tracker_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_duty_cycle_tracker_t)
                );
                let inst: aeron_duty_cycle_tracker_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_duty_cycle_tracker_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_duty_cycle_tracker_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn update(&self) -> aeron_duty_cycle_tracker_update_func_t {
        self.update.into()
    }
    #[inline]
    pub fn measure_and_update(&self) -> aeron_duty_cycle_tracker_measure_and_update_func_t {
        self.measure_and_update.into()
    }
    #[inline]
    pub fn state(&self) -> *mut ::std::os::raw::c_void {
        self.state.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_duty_cycle_tracker_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_duty_cycle_tracker_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_duty_cycle_tracker_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronDutyCycleTracker {
    type Target = aeron_duty_cycle_tracker_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_duty_cycle_tracker_t> for AeronDutyCycleTracker {
    #[inline]
    fn from(value: *mut aeron_duty_cycle_tracker_t) -> Self {
        AeronDutyCycleTracker {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronDutyCycleTracker> for *mut aeron_duty_cycle_tracker_t {
    #[inline]
    fn from(value: AeronDutyCycleTracker) -> Self {
        value.get_inner()
    }
}
impl From<&AeronDutyCycleTracker> for *mut aeron_duty_cycle_tracker_t {
    #[inline]
    fn from(value: &AeronDutyCycleTracker) -> Self {
        value.get_inner()
    }
}
impl From<AeronDutyCycleTracker> for aeron_duty_cycle_tracker_t {
    #[inline]
    fn from(value: AeronDutyCycleTracker) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_duty_cycle_tracker_t> for AeronDutyCycleTracker {
    #[inline]
    fn from(value: *const aeron_duty_cycle_tracker_t) -> Self {
        AeronDutyCycleTracker {
            inner: CResource::Borrowed(value as *mut aeron_duty_cycle_tracker_t),
        }
    }
}
impl From<aeron_duty_cycle_tracker_t> for AeronDutyCycleTracker {
    #[inline]
    fn from(value: aeron_duty_cycle_tracker_t) -> Self {
        AeronDutyCycleTracker {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronDutyCycleTracker {
    fn default() -> Self {
        AeronDutyCycleTracker::new_zeroed_on_heap()
    }
}
impl AeronDutyCycleTracker {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronEndOfLifeResource {
    inner: CResource<aeron_end_of_life_resource_t>,
}
impl core::fmt::Debug for AeronEndOfLifeResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronEndOfLifeResource))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronEndOfLifeResource))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronEndOfLifeResource {
    #[inline]
    pub fn new(
        resource: *mut ::std::os::raw::c_void,
        free_func: aeron_end_of_life_resource_free_t,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_end_of_life_resource_t {
                    resource: resource.into(),
                    free_func: free_func.into(),
                };
                let inner_ptr: *mut aeron_end_of_life_resource_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_end_of_life_resource_t)
                );
                let inst: aeron_end_of_life_resource_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_end_of_life_resource_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_end_of_life_resource_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn resource(&self) -> *mut ::std::os::raw::c_void {
        self.resource.into()
    }
    #[inline]
    pub fn free_func(&self) -> aeron_end_of_life_resource_free_t {
        self.free_func.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_end_of_life_resource_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_end_of_life_resource_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_end_of_life_resource_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronEndOfLifeResource {
    type Target = aeron_end_of_life_resource_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_end_of_life_resource_t> for AeronEndOfLifeResource {
    #[inline]
    fn from(value: *mut aeron_end_of_life_resource_t) -> Self {
        AeronEndOfLifeResource {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronEndOfLifeResource> for *mut aeron_end_of_life_resource_t {
    #[inline]
    fn from(value: AeronEndOfLifeResource) -> Self {
        value.get_inner()
    }
}
impl From<&AeronEndOfLifeResource> for *mut aeron_end_of_life_resource_t {
    #[inline]
    fn from(value: &AeronEndOfLifeResource) -> Self {
        value.get_inner()
    }
}
impl From<AeronEndOfLifeResource> for aeron_end_of_life_resource_t {
    #[inline]
    fn from(value: AeronEndOfLifeResource) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_end_of_life_resource_t> for AeronEndOfLifeResource {
    #[inline]
    fn from(value: *const aeron_end_of_life_resource_t) -> Self {
        AeronEndOfLifeResource {
            inner: CResource::Borrowed(value as *mut aeron_end_of_life_resource_t),
        }
    }
}
impl From<aeron_end_of_life_resource_t> for AeronEndOfLifeResource {
    #[inline]
    fn from(value: aeron_end_of_life_resource_t) -> Self {
        AeronEndOfLifeResource {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronEndOfLifeResource {
    fn default() -> Self {
        AeronEndOfLifeResource::new_zeroed_on_heap()
    }
}
impl AeronEndOfLifeResource {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronErrorLogEntry {
    inner: CResource<aeron_error_log_entry_t>,
}
impl core::fmt::Debug for AeronErrorLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronErrorLogEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronErrorLogEntry))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .field(stringify!(observation_count), &self.observation_count())
                .field(
                    stringify!(last_observation_timestamp),
                    &self.last_observation_timestamp(),
                )
                .field(
                    stringify!(first_observation_timestamp),
                    &self.first_observation_timestamp(),
                )
                .finish()
        }
    }
}
impl AeronErrorLogEntry {
    #[inline]
    pub fn new(
        length: i32,
        observation_count: i32,
        last_observation_timestamp: i64,
        first_observation_timestamp: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_error_log_entry_t {
                    length: length.into(),
                    observation_count: observation_count.into(),
                    last_observation_timestamp: last_observation_timestamp.into(),
                    first_observation_timestamp: first_observation_timestamp.into(),
                };
                let inner_ptr: *mut aeron_error_log_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_error_log_entry_t)
                );
                let inst: aeron_error_log_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_error_log_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_error_log_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn length(&self) -> i32 {
        self.length.into()
    }
    #[inline]
    pub fn observation_count(&self) -> i32 {
        self.observation_count.into()
    }
    #[inline]
    pub fn last_observation_timestamp(&self) -> i64 {
        self.last_observation_timestamp.into()
    }
    #[inline]
    pub fn first_observation_timestamp(&self) -> i64 {
        self.first_observation_timestamp.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_error_log_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_error_log_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_error_log_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronErrorLogEntry {
    type Target = aeron_error_log_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_error_log_entry_t> for AeronErrorLogEntry {
    #[inline]
    fn from(value: *mut aeron_error_log_entry_t) -> Self {
        AeronErrorLogEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronErrorLogEntry> for *mut aeron_error_log_entry_t {
    #[inline]
    fn from(value: AeronErrorLogEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronErrorLogEntry> for *mut aeron_error_log_entry_t {
    #[inline]
    fn from(value: &AeronErrorLogEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronErrorLogEntry> for aeron_error_log_entry_t {
    #[inline]
    fn from(value: AeronErrorLogEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_error_log_entry_t> for AeronErrorLogEntry {
    #[inline]
    fn from(value: *const aeron_error_log_entry_t) -> Self {
        AeronErrorLogEntry {
            inner: CResource::Borrowed(value as *mut aeron_error_log_entry_t),
        }
    }
}
impl From<aeron_error_log_entry_t> for AeronErrorLogEntry {
    #[inline]
    fn from(value: aeron_error_log_entry_t) -> Self {
        AeronErrorLogEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronErrorLogEntry {
    fn default() -> Self {
        AeronErrorLogEntry::new_zeroed_on_heap()
    }
}
impl AeronErrorLogEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronErrorResponse {
    inner: CResource<aeron_error_response_t>,
}
impl core::fmt::Debug for AeronErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronErrorResponse))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronErrorResponse))
                .field("inner", &self.inner)
                .field(
                    stringify!(offending_command_correlation_id),
                    &self.offending_command_correlation_id(),
                )
                .field(stringify!(error_code), &self.error_code())
                .field(
                    stringify!(error_message_length),
                    &self.error_message_length(),
                )
                .finish()
        }
    }
}
impl AeronErrorResponse {
    #[inline]
    pub fn new(
        offending_command_correlation_id: i64,
        error_code: i32,
        error_message_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_error_response_t {
                    offending_command_correlation_id: offending_command_correlation_id.into(),
                    error_code: error_code.into(),
                    error_message_length: error_message_length.into(),
                };
                let inner_ptr: *mut aeron_error_response_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_error_response_t)
                );
                let inst: aeron_error_response_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_error_response_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_error_response_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn offending_command_correlation_id(&self) -> i64 {
        self.offending_command_correlation_id.into()
    }
    #[inline]
    pub fn error_code(&self) -> i32 {
        self.error_code.into()
    }
    #[inline]
    pub fn error_message_length(&self) -> i32 {
        self.error_message_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_error_response_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_error_response_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_error_response_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronErrorResponse {
    type Target = aeron_error_response_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_error_response_t> for AeronErrorResponse {
    #[inline]
    fn from(value: *mut aeron_error_response_t) -> Self {
        AeronErrorResponse {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronErrorResponse> for *mut aeron_error_response_t {
    #[inline]
    fn from(value: AeronErrorResponse) -> Self {
        value.get_inner()
    }
}
impl From<&AeronErrorResponse> for *mut aeron_error_response_t {
    #[inline]
    fn from(value: &AeronErrorResponse) -> Self {
        value.get_inner()
    }
}
impl From<AeronErrorResponse> for aeron_error_response_t {
    #[inline]
    fn from(value: AeronErrorResponse) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_error_response_t> for AeronErrorResponse {
    #[inline]
    fn from(value: *const aeron_error_response_t) -> Self {
        AeronErrorResponse {
            inner: CResource::Borrowed(value as *mut aeron_error_response_t),
        }
    }
}
impl From<aeron_error_response_t> for AeronErrorResponse {
    #[inline]
    fn from(value: aeron_error_response_t) -> Self {
        AeronErrorResponse {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronErrorResponse {
    fn default() -> Self {
        AeronErrorResponse::new_zeroed_on_heap()
    }
}
impl AeronErrorResponse {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronError {
    inner: CResource<aeron_error_t>,
}
impl core::fmt::Debug for AeronError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronError))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronError))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(receiver_id), &self.receiver_id())
                .field(stringify!(group_tag), &self.group_tag())
                .field(stringify!(error_code), &self.error_code())
                .field(stringify!(error_length), &self.error_length())
                .finish()
        }
    }
}
impl AeronError {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        session_id: i32,
        stream_id: i32,
        receiver_id: i64,
        group_tag: i64,
        error_code: i32,
        error_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_error_t {
                    frame_header: frame_header.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    receiver_id: receiver_id.into(),
                    group_tag: group_tag.into(),
                    error_code: error_code.into(),
                    error_length: error_length.into(),
                };
                let inner_ptr: *mut aeron_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_error_t)
                );
                let inst: aeron_error_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_error_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn group_tag(&self) -> i64 {
        self.group_tag.into()
    }
    #[inline]
    pub fn error_code(&self) -> i32 {
        self.error_code.into()
    }
    #[inline]
    pub fn error_length(&self) -> i32 {
        self.error_length.into()
    }
    #[inline]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn code_str(errcode: ::std::os::raw::c_int) -> &'static str {
        unsafe {
            let result = aeron_error_code_str(errcode.into());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_error_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_error_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_error_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronError {
    type Target = aeron_error_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_error_t> for AeronError {
    #[inline]
    fn from(value: *mut aeron_error_t) -> Self {
        AeronError {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronError> for *mut aeron_error_t {
    #[inline]
    fn from(value: AeronError) -> Self {
        value.get_inner()
    }
}
impl From<&AeronError> for *mut aeron_error_t {
    #[inline]
    fn from(value: &AeronError) -> Self {
        value.get_inner()
    }
}
impl From<AeronError> for aeron_error_t {
    #[inline]
    fn from(value: AeronError) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_error_t> for AeronError {
    #[inline]
    fn from(value: *const aeron_error_t) -> Self {
        AeronError {
            inner: CResource::Borrowed(value as *mut aeron_error_t),
        }
    }
}
impl From<aeron_error_t> for AeronError {
    #[inline]
    fn from(value: aeron_error_t) -> Self {
        AeronError {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronError {
    fn default() -> Self {
        AeronError::new_zeroed_on_heap()
    }
}
impl AeronError {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronExclusivePublication {
    inner: CResource<aeron_exclusive_publication_t>,
}
impl core::fmt::Debug for AeronExclusivePublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronExclusivePublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronExclusivePublication))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronExclusivePublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_exclusive_publication_t)
                );
                let inst: aeron_exclusive_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_exclusive_publication_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            Some(|c| unsafe { aeron_exclusive_publication_is_closed(c) }),
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_exclusive_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Non-blocking publish of a buffer containing a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` to publish."]
    #[doc = " \n - `length` of the buffer."]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn offer<AeronReservedValueSupplierHandlerImpl: AeronReservedValueSupplierCallback>(
        &self,
        buffer: &[u8],
        reserved_value_supplier: Option<&Handler<AeronReservedValueSupplierHandlerImpl>>,
    ) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_offer(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                {
                    let callback: aeron_reserved_value_supplier_t =
                        if reserved_value_supplier.is_none() {
                            None
                        } else {
                            Some(
                                aeron_reserved_value_supplier_t_callback::<
                                    AeronReservedValueSupplierHandlerImpl,
                                >,
                            )
                        };
                    callback
                },
                reserved_value_supplier
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish of a buffer containing a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` to publish."]
    #[doc = " \n - `length` of the buffer."]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn offer_once<AeronReservedValueSupplierHandlerImpl: FnMut(*mut u8, usize) -> i64>(
        &self,
        buffer: &[u8],
        mut reserved_value_supplier: AeronReservedValueSupplierHandlerImpl,
    ) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_offer(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                Some(
                    aeron_reserved_value_supplier_t_callback_for_once_closure::<
                        AeronReservedValueSupplierHandlerImpl,
                    >,
                ),
                &mut reserved_value_supplier as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish by gathering buffer vectors into a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `iov` array for the vectors"]
    #[doc = " \n - `iovcnt` of the number of vectors"]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn offerv<AeronReservedValueSupplierHandlerImpl: AeronReservedValueSupplierCallback>(
        &self,
        iov: &AeronIovec,
        iovcnt: usize,
        reserved_value_supplier: Option<&Handler<AeronReservedValueSupplierHandlerImpl>>,
    ) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_offerv(
                self.get_inner(),
                iov.get_inner(),
                iovcnt.into(),
                {
                    let callback: aeron_reserved_value_supplier_t =
                        if reserved_value_supplier.is_none() {
                            None
                        } else {
                            Some(
                                aeron_reserved_value_supplier_t_callback::<
                                    AeronReservedValueSupplierHandlerImpl,
                                >,
                            )
                        };
                    callback
                },
                reserved_value_supplier
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish by gathering buffer vectors into a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `iov` array for the vectors"]
    #[doc = " \n - `iovcnt` of the number of vectors"]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn offerv_once<AeronReservedValueSupplierHandlerImpl: FnMut(*mut u8, usize) -> i64>(
        &self,
        iov: &AeronIovec,
        iovcnt: usize,
        mut reserved_value_supplier: AeronReservedValueSupplierHandlerImpl,
    ) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_offerv(
                self.get_inner(),
                iov.get_inner(),
                iovcnt.into(),
                Some(
                    aeron_reserved_value_supplier_t_callback_for_once_closure::<
                        AeronReservedValueSupplierHandlerImpl,
                    >,
                ),
                &mut reserved_value_supplier as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Try to claim a range in the publication log into which a message can be written with zero copy semantics."]
    #[doc = " Once the message has been written then aeron_buffer_claim_commit should be called thus making it available."]
    #[doc = " A claim length cannot be greater than max payload length."]
    #[doc = " \n"]
    #[doc = " <b>Note:</b> This method can only be used for message lengths less than MTU length minus header."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " `AeronBufferClaim` buffer_claim;"]
    #[doc = ""]
    #[doc = " if (`AeronExclusivePublication`ry_claim(publication, length, &buffer_claim) > 0L)"]
    #[doc = " {"]
    #[doc = "     // work with buffer_claim->data directly."]
    #[doc = "     aeron_buffer_claim_commit(&buffer_claim);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `length` of the message."]
    #[doc = " \n - `buffer_claim` to be populated if the claim succeeds."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn try_claim(&self, length: usize, buffer_claim: &AeronBufferClaim) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_try_claim(
                self.get_inner(),
                length.into(),
                buffer_claim.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Append a padding record log of a given length to make up the log to a position."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `length` of the range to claim, in bytes."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn append_padding(&self, length: usize) -> i64 {
        unsafe {
            let result =
                aeron_exclusive_publication_append_padding(self.get_inner(), length.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Offer a block of pre-formatted message fragments directly into the current term."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` containing the pre-formatted block of message fragments."]
    #[doc = " \n - `offset` offset in the buffer at which the first fragment begins."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn offer_block(&self, buffer: &[u8]) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_offer_block(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the status of the media channel for this publication."]
    #[doc = " \n"]
    #[doc = " The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well."]
    #[doc = ""]
    #[doc = " \n# Return\n 1 for ACTIVE, -1 for ERRORED"]
    pub fn channel_status(&self) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_channel_status(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a publication."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `publication` to get the constants for."]
    #[doc = " \n - `constants` structure to fill in with the constants"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn constants(&self, constants: &AeronPublicationConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_exclusive_publication_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a publication."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronPublicationConstants, AeronCError> {
        let result = AeronPublicationConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Get the current position to which the publication has advanced for this stream."]
    #[doc = ""]
    #[doc = " \n# Return\n the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn position(&self) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_position(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the position limit beyond which this publication will be back pressured."]
    #[doc = ""]
    #[doc = " This should only be used as a guide to determine when back pressure is likely to be applied."]
    #[doc = ""]
    #[doc = " \n# Return\n the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn position_limit(&self) -> i64 {
        unsafe {
            let result = aeron_exclusive_publication_position_limit(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Asynchronously close the publication."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn close<AeronNotificationHandlerImpl: AeronNotificationCallback>(
        &self,
        on_close_complete: Option<&Handler<AeronNotificationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_exclusive_publication_close(
                self.get_inner(),
                {
                    let callback: aeron_notification_t = if on_close_complete.is_none() {
                        None
                    } else {
                        Some(aeron_notification_t_callback::<AeronNotificationHandlerImpl>)
                    };
                    callback
                },
                on_close_complete
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Asynchronously close the publication."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn close_once<AeronNotificationHandlerImpl: FnMut() -> ()>(
        &self,
        mut on_close_complete: AeronNotificationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_exclusive_publication_close(
                self.get_inner(),
                Some(
                    aeron_notification_t_callback_for_once_closure::<AeronNotificationHandlerImpl>,
                ),
                &mut on_close_complete as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Revoke this publication when it's closed."]
    #[doc = ""]
    pub fn revoke_on_close(&self) -> () {
        unsafe {
            let result = aeron_exclusive_publication_revoke_on_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Asynchronously revoke and close the publication. Will callback on the on_complete notification when the publicaiton is closed."]
    #[doc = " The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the publication has been revoked, closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn revoke<AeronNotificationHandlerImpl: AeronNotificationCallback>(
        &self,
        on_close_complete: Option<&Handler<AeronNotificationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_exclusive_publication_revoke(
                self.get_inner(),
                {
                    let callback: aeron_notification_t = if on_close_complete.is_none() {
                        None
                    } else {
                        Some(aeron_notification_t_callback::<AeronNotificationHandlerImpl>)
                    };
                    callback
                },
                on_close_complete
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Asynchronously revoke and close the publication. Will callback on the on_complete notification when the publicaiton is closed."]
    #[doc = " The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the publication has been revoked, closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn revoke_once<AeronNotificationHandlerImpl: FnMut() -> ()>(
        &self,
        mut on_close_complete: AeronNotificationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_exclusive_publication_revoke(
                self.get_inner(),
                Some(
                    aeron_notification_t_callback_for_once_closure::<AeronNotificationHandlerImpl>,
                ),
                &mut on_close_complete as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Has the exclusive publication closed?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if this publication is closed."]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_exclusive_publication_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Has the exclusive publication seen an active Subscriber recently?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if this publication has recently seen an active subscriber otherwise false."]
    pub fn is_connected(&self) -> bool {
        unsafe {
            let result = aeron_exclusive_publication_is_connected(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get all of the local socket addresses for this exclusive publication. Typically only one representing the control"]
    #[doc = " address."]
    #[doc = ""]
    #[doc = " @see aeron_subscription_local_`Sockaddr`s"]
    #[doc = "# Parameters\n \n - `address_vec` to hold the received addresses"]
    #[doc = " \n - `address_vec_len` available length of the vector to hold the addresses"]
    #[doc = " \n# Return\n number of addresses found or -1 if there is an error."]
    pub fn local_sockaddrs(
        &self,
        address_vec: &AeronIovec,
        address_vec_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_exclusive_publication_local_sockaddrs(
                self.get_inner(),
                address_vec.get_inner(),
                address_vec_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_exclusive_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_exclusive_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_exclusive_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronExclusivePublication {
    type Target = aeron_exclusive_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_exclusive_publication_t> for AeronExclusivePublication {
    #[inline]
    fn from(value: *mut aeron_exclusive_publication_t) -> Self {
        AeronExclusivePublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronExclusivePublication> for *mut aeron_exclusive_publication_t {
    #[inline]
    fn from(value: AeronExclusivePublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronExclusivePublication> for *mut aeron_exclusive_publication_t {
    #[inline]
    fn from(value: &AeronExclusivePublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronExclusivePublication> for aeron_exclusive_publication_t {
    #[inline]
    fn from(value: AeronExclusivePublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_exclusive_publication_t> for AeronExclusivePublication {
    #[inline]
    fn from(value: *const aeron_exclusive_publication_t) -> Self {
        AeronExclusivePublication {
            inner: CResource::Borrowed(value as *mut aeron_exclusive_publication_t),
        }
    }
}
impl From<aeron_exclusive_publication_t> for AeronExclusivePublication {
    #[inline]
    fn from(value: aeron_exclusive_publication_t) -> Self {
        AeronExclusivePublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronExclusivePublication {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronExclusivePublication));
                    let result = self.close_with_no_args();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronExclusivePublication));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronFeedbackDelayGeneratorState {
    inner: CResource<aeron_feedback_delay_generator_state_t>,
}
impl core::fmt::Debug for AeronFeedbackDelayGeneratorState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFeedbackDelayGeneratorState))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFeedbackDelayGeneratorState))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronFeedbackDelayGeneratorState {
    #[inline]
    pub fn new(
        static_delay: aeron_feedback_delay_generator_state_stct_static_delay_stct,
        optimal_delay: aeron_feedback_delay_generator_state_stct_optimal_delay_stct,
        delay_generator: aeron_feedback_delay_generator_func_t,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_feedback_delay_generator_state_t {
                    static_delay: static_delay.into(),
                    optimal_delay: optimal_delay.into(),
                    delay_generator: delay_generator.into(),
                };
                let inner_ptr: *mut aeron_feedback_delay_generator_state_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_feedback_delay_generator_state_t)
                );
                let inst: aeron_feedback_delay_generator_state_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_feedback_delay_generator_state_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_feedback_delay_generator_state_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn static_delay(&self) -> aeron_feedback_delay_generator_state_stct_static_delay_stct {
        self.static_delay.into()
    }
    #[inline]
    pub fn optimal_delay(&self) -> aeron_feedback_delay_generator_state_stct_optimal_delay_stct {
        self.optimal_delay.into()
    }
    #[inline]
    pub fn delay_generator(&self) -> aeron_feedback_delay_generator_func_t {
        self.delay_generator.into()
    }
    #[inline]
    pub fn aeron_feedback_delay_state_init(
        &self,
        delay_generator: aeron_feedback_delay_generator_func_t,
        delay_ns: i64,
        retry_ns: i64,
        multicast_group_size: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_feedback_delay_state_init(
                self.get_inner(),
                delay_generator.into(),
                delay_ns.into(),
                retry_ns.into(),
                multicast_group_size.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_loss_detector_nak_multicast_delay_generator(&self, retry: bool) -> i64 {
        unsafe {
            let result =
                aeron_loss_detector_nak_multicast_delay_generator(self.get_inner(), retry.into());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_feedback_delay_generator_state_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_feedback_delay_generator_state_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_feedback_delay_generator_state_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFeedbackDelayGeneratorState {
    type Target = aeron_feedback_delay_generator_state_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_feedback_delay_generator_state_t> for AeronFeedbackDelayGeneratorState {
    #[inline]
    fn from(value: *mut aeron_feedback_delay_generator_state_t) -> Self {
        AeronFeedbackDelayGeneratorState {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFeedbackDelayGeneratorState> for *mut aeron_feedback_delay_generator_state_t {
    #[inline]
    fn from(value: AeronFeedbackDelayGeneratorState) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFeedbackDelayGeneratorState> for *mut aeron_feedback_delay_generator_state_t {
    #[inline]
    fn from(value: &AeronFeedbackDelayGeneratorState) -> Self {
        value.get_inner()
    }
}
impl From<AeronFeedbackDelayGeneratorState> for aeron_feedback_delay_generator_state_t {
    #[inline]
    fn from(value: AeronFeedbackDelayGeneratorState) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_feedback_delay_generator_state_t> for AeronFeedbackDelayGeneratorState {
    #[inline]
    fn from(value: *const aeron_feedback_delay_generator_state_t) -> Self {
        AeronFeedbackDelayGeneratorState {
            inner: CResource::Borrowed(value as *mut aeron_feedback_delay_generator_state_t),
        }
    }
}
impl From<aeron_feedback_delay_generator_state_t> for AeronFeedbackDelayGeneratorState {
    #[inline]
    fn from(value: aeron_feedback_delay_generator_state_t) -> Self {
        AeronFeedbackDelayGeneratorState {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronFeedbackDelayGeneratorState {
    fn default() -> Self {
        AeronFeedbackDelayGeneratorState::new_zeroed_on_heap()
    }
}
impl AeronFeedbackDelayGeneratorState {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronFlowControlMaxOptions {
    inner: CResource<aeron_flow_control_max_options_t>,
}
impl core::fmt::Debug for AeronFlowControlMaxOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFlowControlMaxOptions))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFlowControlMaxOptions))
                .field("inner", &self.inner)
                .field(
                    stringify!(multicast_flow_control_rrwm),
                    &self.multicast_flow_control_rrwm(),
                )
                .finish()
        }
    }
}
impl AeronFlowControlMaxOptions {
    #[inline]
    pub fn new(multicast_flow_control_rrwm: usize) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_flow_control_max_options_t {
                    multicast_flow_control_rrwm: multicast_flow_control_rrwm.into(),
                };
                let inner_ptr: *mut aeron_flow_control_max_options_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_flow_control_max_options_t)
                );
                let inst: aeron_flow_control_max_options_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_flow_control_max_options_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_flow_control_max_options_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn multicast_flow_control_rrwm(&self) -> usize {
        self.multicast_flow_control_rrwm.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_flow_control_max_options_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_flow_control_max_options_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_flow_control_max_options_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFlowControlMaxOptions {
    type Target = aeron_flow_control_max_options_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_flow_control_max_options_t> for AeronFlowControlMaxOptions {
    #[inline]
    fn from(value: *mut aeron_flow_control_max_options_t) -> Self {
        AeronFlowControlMaxOptions {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFlowControlMaxOptions> for *mut aeron_flow_control_max_options_t {
    #[inline]
    fn from(value: AeronFlowControlMaxOptions) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFlowControlMaxOptions> for *mut aeron_flow_control_max_options_t {
    #[inline]
    fn from(value: &AeronFlowControlMaxOptions) -> Self {
        value.get_inner()
    }
}
impl From<AeronFlowControlMaxOptions> for aeron_flow_control_max_options_t {
    #[inline]
    fn from(value: AeronFlowControlMaxOptions) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_flow_control_max_options_t> for AeronFlowControlMaxOptions {
    #[inline]
    fn from(value: *const aeron_flow_control_max_options_t) -> Self {
        AeronFlowControlMaxOptions {
            inner: CResource::Borrowed(value as *mut aeron_flow_control_max_options_t),
        }
    }
}
impl From<aeron_flow_control_max_options_t> for AeronFlowControlMaxOptions {
    #[inline]
    fn from(value: aeron_flow_control_max_options_t) -> Self {
        AeronFlowControlMaxOptions {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronFlowControlMaxOptions {
    fn default() -> Self {
        AeronFlowControlMaxOptions::new_zeroed_on_heap()
    }
}
impl AeronFlowControlMaxOptions {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronFlowControlStrategySupplierFuncTableEntry {
    inner: CResource<aeron_flow_control_strategy_supplier_func_table_entry_t>,
}
impl core::fmt::Debug for AeronFlowControlStrategySupplierFuncTableEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFlowControlStrategySupplierFuncTableEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFlowControlStrategySupplierFuncTableEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronFlowControlStrategySupplierFuncTableEntry {
    #[inline]
    pub fn new(
        name: &std::ffi::CStr,
        supplier_func: aeron_flow_control_strategy_supplier_func_t,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_flow_control_strategy_supplier_func_table_entry_t {
                    name: name.as_ptr(),
                    supplier_func: supplier_func.into(),
                };
                let inner_ptr: *mut aeron_flow_control_strategy_supplier_func_table_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_flow_control_strategy_supplier_func_table_entry_t)
                );
                let inst: aeron_flow_control_strategy_supplier_func_table_entry_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_flow_control_strategy_supplier_func_table_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_flow_control_strategy_supplier_func_table_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn name(&self) -> &str {
        if self.name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.name).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn supplier_func(&self) -> aeron_flow_control_strategy_supplier_func_t {
        self.supplier_func.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_flow_control_strategy_supplier_func_table_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_flow_control_strategy_supplier_func_table_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_flow_control_strategy_supplier_func_table_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFlowControlStrategySupplierFuncTableEntry {
    type Target = aeron_flow_control_strategy_supplier_func_table_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_flow_control_strategy_supplier_func_table_entry_t>
    for AeronFlowControlStrategySupplierFuncTableEntry
{
    #[inline]
    fn from(value: *mut aeron_flow_control_strategy_supplier_func_table_entry_t) -> Self {
        AeronFlowControlStrategySupplierFuncTableEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFlowControlStrategySupplierFuncTableEntry>
    for *mut aeron_flow_control_strategy_supplier_func_table_entry_t
{
    #[inline]
    fn from(value: AeronFlowControlStrategySupplierFuncTableEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFlowControlStrategySupplierFuncTableEntry>
    for *mut aeron_flow_control_strategy_supplier_func_table_entry_t
{
    #[inline]
    fn from(value: &AeronFlowControlStrategySupplierFuncTableEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronFlowControlStrategySupplierFuncTableEntry>
    for aeron_flow_control_strategy_supplier_func_table_entry_t
{
    #[inline]
    fn from(value: AeronFlowControlStrategySupplierFuncTableEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_flow_control_strategy_supplier_func_table_entry_t>
    for AeronFlowControlStrategySupplierFuncTableEntry
{
    #[inline]
    fn from(value: *const aeron_flow_control_strategy_supplier_func_table_entry_t) -> Self {
        AeronFlowControlStrategySupplierFuncTableEntry {
            inner: CResource::Borrowed(
                value as *mut aeron_flow_control_strategy_supplier_func_table_entry_t,
            ),
        }
    }
}
impl From<aeron_flow_control_strategy_supplier_func_table_entry_t>
    for AeronFlowControlStrategySupplierFuncTableEntry
{
    #[inline]
    fn from(value: aeron_flow_control_strategy_supplier_func_table_entry_t) -> Self {
        AeronFlowControlStrategySupplierFuncTableEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronFlowControlStrategySupplierFuncTableEntry {
    fn default() -> Self {
        AeronFlowControlStrategySupplierFuncTableEntry::new_zeroed_on_heap()
    }
}
impl AeronFlowControlStrategySupplierFuncTableEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronFlowControlStrategy {
    inner: CResource<aeron_flow_control_strategy_t>,
}
impl core::fmt::Debug for AeronFlowControlStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFlowControlStrategy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFlowControlStrategy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronFlowControlStrategy {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_flow_control_strategy_t)
                );
                let inst: aeron_flow_control_strategy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_flow_control_strategy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_flow_control_strategy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn on_status_message(&self) -> aeron_flow_control_strategy_on_sm_func_t {
        self.on_status_message.into()
    }
    #[inline]
    pub fn on_idle(&self) -> aeron_flow_control_strategy_on_idle_func_t {
        self.on_idle.into()
    }
    #[inline]
    pub fn on_setup(&self) -> aeron_flow_control_strategy_on_setup_func_t {
        self.on_setup.into()
    }
    #[inline]
    pub fn on_error(&self) -> aeron_flow_control_strategy_on_error_func_t {
        self.on_error.into()
    }
    #[inline]
    pub fn fini(&self) -> aeron_flow_control_strategy_fini_func_t {
        self.fini.into()
    }
    #[inline]
    pub fn has_required_receivers(
        &self,
    ) -> aeron_flow_control_strategy_has_required_receivers_func_t {
        self.has_required_receivers.into()
    }
    #[inline]
    pub fn on_trigger_send_setup(
        &self,
    ) -> aeron_flow_control_strategy_on_trigger_send_setup_func_t {
        self.on_trigger_send_setup.into()
    }
    #[inline]
    pub fn max_retransmission_length(
        &self,
    ) -> aeron_flow_control_strategy_max_retransmission_length_func_t {
        self.max_retransmission_length.into()
    }
    #[inline]
    pub fn state(&self) -> *mut ::std::os::raw::c_void {
        self.state.into()
    }
    #[inline]
    #[doc = "Return a flow control strategy supplier function pointer associated with the given name. This only will find"]
    #[doc = " strategies built into the driver and will not try to dynamically load nor find any in the current executable."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `name` of the strategy"]
    #[doc = " \n# Return\n function pointer to supplier associated with the name"]
    pub fn supplier_by_name(name: &std::ffi::CStr) -> aeron_flow_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_flow_control_strategy_supplier_by_name(name.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn has_required_receivers_default(&self) -> bool {
        unsafe {
            let result =
                aeron_flow_control_strategy_has_required_receivers_default(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn supplier_load(
        strategy_name: &std::ffi::CStr,
    ) -> aeron_flow_control_strategy_supplier_func_t {
        unsafe {
            let result = aeron_flow_control_strategy_supplier_load(strategy_name.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_tagged_flow_control_strategy_to_string(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_tagged_flow_control_strategy_to_string(
                self.get_inner(),
                buffer.into(),
                buffer_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_tagged_flow_control_strategy_to_string_as_string(
        &self,
        max_length: usize,
    ) -> Result<String, AeronCError> {
        let mut result = String::with_capacity(max_length);
        self.aeron_tagged_flow_control_strategy_to_string_into(&mut result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "NOTE: allocation friendly method, the string capacity must be set as it will truncate string to capacity it will never grow the string. So if you pass String::new() it will write 0 chars"]
    pub fn aeron_tagged_flow_control_strategy_to_string_into(
        &self,
        dst_truncate_to_capacity: &mut String,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let capacity = dst_truncate_to_capacity.capacity();
            let vec = dst_truncate_to_capacity.as_mut_vec();
            vec.set_len(capacity);
            let result = self.aeron_tagged_flow_control_strategy_to_string(
                vec.as_mut_ptr() as *mut _,
                capacity,
            )?;
            let mut len = 0;
            loop {
                if len == capacity {
                    break;
                }
                let val = vec[len];
                if val == 0 {
                    break;
                }
                len += 1;
            }
            vec.set_len(len);
            Ok(result)
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_flow_control_strategy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_flow_control_strategy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_flow_control_strategy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFlowControlStrategy {
    type Target = aeron_flow_control_strategy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_flow_control_strategy_t> for AeronFlowControlStrategy {
    #[inline]
    fn from(value: *mut aeron_flow_control_strategy_t) -> Self {
        AeronFlowControlStrategy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFlowControlStrategy> for *mut aeron_flow_control_strategy_t {
    #[inline]
    fn from(value: AeronFlowControlStrategy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFlowControlStrategy> for *mut aeron_flow_control_strategy_t {
    #[inline]
    fn from(value: &AeronFlowControlStrategy) -> Self {
        value.get_inner()
    }
}
impl From<AeronFlowControlStrategy> for aeron_flow_control_strategy_t {
    #[inline]
    fn from(value: AeronFlowControlStrategy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_flow_control_strategy_t> for AeronFlowControlStrategy {
    #[inline]
    fn from(value: *const aeron_flow_control_strategy_t) -> Self {
        AeronFlowControlStrategy {
            inner: CResource::Borrowed(value as *mut aeron_flow_control_strategy_t),
        }
    }
}
impl From<aeron_flow_control_strategy_t> for AeronFlowControlStrategy {
    #[inline]
    fn from(value: aeron_flow_control_strategy_t) -> Self {
        AeronFlowControlStrategy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronFlowControlTaggedOptions {
    inner: CResource<aeron_flow_control_tagged_options_t>,
}
impl core::fmt::Debug for AeronFlowControlTaggedOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFlowControlTaggedOptions))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFlowControlTaggedOptions))
                .field("inner", &self.inner)
                .field(
                    stringify!(strategy_name_length),
                    &self.strategy_name_length(),
                )
                .field(
                    stringify!(multicast_flow_control_rrwm),
                    &self.multicast_flow_control_rrwm(),
                )
                .finish()
        }
    }
}
impl AeronFlowControlTaggedOptions {
    #[inline]
    pub fn new(
        strategy_name_length: usize,
        strategy_name: &std::ffi::CStr,
        group_tag: aeron_flow_control_tagged_options_stct__bindgen_ty_1,
        timeout_ns: aeron_flow_control_tagged_options_stct__bindgen_ty_2,
        group_min_size: aeron_flow_control_tagged_options_stct__bindgen_ty_3,
        multicast_flow_control_rrwm: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_flow_control_tagged_options_t {
                    strategy_name_length: strategy_name_length.into(),
                    strategy_name: strategy_name.as_ptr(),
                    group_tag: group_tag.into(),
                    timeout_ns: timeout_ns.into(),
                    group_min_size: group_min_size.into(),
                    multicast_flow_control_rrwm: multicast_flow_control_rrwm.into(),
                };
                let inner_ptr: *mut aeron_flow_control_tagged_options_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_flow_control_tagged_options_t)
                );
                let inst: aeron_flow_control_tagged_options_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_flow_control_tagged_options_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_flow_control_tagged_options_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn strategy_name_length(&self) -> usize {
        self.strategy_name_length.into()
    }
    #[inline]
    pub fn strategy_name(&self) -> &str {
        if self.strategy_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.strategy_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn group_tag(&self) -> aeron_flow_control_tagged_options_stct__bindgen_ty_1 {
        self.group_tag.into()
    }
    #[inline]
    pub fn timeout_ns(&self) -> aeron_flow_control_tagged_options_stct__bindgen_ty_2 {
        self.timeout_ns.into()
    }
    #[inline]
    pub fn group_min_size(&self) -> aeron_flow_control_tagged_options_stct__bindgen_ty_3 {
        self.group_min_size.into()
    }
    #[inline]
    pub fn multicast_flow_control_rrwm(&self) -> usize {
        self.multicast_flow_control_rrwm.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_flow_control_tagged_options_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_flow_control_tagged_options_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_flow_control_tagged_options_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFlowControlTaggedOptions {
    type Target = aeron_flow_control_tagged_options_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_flow_control_tagged_options_t> for AeronFlowControlTaggedOptions {
    #[inline]
    fn from(value: *mut aeron_flow_control_tagged_options_t) -> Self {
        AeronFlowControlTaggedOptions {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFlowControlTaggedOptions> for *mut aeron_flow_control_tagged_options_t {
    #[inline]
    fn from(value: AeronFlowControlTaggedOptions) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFlowControlTaggedOptions> for *mut aeron_flow_control_tagged_options_t {
    #[inline]
    fn from(value: &AeronFlowControlTaggedOptions) -> Self {
        value.get_inner()
    }
}
impl From<AeronFlowControlTaggedOptions> for aeron_flow_control_tagged_options_t {
    #[inline]
    fn from(value: AeronFlowControlTaggedOptions) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_flow_control_tagged_options_t> for AeronFlowControlTaggedOptions {
    #[inline]
    fn from(value: *const aeron_flow_control_tagged_options_t) -> Self {
        AeronFlowControlTaggedOptions {
            inner: CResource::Borrowed(value as *mut aeron_flow_control_tagged_options_t),
        }
    }
}
impl From<aeron_flow_control_tagged_options_t> for AeronFlowControlTaggedOptions {
    #[inline]
    fn from(value: aeron_flow_control_tagged_options_t) -> Self {
        AeronFlowControlTaggedOptions {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronFlowControlTaggedOptions {
    fn default() -> Self {
        AeronFlowControlTaggedOptions::new_zeroed_on_heap()
    }
}
impl AeronFlowControlTaggedOptions {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronFragmentAssembler {
    inner: CResource<aeron_fragment_assembler_t>,
}
impl core::fmt::Debug for AeronFragmentAssembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFragmentAssembler))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFragmentAssembler))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronFragmentAssembler {
    #[doc = "Create a fragment assembler for use with a subscription."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `delegate` to call on completed"]
    #[doc = " \n - `delegate_clientd` to pass to delegate handler."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new<AeronFragmentHandlerHandlerImpl: AeronFragmentHandlerCallback>(
        delegate: Option<&Handler<AeronFragmentHandlerHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let (delegate, delegate_clientd) = (
            {
                let callback: aeron_fragment_handler_t = if delegate.is_none() {
                    None
                } else {
                    Some(aeron_fragment_handler_t_callback::<AeronFragmentHandlerHandlerImpl>)
                };
                callback
            },
            delegate
                .map(|m| m.as_raw())
                .unwrap_or_else(|| std::ptr::null_mut()),
        );
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_fragment_assembler_create(ctx_field, delegate, delegate_clientd)
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_fragment_assembler_delete(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    #[doc = "Delete a fragment assembler."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_fragment_assembler_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Handler function to be passed for handling fragment assembly."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `clientd` passed in the poll call (must be a `AeronFragmentAssembler`)"]
    #[doc = " \n - `buffer` containing the data."]
    #[doc = " \n - `header` representing the meta data for the data."]
    pub fn handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: &[u8],
        header: &AeronHeader,
    ) -> () {
        unsafe {
            let result = aeron_fragment_assembler_handler(
                clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                header.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_fragment_assembler_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_fragment_assembler_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_fragment_assembler_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFragmentAssembler {
    type Target = aeron_fragment_assembler_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_fragment_assembler_t> for AeronFragmentAssembler {
    #[inline]
    fn from(value: *mut aeron_fragment_assembler_t) -> Self {
        AeronFragmentAssembler {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFragmentAssembler> for *mut aeron_fragment_assembler_t {
    #[inline]
    fn from(value: AeronFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFragmentAssembler> for *mut aeron_fragment_assembler_t {
    #[inline]
    fn from(value: &AeronFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<AeronFragmentAssembler> for aeron_fragment_assembler_t {
    #[inline]
    fn from(value: AeronFragmentAssembler) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_fragment_assembler_t> for AeronFragmentAssembler {
    #[inline]
    fn from(value: *const aeron_fragment_assembler_t) -> Self {
        AeronFragmentAssembler {
            inner: CResource::Borrowed(value as *mut aeron_fragment_assembler_t),
        }
    }
}
impl From<aeron_fragment_assembler_t> for AeronFragmentAssembler {
    #[inline]
    fn from(value: aeron_fragment_assembler_t) -> Self {
        AeronFragmentAssembler {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronFrameHeader {
    inner: CResource<aeron_frame_header_t>,
}
impl core::fmt::Debug for AeronFrameHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronFrameHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronFrameHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_length), &self.frame_length())
                .field(stringify!(type_), &self.type_())
                .finish()
        }
    }
}
impl AeronFrameHeader {
    #[inline]
    pub fn new(frame_length: i32, version: i8, flags: u8, type_: i16) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_frame_header_t {
                    frame_length: frame_length.into(),
                    version: version.into(),
                    flags: flags.into(),
                    type_: type_.into(),
                };
                let inner_ptr: *mut aeron_frame_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_frame_header_t)
                );
                let inst: aeron_frame_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_frame_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_frame_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_length(&self) -> i32 {
        self.frame_length.into()
    }
    #[inline]
    pub fn version(&self) -> i8 {
        self.version.into()
    }
    #[inline]
    pub fn flags(&self) -> u8 {
        self.flags.into()
    }
    #[inline]
    pub fn type_(&self) -> i16 {
        self.type_.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_frame_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_frame_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_frame_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronFrameHeader {
    type Target = aeron_frame_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_frame_header_t> for AeronFrameHeader {
    #[inline]
    fn from(value: *mut aeron_frame_header_t) -> Self {
        AeronFrameHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronFrameHeader> for *mut aeron_frame_header_t {
    #[inline]
    fn from(value: AeronFrameHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronFrameHeader> for *mut aeron_frame_header_t {
    #[inline]
    fn from(value: &AeronFrameHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronFrameHeader> for aeron_frame_header_t {
    #[inline]
    fn from(value: AeronFrameHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_frame_header_t> for AeronFrameHeader {
    #[inline]
    fn from(value: *const aeron_frame_header_t) -> Self {
        AeronFrameHeader {
            inner: CResource::Borrowed(value as *mut aeron_frame_header_t),
        }
    }
}
impl From<aeron_frame_header_t> for AeronFrameHeader {
    #[inline]
    fn from(value: aeron_frame_header_t) -> Self {
        AeronFrameHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronFrameHeader {
    fn default() -> Self {
        AeronFrameHeader::new_zeroed_on_heap()
    }
}
impl AeronFrameHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronHeader {
    inner: CResource<aeron_header_t>,
}
impl core::fmt::Debug for AeronHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronHeader))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronHeader {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_header_t)
                );
                let inst: aeron_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Get all of the field values from the header. This will do a memcpy into the supplied header_values_t pointer."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `header` to read values from."]
    #[doc = " \n - `values` to copy values to, must not be null."]
    #[doc = " \n# Return\n 0 on success, -1 on failure."]
    pub fn values(&self, values: &AeronHeaderValues) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_header_values(self.get_inner(), values.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Get all of the field values from the header. This will do a memcpy into the supplied header_values_t pointer."]
    #[doc = ""]
    pub fn get_values(&self) -> Result<AeronHeaderValues, AeronCError> {
        let result = AeronHeaderValues::new_zeroed_on_stack();
        self.values(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Get the current position to which the Image has advanced on reading this message."]
    #[doc = ""]
    #[doc = " \n# Return\n the current position to which the Image has advanced on reading this message."]
    pub fn position(&self) -> i64 {
        unsafe {
            let result = aeron_header_position(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the number of times to left shift the term count to multiply by term length."]
    #[doc = ""]
    #[doc = " \n# Return\n number of times to left shift the term count to multiply by term length."]
    pub fn position_bits_to_shift(&self) -> usize {
        unsafe {
            let result = aeron_header_position_bits_to_shift(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Calculates the offset of the frame immediately after this one."]
    #[doc = ""]
    #[doc = " \n# Return\n the offset of the next frame."]
    pub fn next_term_offset(&self) -> i32 {
        unsafe {
            let result = aeron_header_next_term_offset(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get a pointer to the context associated with this message. Only valid during poll handling. Is normally a"]
    #[doc = " pointer to an Image instance."]
    #[doc = ""]
    #[doc = " \n# Return\n a pointer to the context associated with this message."]
    pub fn context(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_header_context(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronHeader {
    type Target = aeron_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_header_t> for AeronHeader {
    #[inline]
    fn from(value: *mut aeron_header_t) -> Self {
        AeronHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronHeader> for *mut aeron_header_t {
    #[inline]
    fn from(value: AeronHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronHeader> for *mut aeron_header_t {
    #[inline]
    fn from(value: &AeronHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronHeader> for aeron_header_t {
    #[inline]
    fn from(value: AeronHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_header_t> for AeronHeader {
    #[inline]
    fn from(value: *const aeron_header_t) -> Self {
        AeronHeader {
            inner: CResource::Borrowed(value as *mut aeron_header_t),
        }
    }
}
impl From<aeron_header_t> for AeronHeader {
    #[inline]
    fn from(value: aeron_header_t) -> Self {
        AeronHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronHeaderValuesFrame {
    inner: CResource<aeron_header_values_frame_t>,
}
impl core::fmt::Debug for AeronHeaderValuesFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronHeaderValuesFrame))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronHeaderValuesFrame))
                .field("inner", &self.inner)
                .field(stringify!(frame_length), &self.frame_length())
                .field(stringify!(type_), &self.type_())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(reserved_value), &self.reserved_value())
                .finish()
        }
    }
}
impl AeronHeaderValuesFrame {
    #[inline]
    pub fn new(
        frame_length: i32,
        version: i8,
        flags: u8,
        type_: i16,
        term_offset: i32,
        session_id: i32,
        stream_id: i32,
        term_id: i32,
        reserved_value: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_header_values_frame_t {
                    frame_length: frame_length.into(),
                    version: version.into(),
                    flags: flags.into(),
                    type_: type_.into(),
                    term_offset: term_offset.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    term_id: term_id.into(),
                    reserved_value: reserved_value.into(),
                };
                let inner_ptr: *mut aeron_header_values_frame_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_header_values_frame_t)
                );
                let inst: aeron_header_values_frame_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_header_values_frame_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_header_values_frame_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_length(&self) -> i32 {
        self.frame_length.into()
    }
    #[inline]
    pub fn version(&self) -> i8 {
        self.version.into()
    }
    #[inline]
    pub fn flags(&self) -> u8 {
        self.flags.into()
    }
    #[inline]
    pub fn type_(&self) -> i16 {
        self.type_.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn reserved_value(&self) -> i64 {
        self.reserved_value.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_header_values_frame_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_header_values_frame_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_header_values_frame_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronHeaderValuesFrame {
    type Target = aeron_header_values_frame_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_header_values_frame_t> for AeronHeaderValuesFrame {
    #[inline]
    fn from(value: *mut aeron_header_values_frame_t) -> Self {
        AeronHeaderValuesFrame {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronHeaderValuesFrame> for *mut aeron_header_values_frame_t {
    #[inline]
    fn from(value: AeronHeaderValuesFrame) -> Self {
        value.get_inner()
    }
}
impl From<&AeronHeaderValuesFrame> for *mut aeron_header_values_frame_t {
    #[inline]
    fn from(value: &AeronHeaderValuesFrame) -> Self {
        value.get_inner()
    }
}
impl From<AeronHeaderValuesFrame> for aeron_header_values_frame_t {
    #[inline]
    fn from(value: AeronHeaderValuesFrame) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_header_values_frame_t> for AeronHeaderValuesFrame {
    #[inline]
    fn from(value: *const aeron_header_values_frame_t) -> Self {
        AeronHeaderValuesFrame {
            inner: CResource::Borrowed(value as *mut aeron_header_values_frame_t),
        }
    }
}
impl From<aeron_header_values_frame_t> for AeronHeaderValuesFrame {
    #[inline]
    fn from(value: aeron_header_values_frame_t) -> Self {
        AeronHeaderValuesFrame {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronHeaderValuesFrame {
    fn default() -> Self {
        AeronHeaderValuesFrame::new_zeroed_on_heap()
    }
}
impl AeronHeaderValuesFrame {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronHeaderValues {
    inner: CResource<aeron_header_values_t>,
}
impl core::fmt::Debug for AeronHeaderValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronHeaderValues))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronHeaderValues))
                .field("inner", &self.inner)
                .field(stringify!(frame), &self.frame())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .finish()
        }
    }
}
impl AeronHeaderValues {
    #[inline]
    pub fn new(
        frame: AeronHeaderValuesFrame,
        initial_term_id: i32,
        position_bits_to_shift: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_header_values_t {
                    frame: frame.into(),
                    initial_term_id: initial_term_id.into(),
                    position_bits_to_shift: position_bits_to_shift.into(),
                };
                let inner_ptr: *mut aeron_header_values_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_header_values_t)
                );
                let inst: aeron_header_values_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_header_values_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_header_values_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame(&self) -> AeronHeaderValuesFrame {
        self.frame.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_header_values_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_header_values_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_header_values_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronHeaderValues {
    type Target = aeron_header_values_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_header_values_t> for AeronHeaderValues {
    #[inline]
    fn from(value: *mut aeron_header_values_t) -> Self {
        AeronHeaderValues {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronHeaderValues> for *mut aeron_header_values_t {
    #[inline]
    fn from(value: AeronHeaderValues) -> Self {
        value.get_inner()
    }
}
impl From<&AeronHeaderValues> for *mut aeron_header_values_t {
    #[inline]
    fn from(value: &AeronHeaderValues) -> Self {
        value.get_inner()
    }
}
impl From<AeronHeaderValues> for aeron_header_values_t {
    #[inline]
    fn from(value: AeronHeaderValues) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_header_values_t> for AeronHeaderValues {
    #[inline]
    fn from(value: *const aeron_header_values_t) -> Self {
        AeronHeaderValues {
            inner: CResource::Borrowed(value as *mut aeron_header_values_t),
        }
    }
}
impl From<aeron_header_values_t> for AeronHeaderValues {
    #[inline]
    fn from(value: aeron_header_values_t) -> Self {
        AeronHeaderValues {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronHeaderValues {
    fn default() -> Self {
        AeronHeaderValues::new_zeroed_on_heap()
    }
}
impl AeronHeaderValues {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronHeartbeatTimestampKeyLayout {
    inner: CResource<aeron_heartbeat_timestamp_key_layout_t>,
}
impl core::fmt::Debug for AeronHeartbeatTimestampKeyLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronHeartbeatTimestampKeyLayout))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronHeartbeatTimestampKeyLayout))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .finish()
        }
    }
}
impl AeronHeartbeatTimestampKeyLayout {
    #[inline]
    pub fn new(registration_id: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_heartbeat_timestamp_key_layout_t {
                    registration_id: registration_id.into(),
                };
                let inner_ptr: *mut aeron_heartbeat_timestamp_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_heartbeat_timestamp_key_layout_t)
                );
                let inst: aeron_heartbeat_timestamp_key_layout_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_heartbeat_timestamp_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_heartbeat_timestamp_key_layout_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_heartbeat_timestamp_key_layout_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_heartbeat_timestamp_key_layout_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_heartbeat_timestamp_key_layout_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronHeartbeatTimestampKeyLayout {
    type Target = aeron_heartbeat_timestamp_key_layout_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_heartbeat_timestamp_key_layout_t> for AeronHeartbeatTimestampKeyLayout {
    #[inline]
    fn from(value: *mut aeron_heartbeat_timestamp_key_layout_t) -> Self {
        AeronHeartbeatTimestampKeyLayout {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronHeartbeatTimestampKeyLayout> for *mut aeron_heartbeat_timestamp_key_layout_t {
    #[inline]
    fn from(value: AeronHeartbeatTimestampKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<&AeronHeartbeatTimestampKeyLayout> for *mut aeron_heartbeat_timestamp_key_layout_t {
    #[inline]
    fn from(value: &AeronHeartbeatTimestampKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<AeronHeartbeatTimestampKeyLayout> for aeron_heartbeat_timestamp_key_layout_t {
    #[inline]
    fn from(value: AeronHeartbeatTimestampKeyLayout) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_heartbeat_timestamp_key_layout_t> for AeronHeartbeatTimestampKeyLayout {
    #[inline]
    fn from(value: *const aeron_heartbeat_timestamp_key_layout_t) -> Self {
        AeronHeartbeatTimestampKeyLayout {
            inner: CResource::Borrowed(value as *mut aeron_heartbeat_timestamp_key_layout_t),
        }
    }
}
impl From<aeron_heartbeat_timestamp_key_layout_t> for AeronHeartbeatTimestampKeyLayout {
    #[inline]
    fn from(value: aeron_heartbeat_timestamp_key_layout_t) -> Self {
        AeronHeartbeatTimestampKeyLayout {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronHeartbeatTimestampKeyLayout {
    fn default() -> Self {
        AeronHeartbeatTimestampKeyLayout::new_zeroed_on_heap()
    }
}
impl AeronHeartbeatTimestampKeyLayout {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronIdleStrategy {
    inner: CResource<aeron_idle_strategy_t>,
}
impl core::fmt::Debug for AeronIdleStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronIdleStrategy))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronIdleStrategy))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronIdleStrategy {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_idle_strategy_t)
                );
                let inst: aeron_idle_strategy_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_idle_strategy_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_idle_strategy_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn idle(&self) -> aeron_idle_strategy_func_t {
        self.idle.into()
    }
    #[inline]
    pub fn init(&self) -> aeron_idle_strategy_init_func_t {
        self.init.into()
    }
    #[inline]
    pub fn sleeping_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    ) -> () {
        unsafe {
            let result = aeron_idle_strategy_sleeping_idle(state.into(), work_count.into());
            result.into()
        }
    }
    #[inline]
    pub fn yielding_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    ) -> () {
        unsafe {
            let result = aeron_idle_strategy_yielding_idle(state.into(), work_count.into());
            result.into()
        }
    }
    #[inline]
    pub fn busy_spinning_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    ) -> () {
        unsafe {
            let result = aeron_idle_strategy_busy_spinning_idle(state.into(), work_count.into());
            result.into()
        }
    }
    #[inline]
    pub fn noop_idle(state: *mut ::std::os::raw::c_void, work_count: ::std::os::raw::c_int) -> () {
        unsafe {
            let result = aeron_idle_strategy_noop_idle(state.into(), work_count.into());
            result.into()
        }
    }
    #[inline]
    pub fn backoff_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    ) -> () {
        unsafe {
            let result = aeron_idle_strategy_backoff_idle(state.into(), work_count.into());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_idle_strategy_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_idle_strategy_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_idle_strategy_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronIdleStrategy {
    type Target = aeron_idle_strategy_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_idle_strategy_t> for AeronIdleStrategy {
    #[inline]
    fn from(value: *mut aeron_idle_strategy_t) -> Self {
        AeronIdleStrategy {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronIdleStrategy> for *mut aeron_idle_strategy_t {
    #[inline]
    fn from(value: AeronIdleStrategy) -> Self {
        value.get_inner()
    }
}
impl From<&AeronIdleStrategy> for *mut aeron_idle_strategy_t {
    #[inline]
    fn from(value: &AeronIdleStrategy) -> Self {
        value.get_inner()
    }
}
impl From<AeronIdleStrategy> for aeron_idle_strategy_t {
    #[inline]
    fn from(value: AeronIdleStrategy) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_idle_strategy_t> for AeronIdleStrategy {
    #[inline]
    fn from(value: *const aeron_idle_strategy_t) -> Self {
        AeronIdleStrategy {
            inner: CResource::Borrowed(value as *mut aeron_idle_strategy_t),
        }
    }
}
impl From<aeron_idle_strategy_t> for AeronIdleStrategy {
    #[inline]
    fn from(value: aeron_idle_strategy_t) -> Self {
        AeronIdleStrategy {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronImageBuffersReady {
    inner: CResource<aeron_image_buffers_ready_t>,
}
impl core::fmt::Debug for AeronImageBuffersReady {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImageBuffersReady))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImageBuffersReady))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(
                    stringify!(subscriber_registration_id),
                    &self.subscriber_registration_id(),
                )
                .field(
                    stringify!(subscriber_position_id),
                    &self.subscriber_position_id(),
                )
                .finish()
        }
    }
}
impl AeronImageBuffersReady {
    #[inline]
    pub fn new(
        correlation_id: i64,
        session_id: i32,
        stream_id: i32,
        subscriber_registration_id: i64,
        subscriber_position_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_image_buffers_ready_t {
                    correlation_id: correlation_id.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    subscriber_registration_id: subscriber_registration_id.into(),
                    subscriber_position_id: subscriber_position_id.into(),
                };
                let inner_ptr: *mut aeron_image_buffers_ready_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_image_buffers_ready_t)
                );
                let inst: aeron_image_buffers_ready_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_image_buffers_ready_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_image_buffers_ready_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn subscriber_registration_id(&self) -> i64 {
        self.subscriber_registration_id.into()
    }
    #[inline]
    pub fn subscriber_position_id(&self) -> i32 {
        self.subscriber_position_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_buffers_ready_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_buffers_ready_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_buffers_ready_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImageBuffersReady {
    type Target = aeron_image_buffers_ready_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_buffers_ready_t> for AeronImageBuffersReady {
    #[inline]
    fn from(value: *mut aeron_image_buffers_ready_t) -> Self {
        AeronImageBuffersReady {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImageBuffersReady> for *mut aeron_image_buffers_ready_t {
    #[inline]
    fn from(value: AeronImageBuffersReady) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImageBuffersReady> for *mut aeron_image_buffers_ready_t {
    #[inline]
    fn from(value: &AeronImageBuffersReady) -> Self {
        value.get_inner()
    }
}
impl From<AeronImageBuffersReady> for aeron_image_buffers_ready_t {
    #[inline]
    fn from(value: AeronImageBuffersReady) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_buffers_ready_t> for AeronImageBuffersReady {
    #[inline]
    fn from(value: *const aeron_image_buffers_ready_t) -> Self {
        AeronImageBuffersReady {
            inner: CResource::Borrowed(value as *mut aeron_image_buffers_ready_t),
        }
    }
}
impl From<aeron_image_buffers_ready_t> for AeronImageBuffersReady {
    #[inline]
    fn from(value: aeron_image_buffers_ready_t) -> Self {
        AeronImageBuffersReady {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronImageBuffersReady {
    fn default() -> Self {
        AeronImageBuffersReady::new_zeroed_on_heap()
    }
}
impl AeronImageBuffersReady {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[doc = "Configuration for an image that does not change during it's lifetime."]
#[derive(Clone)]
pub struct AeronImageConstants {
    inner: CResource<aeron_image_constants_t>,
}
impl core::fmt::Debug for AeronImageConstants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImageConstants))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImageConstants))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(join_position), &self.join_position())
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .field(stringify!(term_buffer_length), &self.term_buffer_length())
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(
                    stringify!(subscriber_position_id),
                    &self.subscriber_position_id(),
                )
                .finish()
        }
    }
}
impl AeronImageConstants {
    #[inline]
    pub fn new(
        subscription: &AeronSubscription,
        source_identity: &std::ffi::CStr,
        correlation_id: i64,
        join_position: i64,
        position_bits_to_shift: usize,
        term_buffer_length: usize,
        mtu_length: usize,
        session_id: i32,
        initial_term_id: i32,
        subscriber_position_id: i32,
    ) -> Result<Self, AeronCError> {
        let subscription_copy = subscription.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_image_constants_t {
                    subscription: subscription.into(),
                    source_identity: source_identity.as_ptr(),
                    correlation_id: correlation_id.into(),
                    join_position: join_position.into(),
                    position_bits_to_shift: position_bits_to_shift.into(),
                    term_buffer_length: term_buffer_length.into(),
                    mtu_length: mtu_length.into(),
                    session_id: session_id.into(),
                    initial_term_id: initial_term_id.into(),
                    subscriber_position_id: subscriber_position_id.into(),
                };
                let inner_ptr: *mut aeron_image_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_image_constants_t)
                );
                let inst: aeron_image_constants_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_image_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_image_constants_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn subscription(&self) -> AeronSubscription {
        self.subscription.into()
    }
    #[inline]
    pub fn source_identity(&self) -> &str {
        if self.source_identity.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.source_identity)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn join_position(&self) -> i64 {
        self.join_position.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline]
    pub fn term_buffer_length(&self) -> usize {
        self.term_buffer_length.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> usize {
        self.mtu_length.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn subscriber_position_id(&self) -> i32 {
        self.subscriber_position_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_constants_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_constants_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_constants_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImageConstants {
    type Target = aeron_image_constants_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_constants_t> for AeronImageConstants {
    #[inline]
    fn from(value: *mut aeron_image_constants_t) -> Self {
        AeronImageConstants {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImageConstants> for *mut aeron_image_constants_t {
    #[inline]
    fn from(value: AeronImageConstants) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImageConstants> for *mut aeron_image_constants_t {
    #[inline]
    fn from(value: &AeronImageConstants) -> Self {
        value.get_inner()
    }
}
impl From<AeronImageConstants> for aeron_image_constants_t {
    #[inline]
    fn from(value: AeronImageConstants) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_constants_t> for AeronImageConstants {
    #[inline]
    fn from(value: *const aeron_image_constants_t) -> Self {
        AeronImageConstants {
            inner: CResource::Borrowed(value as *mut aeron_image_constants_t),
        }
    }
}
impl From<aeron_image_constants_t> for AeronImageConstants {
    #[inline]
    fn from(value: aeron_image_constants_t) -> Self {
        AeronImageConstants {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronImageConstants {
    fn default() -> Self {
        AeronImageConstants::new_zeroed_on_heap()
    }
}
impl AeronImageConstants {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronImageControlledFragmentAssembler {
    inner: CResource<aeron_image_controlled_fragment_assembler_t>,
}
impl core::fmt::Debug for AeronImageControlledFragmentAssembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImageControlledFragmentAssembler))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImageControlledFragmentAssembler))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronImageControlledFragmentAssembler {
    #[doc = "Create an image controlled fragment assembler for use with a single image."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `delegate` to call on completed"]
    #[doc = " \n - `delegate_clientd` to pass to delegate handler."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        delegate: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let (delegate, delegate_clientd) = (
            {
                let callback: aeron_controlled_fragment_handler_t = if delegate.is_none() {
                    None
                } else {
                    Some(
                        aeron_controlled_fragment_handler_t_callback::<
                            AeronControlledFragmentHandlerHandlerImpl,
                        >,
                    )
                };
                callback
            },
            delegate
                .map(|m| m.as_raw())
                .unwrap_or_else(|| std::ptr::null_mut()),
        );
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_image_controlled_fragment_assembler_create(
                    ctx_field,
                    delegate,
                    delegate_clientd,
                )
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_image_controlled_fragment_assembler_delete(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    #[doc = "Delete an image controlled fragment assembler."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_controlled_fragment_assembler_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Handler function to be passed for handling fragment assembly."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `clientd` passed in the poll call (must be a `AeronImageControlledFragmentAssembler`)"]
    #[doc = " \n - `buffer` containing the data."]
    #[doc = " \n - `header` representing the meta data for the data."]
    #[doc = " \n# Return\n The action to be taken with regard to the stream position after the callback."]
    pub fn handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: &[u8],
        header: &AeronHeader,
    ) -> aeron_controlled_fragment_handler_action_t {
        unsafe {
            let result = aeron_image_controlled_fragment_assembler_handler(
                clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                header.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_controlled_fragment_assembler_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_controlled_fragment_assembler_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_controlled_fragment_assembler_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImageControlledFragmentAssembler {
    type Target = aeron_image_controlled_fragment_assembler_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_controlled_fragment_assembler_t>
    for AeronImageControlledFragmentAssembler
{
    #[inline]
    fn from(value: *mut aeron_image_controlled_fragment_assembler_t) -> Self {
        AeronImageControlledFragmentAssembler {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImageControlledFragmentAssembler>
    for *mut aeron_image_controlled_fragment_assembler_t
{
    #[inline]
    fn from(value: AeronImageControlledFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImageControlledFragmentAssembler>
    for *mut aeron_image_controlled_fragment_assembler_t
{
    #[inline]
    fn from(value: &AeronImageControlledFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<AeronImageControlledFragmentAssembler> for aeron_image_controlled_fragment_assembler_t {
    #[inline]
    fn from(value: AeronImageControlledFragmentAssembler) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_controlled_fragment_assembler_t>
    for AeronImageControlledFragmentAssembler
{
    #[inline]
    fn from(value: *const aeron_image_controlled_fragment_assembler_t) -> Self {
        AeronImageControlledFragmentAssembler {
            inner: CResource::Borrowed(value as *mut aeron_image_controlled_fragment_assembler_t),
        }
    }
}
impl From<aeron_image_controlled_fragment_assembler_t> for AeronImageControlledFragmentAssembler {
    #[inline]
    fn from(value: aeron_image_controlled_fragment_assembler_t) -> Self {
        AeronImageControlledFragmentAssembler {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronImageFragmentAssembler {
    inner: CResource<aeron_image_fragment_assembler_t>,
}
impl core::fmt::Debug for AeronImageFragmentAssembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImageFragmentAssembler))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImageFragmentAssembler))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronImageFragmentAssembler {
    #[doc = "Create an image fragment assembler for use with a single image."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `delegate` to call on completed."]
    #[doc = " \n - `delegate_clientd` to pass to delegate handler."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new<AeronFragmentHandlerHandlerImpl: AeronFragmentHandlerCallback>(
        delegate: Option<&Handler<AeronFragmentHandlerHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let (delegate, delegate_clientd) = (
            {
                let callback: aeron_fragment_handler_t = if delegate.is_none() {
                    None
                } else {
                    Some(aeron_fragment_handler_t_callback::<AeronFragmentHandlerHandlerImpl>)
                };
                callback
            },
            delegate
                .map(|m| m.as_raw())
                .unwrap_or_else(|| std::ptr::null_mut()),
        );
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe {
                aeron_image_fragment_assembler_create(ctx_field, delegate, delegate_clientd)
            },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_image_fragment_assembler_delete(*ctx_field)
            })),
            false,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
        })
    }
    #[inline]
    #[doc = "Delete an image fragment assembler."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_fragment_assembler_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Handler function to be passed for handling fragment assembly."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `clientd` passed in the poll call (must be a `AeronImageFragmentAssembler`)"]
    #[doc = " \n - `buffer` containing the data."]
    #[doc = " \n - `header` representing the meta data for the data."]
    pub fn handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: &[u8],
        header: &AeronHeader,
    ) -> () {
        unsafe {
            let result = aeron_image_fragment_assembler_handler(
                clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                header.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_fragment_assembler_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_fragment_assembler_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_fragment_assembler_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImageFragmentAssembler {
    type Target = aeron_image_fragment_assembler_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_fragment_assembler_t> for AeronImageFragmentAssembler {
    #[inline]
    fn from(value: *mut aeron_image_fragment_assembler_t) -> Self {
        AeronImageFragmentAssembler {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImageFragmentAssembler> for *mut aeron_image_fragment_assembler_t {
    #[inline]
    fn from(value: AeronImageFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImageFragmentAssembler> for *mut aeron_image_fragment_assembler_t {
    #[inline]
    fn from(value: &AeronImageFragmentAssembler) -> Self {
        value.get_inner()
    }
}
impl From<AeronImageFragmentAssembler> for aeron_image_fragment_assembler_t {
    #[inline]
    fn from(value: AeronImageFragmentAssembler) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_fragment_assembler_t> for AeronImageFragmentAssembler {
    #[inline]
    fn from(value: *const aeron_image_fragment_assembler_t) -> Self {
        AeronImageFragmentAssembler {
            inner: CResource::Borrowed(value as *mut aeron_image_fragment_assembler_t),
        }
    }
}
impl From<aeron_image_fragment_assembler_t> for AeronImageFragmentAssembler {
    #[inline]
    fn from(value: aeron_image_fragment_assembler_t) -> Self {
        AeronImageFragmentAssembler {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronImageMessage {
    inner: CResource<aeron_image_message_t>,
}
impl core::fmt::Debug for AeronImageMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImageMessage))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImageMessage))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(
                    stringify!(subscription_registration_id),
                    &self.subscription_registration_id(),
                )
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronImageMessage {
    #[inline]
    pub fn new(
        correlation_id: i64,
        subscription_registration_id: i64,
        stream_id: i32,
        channel_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_image_message_t {
                    correlation_id: correlation_id.into(),
                    subscription_registration_id: subscription_registration_id.into(),
                    stream_id: stream_id.into(),
                    channel_length: channel_length.into(),
                };
                let inner_ptr: *mut aeron_image_message_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_image_message_t)
                );
                let inst: aeron_image_message_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_image_message_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_image_message_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn subscription_registration_id(&self) -> i64 {
        self.subscription_registration_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_message_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_message_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_message_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImageMessage {
    type Target = aeron_image_message_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_message_t> for AeronImageMessage {
    #[inline]
    fn from(value: *mut aeron_image_message_t) -> Self {
        AeronImageMessage {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImageMessage> for *mut aeron_image_message_t {
    #[inline]
    fn from(value: AeronImageMessage) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImageMessage> for *mut aeron_image_message_t {
    #[inline]
    fn from(value: &AeronImageMessage) -> Self {
        value.get_inner()
    }
}
impl From<AeronImageMessage> for aeron_image_message_t {
    #[inline]
    fn from(value: AeronImageMessage) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_message_t> for AeronImageMessage {
    #[inline]
    fn from(value: *const aeron_image_message_t) -> Self {
        AeronImageMessage {
            inner: CResource::Borrowed(value as *mut aeron_image_message_t),
        }
    }
}
impl From<aeron_image_message_t> for AeronImageMessage {
    #[inline]
    fn from(value: aeron_image_message_t) -> Self {
        AeronImageMessage {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronImageMessage {
    fn default() -> Self {
        AeronImageMessage::new_zeroed_on_heap()
    }
}
impl AeronImageMessage {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronImage {
    inner: CResource<aeron_image_t>,
}
impl core::fmt::Debug for AeronImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronImage))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronImage))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronImage {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_image_t)
                );
                let inst: aeron_image_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_image_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            Some(|c| unsafe { aeron_image_is_closed(c) }),
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_image_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a image."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `image` to get the constants for."]
    #[doc = " \n - `constants` structure to fill in with the constants"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn constants(&self, constants: &AeronImageConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a image."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronImageConstants, AeronCError> {
        let result = AeronImageConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "The position this image has been consumed to by the subscriber."]
    #[doc = ""]
    #[doc = " \n# Return\n the position this image has been consumed to by the subscriber."]
    pub fn position(&self) -> i64 {
        unsafe {
            let result = aeron_image_position(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Set the subscriber position for this image to indicate where it has been consumed to."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `image` to set the position of."]
    pub fn set_position(&self, position: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_set_position(self.get_inner(), position.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Is the current consumed position at the end of the stream?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if at the end of the stream or false if not."]
    pub fn is_end_of_stream(&self) -> bool {
        unsafe {
            let result = aeron_image_is_end_of_stream(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "The position the stream reached when EOS was received from the publisher. The position will be"]
    #[doc = " INT64_MAX until the stream ends and EOS is set."]
    #[doc = ""]
    #[doc = " \n# Return\n position the stream reached when EOS was received from the publisher."]
    pub fn end_of_stream_position(&self) -> i64 {
        unsafe {
            let result = aeron_image_end_of_stream_position(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Count of observed active transports within the image liveness timeout."]
    #[doc = ""]
    #[doc = " If the image is closed, then this is 0. This may also be 0 if no actual datagrams have arrived. IPC"]
    #[doc = " Images also will be 0."]
    #[doc = ""]
    #[doc = " \n# Return\n count of active transports - 0 if Image is closed, no datagrams yet, or IPC. Or -1 for error."]
    pub fn active_transport_count(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_active_transport_count(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Was the associated publication revoked?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if the associated publication was revoked."]
    pub fn is_publication_revoked(&self) -> bool {
        unsafe {
            let result = aeron_image_is_publication_revoked(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified."]
    #[doc = " \n"]
    #[doc = " Use a fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    pub fn poll<AeronFragmentHandlerHandlerImpl: AeronFragmentHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronFragmentHandlerHandlerImpl>>,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_poll(
                self.get_inner(),
                {
                    let callback: aeron_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_fragment_handler_t_callback::<AeronFragmentHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified."]
    #[doc = " \n"]
    #[doc = " Use a fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn poll_once<AeronFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> ()>(
        &self,
        mut handler: AeronFragmentHandlerHandlerImpl,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_poll(
                self.get_inner(),
                Some(
                    aeron_fragment_handler_t_callback_for_once_closure::<
                        AeronFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    pub fn controlled_poll<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        &self,
        handler: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_controlled_poll(
                self.get_inner(),
                {
                    let callback: aeron_controlled_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_controlled_fragment_handler_t_callback::<
                                AeronControlledFragmentHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn controlled_poll_once<
        AeronControlledFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> aeron_controlled_fragment_handler_action_t,
    >(
        &self,
        mut handler: AeronControlledFragmentHandlerHandlerImpl,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_controlled_poll(
                self.get_inner(),
                Some(
                    aeron_controlled_fragment_handler_t_callback_for_once_closure::<
                        AeronControlledFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified."]
    #[doc = " \n"]
    #[doc = " Use a fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` to consume messages up to."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    pub fn bounded_poll<AeronFragmentHandlerHandlerImpl: AeronFragmentHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronFragmentHandlerHandlerImpl>>,
        limit_position: i64,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_bounded_poll(
                self.get_inner(),
                {
                    let callback: aeron_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_fragment_handler_t_callback::<AeronFragmentHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                limit_position.into(),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified."]
    #[doc = " \n"]
    #[doc = " Use a fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` to consume messages up to."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn bounded_poll_once<AeronFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> ()>(
        &self,
        mut handler: AeronFragmentHandlerHandlerImpl,
        limit_position: i64,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_bounded_poll(
                self.get_inner(),
                Some(
                    aeron_fragment_handler_t_callback_for_once_closure::<
                        AeronFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                limit_position.into(),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` to consume messages up to."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    pub fn bounded_controlled_poll<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        &self,
        handler: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
        limit_position: i64,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_bounded_controlled_poll(
                self.get_inner(),
                {
                    let callback: aeron_controlled_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_controlled_fragment_handler_t_callback::<
                                AeronControlledFragmentHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                limit_position.into(),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` to consume messages up to."]
    #[doc = " \n - `fragment_limit` for the number of fragments to be consumed during one polling operation."]
    #[doc = " \n# Return\n the number of fragments that have been consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn bounded_controlled_poll_once<
        AeronControlledFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> aeron_controlled_fragment_handler_action_t,
    >(
        &self,
        mut handler: AeronControlledFragmentHandlerHandlerImpl,
        limit_position: i64,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_bounded_controlled_poll(
                self.get_inner(),
                Some(
                    aeron_controlled_fragment_handler_t_callback_for_once_closure::<
                        AeronControlledFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                limit_position.into(),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Peek for new messages in a stream by scanning forward from an initial position. If new messages are found then"]
    #[doc = " they will be delivered to the handler up to a limited position."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments. Scans must also"]
    #[doc = " start at the beginning of a message so that the assembler is reset."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `initial_position` from which to peek forward."]
    #[doc = " \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` up to which can be scanned."]
    #[doc = " \n# Return\n the resulting position after the scan terminates which is a complete message or -1 for error."]
    pub fn controlled_peek<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        &self,
        initial_position: i64,
        handler: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
        limit_position: i64,
    ) -> i64 {
        unsafe {
            let result = aeron_image_controlled_peek(
                self.get_inner(),
                initial_position.into(),
                {
                    let callback: aeron_controlled_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_controlled_fragment_handler_t_callback::<
                                AeronControlledFragmentHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                limit_position.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Peek for new messages in a stream by scanning forward from an initial position. If new messages are found then"]
    #[doc = " they will be delivered to the handler up to a limited position."]
    #[doc = " \n"]
    #[doc = " Use a controlled fragment assembler to assemble messages which span multiple fragments. Scans must also"]
    #[doc = " start at the beginning of a message so that the assembler is reset."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `initial_position` from which to peek forward."]
    #[doc = " \n - `handler` to which message fragments are delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `limit_position` up to which can be scanned."]
    #[doc = " \n# Return\n the resulting position after the scan terminates which is a complete message or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn controlled_peek_once<
        AeronControlledFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> aeron_controlled_fragment_handler_action_t,
    >(
        &self,
        initial_position: i64,
        mut handler: AeronControlledFragmentHandlerHandlerImpl,
        limit_position: i64,
    ) -> i64 {
        unsafe {
            let result = aeron_image_controlled_peek(
                self.get_inner(),
                initial_position.into(),
                Some(
                    aeron_controlled_fragment_handler_t_callback_for_once_closure::<
                        AeronControlledFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                limit_position.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of bytes."]
    #[doc = " \n"]
    #[doc = " A scan will terminate if a padding frame is encountered. If first frame in a scan is padding then a block"]
    #[doc = " for the padding is notified. If the padding comes after the first frame in a scan then the scan terminates"]
    #[doc = " at the offset the padding frame begins. Padding frames are delivered singularly in a block."]
    #[doc = " \n"]
    #[doc = " Padding frames may be for a greater range than the limit offset but only the header needs to be valid so"]
    #[doc = " relevant length of the frame is data header length."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which block is delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `block_length_limit` up to which a block may be in length."]
    #[doc = " \n# Return\n the number of bytes that have been consumed or -1 for error."]
    pub fn block_poll<AeronBlockHandlerHandlerImpl: AeronBlockHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronBlockHandlerHandlerImpl>>,
        block_length_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_block_poll(
                self.get_inner(),
                {
                    let callback: aeron_block_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_block_handler_t_callback::<AeronBlockHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                block_length_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll for new messages in a stream. If new messages are found beyond the last consumed position then they"]
    #[doc = " will be delivered to the handler up to a limited number of bytes."]
    #[doc = " \n"]
    #[doc = " A scan will terminate if a padding frame is encountered. If first frame in a scan is padding then a block"]
    #[doc = " for the padding is notified. If the padding comes after the first frame in a scan then the scan terminates"]
    #[doc = " at the offset the padding frame begins. Padding frames are delivered singularly in a block."]
    #[doc = " \n"]
    #[doc = " Padding frames may be for a greater range than the limit offset but only the header needs to be valid so"]
    #[doc = " relevant length of the frame is data header length."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to which block is delivered."]
    #[doc = " \n - `clientd` to pass to the handler."]
    #[doc = " \n - `block_length_limit` up to which a block may be in length."]
    #[doc = " \n# Return\n the number of bytes that have been consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn block_poll_once<AeronBlockHandlerHandlerImpl: FnMut(&[u8], i32, i32) -> ()>(
        &self,
        mut handler: AeronBlockHandlerHandlerImpl,
        block_length_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_block_poll(
                self.get_inner(),
                Some(
                    aeron_block_handler_t_callback_for_once_closure::<AeronBlockHandlerHandlerImpl>,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                block_length_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_image_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn reject(&self, reason: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_image_reject(self.get_inner(), reason.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_image_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_image_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_image_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronImage {
    type Target = aeron_image_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_image_t> for AeronImage {
    #[inline]
    fn from(value: *mut aeron_image_t) -> Self {
        AeronImage {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronImage> for *mut aeron_image_t {
    #[inline]
    fn from(value: AeronImage) -> Self {
        value.get_inner()
    }
}
impl From<&AeronImage> for *mut aeron_image_t {
    #[inline]
    fn from(value: &AeronImage) -> Self {
        value.get_inner()
    }
}
impl From<AeronImage> for aeron_image_t {
    #[inline]
    fn from(value: AeronImage) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_image_t> for AeronImage {
    #[inline]
    fn from(value: *const aeron_image_t) -> Self {
        AeronImage {
            inner: CResource::Borrowed(value as *mut aeron_image_t),
        }
    }
}
impl From<aeron_image_t> for AeronImage {
    #[inline]
    fn from(value: aeron_image_t) -> Self {
        AeronImage {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronInt64CounterMap {
    inner: CResource<aeron_int64_counter_map_t>,
}
impl core::fmt::Debug for AeronInt64CounterMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronInt64CounterMap))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronInt64CounterMap))
                .field("inner", &self.inner)
                .field(stringify!(load_factor), &self.load_factor())
                .field(stringify!(entries_length), &self.entries_length())
                .field(stringify!(size), &self.size())
                .field(stringify!(resize_threshold), &self.resize_threshold())
                .field(stringify!(initial_value), &self.initial_value())
                .finish()
        }
    }
}
impl AeronInt64CounterMap {
    #[inline]
    pub fn new(
        entries: &mut i64,
        load_factor: f32,
        entries_length: usize,
        size: usize,
        resize_threshold: usize,
        initial_value: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_int64_counter_map_t {
                    entries: entries as *mut _,
                    load_factor: load_factor.into(),
                    entries_length: entries_length.into(),
                    size: size.into(),
                    resize_threshold: resize_threshold.into(),
                    initial_value: initial_value.into(),
                };
                let inner_ptr: *mut aeron_int64_counter_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_int64_counter_map_t)
                );
                let inst: aeron_int64_counter_map_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_int64_counter_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_int64_counter_map_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn entries(&self) -> &mut i64 {
        unsafe { &mut *self.entries }
    }
    #[inline]
    pub fn load_factor(&self) -> f32 {
        self.load_factor.into()
    }
    #[inline]
    pub fn entries_length(&self) -> usize {
        self.entries_length.into()
    }
    #[inline]
    pub fn size(&self) -> usize {
        self.size.into()
    }
    #[inline]
    pub fn resize_threshold(&self) -> usize {
        self.resize_threshold.into()
    }
    #[inline]
    pub fn initial_value(&self) -> i64 {
        self.initial_value.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_int64_counter_map_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_int64_counter_map_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_int64_counter_map_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronInt64CounterMap {
    type Target = aeron_int64_counter_map_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_int64_counter_map_t> for AeronInt64CounterMap {
    #[inline]
    fn from(value: *mut aeron_int64_counter_map_t) -> Self {
        AeronInt64CounterMap {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronInt64CounterMap> for *mut aeron_int64_counter_map_t {
    #[inline]
    fn from(value: AeronInt64CounterMap) -> Self {
        value.get_inner()
    }
}
impl From<&AeronInt64CounterMap> for *mut aeron_int64_counter_map_t {
    #[inline]
    fn from(value: &AeronInt64CounterMap) -> Self {
        value.get_inner()
    }
}
impl From<AeronInt64CounterMap> for aeron_int64_counter_map_t {
    #[inline]
    fn from(value: AeronInt64CounterMap) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_int64_counter_map_t> for AeronInt64CounterMap {
    #[inline]
    fn from(value: *const aeron_int64_counter_map_t) -> Self {
        AeronInt64CounterMap {
            inner: CResource::Borrowed(value as *mut aeron_int64_counter_map_t),
        }
    }
}
impl From<aeron_int64_counter_map_t> for AeronInt64CounterMap {
    #[inline]
    fn from(value: aeron_int64_counter_map_t) -> Self {
        AeronInt64CounterMap {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronInt64CounterMap {
    fn default() -> Self {
        AeronInt64CounterMap::new_zeroed_on_heap()
    }
}
impl AeronInt64CounterMap {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronInt64ToPtrHashMap {
    inner: CResource<aeron_int64_to_ptr_hash_map_t>,
}
impl core::fmt::Debug for AeronInt64ToPtrHashMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronInt64ToPtrHashMap))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronInt64ToPtrHashMap))
                .field("inner", &self.inner)
                .field(stringify!(load_factor), &self.load_factor())
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(size), &self.size())
                .field(stringify!(resize_threshold), &self.resize_threshold())
                .finish()
        }
    }
}
impl AeronInt64ToPtrHashMap {
    #[inline]
    pub fn new(
        keys: &mut i64,
        values: *mut *mut ::std::os::raw::c_void,
        load_factor: f32,
        capacity: usize,
        size: usize,
        resize_threshold: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_int64_to_ptr_hash_map_t {
                    keys: keys as *mut _,
                    values: values.into(),
                    load_factor: load_factor.into(),
                    capacity: capacity.into(),
                    size: size.into(),
                    resize_threshold: resize_threshold.into(),
                };
                let inner_ptr: *mut aeron_int64_to_ptr_hash_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_int64_to_ptr_hash_map_t)
                );
                let inst: aeron_int64_to_ptr_hash_map_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_int64_to_ptr_hash_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_int64_to_ptr_hash_map_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn keys(&self) -> &mut i64 {
        unsafe { &mut *self.keys }
    }
    #[inline]
    pub fn values(&self) -> *mut *mut ::std::os::raw::c_void {
        self.values.into()
    }
    #[inline]
    pub fn load_factor(&self) -> f32 {
        self.load_factor.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn size(&self) -> usize {
        self.size.into()
    }
    #[inline]
    pub fn resize_threshold(&self) -> usize {
        self.resize_threshold.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_int64_to_ptr_hash_map_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_int64_to_ptr_hash_map_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_int64_to_ptr_hash_map_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronInt64ToPtrHashMap {
    type Target = aeron_int64_to_ptr_hash_map_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_int64_to_ptr_hash_map_t> for AeronInt64ToPtrHashMap {
    #[inline]
    fn from(value: *mut aeron_int64_to_ptr_hash_map_t) -> Self {
        AeronInt64ToPtrHashMap {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronInt64ToPtrHashMap> for *mut aeron_int64_to_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronInt64ToPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<&AeronInt64ToPtrHashMap> for *mut aeron_int64_to_ptr_hash_map_t {
    #[inline]
    fn from(value: &AeronInt64ToPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<AeronInt64ToPtrHashMap> for aeron_int64_to_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronInt64ToPtrHashMap) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_int64_to_ptr_hash_map_t> for AeronInt64ToPtrHashMap {
    #[inline]
    fn from(value: *const aeron_int64_to_ptr_hash_map_t) -> Self {
        AeronInt64ToPtrHashMap {
            inner: CResource::Borrowed(value as *mut aeron_int64_to_ptr_hash_map_t),
        }
    }
}
impl From<aeron_int64_to_ptr_hash_map_t> for AeronInt64ToPtrHashMap {
    #[inline]
    fn from(value: aeron_int64_to_ptr_hash_map_t) -> Self {
        AeronInt64ToPtrHashMap {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronInt64ToPtrHashMap {
    fn default() -> Self {
        AeronInt64ToPtrHashMap::new_zeroed_on_heap()
    }
}
impl AeronInt64ToPtrHashMap {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronInt64ToTaggedPtrEntry {
    inner: CResource<aeron_int64_to_tagged_ptr_entry_t>,
}
impl core::fmt::Debug for AeronInt64ToTaggedPtrEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronInt64ToTaggedPtrEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronInt64ToTaggedPtrEntry))
                .field("inner", &self.inner)
                .field(stringify!(internal_flags), &self.internal_flags())
                .field(stringify!(tag), &self.tag())
                .finish()
        }
    }
}
impl AeronInt64ToTaggedPtrEntry {
    #[inline]
    pub fn new(
        value: *mut ::std::os::raw::c_void,
        internal_flags: u32,
        tag: u32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_int64_to_tagged_ptr_entry_t {
                    value: value.into(),
                    internal_flags: internal_flags.into(),
                    tag: tag.into(),
                };
                let inner_ptr: *mut aeron_int64_to_tagged_ptr_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_int64_to_tagged_ptr_entry_t)
                );
                let inst: aeron_int64_to_tagged_ptr_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_int64_to_tagged_ptr_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_int64_to_tagged_ptr_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn value(&self) -> *mut ::std::os::raw::c_void {
        self.value.into()
    }
    #[inline]
    pub fn internal_flags(&self) -> u32 {
        self.internal_flags.into()
    }
    #[inline]
    pub fn tag(&self) -> u32 {
        self.tag.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_int64_to_tagged_ptr_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_int64_to_tagged_ptr_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_int64_to_tagged_ptr_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronInt64ToTaggedPtrEntry {
    type Target = aeron_int64_to_tagged_ptr_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_int64_to_tagged_ptr_entry_t> for AeronInt64ToTaggedPtrEntry {
    #[inline]
    fn from(value: *mut aeron_int64_to_tagged_ptr_entry_t) -> Self {
        AeronInt64ToTaggedPtrEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronInt64ToTaggedPtrEntry> for *mut aeron_int64_to_tagged_ptr_entry_t {
    #[inline]
    fn from(value: AeronInt64ToTaggedPtrEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronInt64ToTaggedPtrEntry> for *mut aeron_int64_to_tagged_ptr_entry_t {
    #[inline]
    fn from(value: &AeronInt64ToTaggedPtrEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronInt64ToTaggedPtrEntry> for aeron_int64_to_tagged_ptr_entry_t {
    #[inline]
    fn from(value: AeronInt64ToTaggedPtrEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_int64_to_tagged_ptr_entry_t> for AeronInt64ToTaggedPtrEntry {
    #[inline]
    fn from(value: *const aeron_int64_to_tagged_ptr_entry_t) -> Self {
        AeronInt64ToTaggedPtrEntry {
            inner: CResource::Borrowed(value as *mut aeron_int64_to_tagged_ptr_entry_t),
        }
    }
}
impl From<aeron_int64_to_tagged_ptr_entry_t> for AeronInt64ToTaggedPtrEntry {
    #[inline]
    fn from(value: aeron_int64_to_tagged_ptr_entry_t) -> Self {
        AeronInt64ToTaggedPtrEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronInt64ToTaggedPtrEntry {
    fn default() -> Self {
        AeronInt64ToTaggedPtrEntry::new_zeroed_on_heap()
    }
}
impl AeronInt64ToTaggedPtrEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronInt64ToTaggedPtrHashMap {
    inner: CResource<aeron_int64_to_tagged_ptr_hash_map_t>,
}
impl core::fmt::Debug for AeronInt64ToTaggedPtrHashMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronInt64ToTaggedPtrHashMap))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronInt64ToTaggedPtrHashMap))
                .field("inner", &self.inner)
                .field(stringify!(load_factor), &self.load_factor())
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(size), &self.size())
                .field(stringify!(resize_threshold), &self.resize_threshold())
                .finish()
        }
    }
}
impl AeronInt64ToTaggedPtrHashMap {
    #[inline]
    pub fn new(
        keys: &mut i64,
        entries: &AeronInt64ToTaggedPtrEntry,
        load_factor: f32,
        capacity: usize,
        size: usize,
        resize_threshold: usize,
    ) -> Result<Self, AeronCError> {
        let entries_copy = entries.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_int64_to_tagged_ptr_hash_map_t {
                    keys: keys as *mut _,
                    entries: entries.into(),
                    load_factor: load_factor.into(),
                    capacity: capacity.into(),
                    size: size.into(),
                    resize_threshold: resize_threshold.into(),
                };
                let inner_ptr: *mut aeron_int64_to_tagged_ptr_hash_map_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_int64_to_tagged_ptr_hash_map_t)
                );
                let inst: aeron_int64_to_tagged_ptr_hash_map_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_int64_to_tagged_ptr_hash_map_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn keys(&self) -> &mut i64 {
        unsafe { &mut *self.keys }
    }
    #[inline]
    pub fn entries(&self) -> AeronInt64ToTaggedPtrEntry {
        self.entries.into()
    }
    #[inline]
    pub fn load_factor(&self) -> f32 {
        self.load_factor.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn size(&self) -> usize {
        self.size.into()
    }
    #[inline]
    pub fn resize_threshold(&self) -> usize {
        self.resize_threshold.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_int64_to_tagged_ptr_hash_map_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_int64_to_tagged_ptr_hash_map_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_int64_to_tagged_ptr_hash_map_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronInt64ToTaggedPtrHashMap {
    type Target = aeron_int64_to_tagged_ptr_hash_map_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_int64_to_tagged_ptr_hash_map_t> for AeronInt64ToTaggedPtrHashMap {
    #[inline]
    fn from(value: *mut aeron_int64_to_tagged_ptr_hash_map_t) -> Self {
        AeronInt64ToTaggedPtrHashMap {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronInt64ToTaggedPtrHashMap> for *mut aeron_int64_to_tagged_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronInt64ToTaggedPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<&AeronInt64ToTaggedPtrHashMap> for *mut aeron_int64_to_tagged_ptr_hash_map_t {
    #[inline]
    fn from(value: &AeronInt64ToTaggedPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<AeronInt64ToTaggedPtrHashMap> for aeron_int64_to_tagged_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronInt64ToTaggedPtrHashMap) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_int64_to_tagged_ptr_hash_map_t> for AeronInt64ToTaggedPtrHashMap {
    #[inline]
    fn from(value: *const aeron_int64_to_tagged_ptr_hash_map_t) -> Self {
        AeronInt64ToTaggedPtrHashMap {
            inner: CResource::Borrowed(value as *mut aeron_int64_to_tagged_ptr_hash_map_t),
        }
    }
}
impl From<aeron_int64_to_tagged_ptr_hash_map_t> for AeronInt64ToTaggedPtrHashMap {
    #[inline]
    fn from(value: aeron_int64_to_tagged_ptr_hash_map_t) -> Self {
        AeronInt64ToTaggedPtrHashMap {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronInt64ToTaggedPtrHashMap {
    fn default() -> Self {
        AeronInt64ToTaggedPtrHashMap::new_zeroed_on_heap()
    }
}
impl AeronInt64ToTaggedPtrHashMap {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronIovec {
    inner: CResource<aeron_iovec_t>,
}
impl core::fmt::Debug for AeronIovec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronIovec))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronIovec))
                .field("inner", &self.inner)
                .field(stringify!(iov_len), &self.iov_len())
                .finish()
        }
    }
}
impl AeronIovec {
    #[inline]
    pub fn new(iov_base: *mut u8, iov_len: usize) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_iovec_t {
                    iov_base: iov_base.into(),
                    iov_len: iov_len.into(),
                };
                let inner_ptr: *mut aeron_iovec_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_iovec_t)
                );
                let inst: aeron_iovec_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_iovec_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_iovec_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn iov_base(&self) -> *mut u8 {
        self.iov_base.into()
    }
    #[inline]
    pub fn iov_len(&self) -> usize {
        self.iov_len.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_iovec_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_iovec_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_iovec_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronIovec {
    type Target = aeron_iovec_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_iovec_t> for AeronIovec {
    #[inline]
    fn from(value: *mut aeron_iovec_t) -> Self {
        AeronIovec {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronIovec> for *mut aeron_iovec_t {
    #[inline]
    fn from(value: AeronIovec) -> Self {
        value.get_inner()
    }
}
impl From<&AeronIovec> for *mut aeron_iovec_t {
    #[inline]
    fn from(value: &AeronIovec) -> Self {
        value.get_inner()
    }
}
impl From<AeronIovec> for aeron_iovec_t {
    #[inline]
    fn from(value: AeronIovec) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_iovec_t> for AeronIovec {
    #[inline]
    fn from(value: *const aeron_iovec_t) -> Self {
        AeronIovec {
            inner: CResource::Borrowed(value as *mut aeron_iovec_t),
        }
    }
}
impl From<aeron_iovec_t> for AeronIovec {
    #[inline]
    fn from(value: aeron_iovec_t) -> Self {
        AeronIovec {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronIovec {
    fn default() -> Self {
        AeronIovec::new_zeroed_on_heap()
    }
}
impl AeronIovec {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronIpcChannelParams {
    inner: CResource<aeron_ipc_channel_params_t>,
}
impl core::fmt::Debug for AeronIpcChannelParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronIpcChannelParams))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronIpcChannelParams))
                .field("inner", &self.inner)
                .field(stringify!(additional_params), &self.additional_params())
                .finish()
        }
    }
}
impl AeronIpcChannelParams {
    #[inline]
    pub fn new(
        channel_tag: &std::ffi::CStr,
        entity_tag: &std::ffi::CStr,
        additional_params: AeronUriParams,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_ipc_channel_params_t {
                    channel_tag: channel_tag.as_ptr(),
                    entity_tag: entity_tag.as_ptr(),
                    additional_params: additional_params.into(),
                };
                let inner_ptr: *mut aeron_ipc_channel_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_ipc_channel_params_t)
                );
                let inst: aeron_ipc_channel_params_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_ipc_channel_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_ipc_channel_params_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel_tag(&self) -> &str {
        if self.channel_tag.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.channel_tag).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn entity_tag(&self) -> &str {
        if self.entity_tag.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.entity_tag).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn additional_params(&self) -> AeronUriParams {
        self.additional_params.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_ipc_channel_params_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_ipc_channel_params_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_ipc_channel_params_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronIpcChannelParams {
    type Target = aeron_ipc_channel_params_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_ipc_channel_params_t> for AeronIpcChannelParams {
    #[inline]
    fn from(value: *mut aeron_ipc_channel_params_t) -> Self {
        AeronIpcChannelParams {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronIpcChannelParams> for *mut aeron_ipc_channel_params_t {
    #[inline]
    fn from(value: AeronIpcChannelParams) -> Self {
        value.get_inner()
    }
}
impl From<&AeronIpcChannelParams> for *mut aeron_ipc_channel_params_t {
    #[inline]
    fn from(value: &AeronIpcChannelParams) -> Self {
        value.get_inner()
    }
}
impl From<AeronIpcChannelParams> for aeron_ipc_channel_params_t {
    #[inline]
    fn from(value: AeronIpcChannelParams) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_ipc_channel_params_t> for AeronIpcChannelParams {
    #[inline]
    fn from(value: *const aeron_ipc_channel_params_t) -> Self {
        AeronIpcChannelParams {
            inner: CResource::Borrowed(value as *mut aeron_ipc_channel_params_t),
        }
    }
}
impl From<aeron_ipc_channel_params_t> for AeronIpcChannelParams {
    #[inline]
    fn from(value: aeron_ipc_channel_params_t) -> Self {
        AeronIpcChannelParams {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronIpcChannelParams {
    fn default() -> Self {
        AeronIpcChannelParams::new_zeroed_on_heap()
    }
}
impl AeronIpcChannelParams {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronIpcPublicationEntry {
    inner: CResource<aeron_ipc_publication_entry_t>,
}
impl core::fmt::Debug for AeronIpcPublicationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronIpcPublicationEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronIpcPublicationEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronIpcPublicationEntry {
    #[inline]
    pub fn new(publication: &AeronIpcPublication) -> Result<Self, AeronCError> {
        let publication_copy = publication.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_ipc_publication_entry_t {
                    publication: publication.into(),
                };
                let inner_ptr: *mut aeron_ipc_publication_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_ipc_publication_entry_t)
                );
                let inst: aeron_ipc_publication_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_ipc_publication_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_ipc_publication_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn publication(&self) -> AeronIpcPublication {
        self.publication.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_ipc_publication_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_ipc_publication_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_ipc_publication_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronIpcPublicationEntry {
    type Target = aeron_ipc_publication_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_ipc_publication_entry_t> for AeronIpcPublicationEntry {
    #[inline]
    fn from(value: *mut aeron_ipc_publication_entry_t) -> Self {
        AeronIpcPublicationEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronIpcPublicationEntry> for *mut aeron_ipc_publication_entry_t {
    #[inline]
    fn from(value: AeronIpcPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronIpcPublicationEntry> for *mut aeron_ipc_publication_entry_t {
    #[inline]
    fn from(value: &AeronIpcPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronIpcPublicationEntry> for aeron_ipc_publication_entry_t {
    #[inline]
    fn from(value: AeronIpcPublicationEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_ipc_publication_entry_t> for AeronIpcPublicationEntry {
    #[inline]
    fn from(value: *const aeron_ipc_publication_entry_t) -> Self {
        AeronIpcPublicationEntry {
            inner: CResource::Borrowed(value as *mut aeron_ipc_publication_entry_t),
        }
    }
}
impl From<aeron_ipc_publication_entry_t> for AeronIpcPublicationEntry {
    #[inline]
    fn from(value: aeron_ipc_publication_entry_t) -> Self {
        AeronIpcPublicationEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronIpcPublicationEntry {
    fn default() -> Self {
        AeronIpcPublicationEntry::new_zeroed_on_heap()
    }
}
impl AeronIpcPublicationEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronIpcPublication {
    inner: CResource<aeron_ipc_publication_t>,
}
impl core::fmt::Debug for AeronIpcPublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronIpcPublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronIpcPublication))
                .field("inner", &self.inner)
                .field(stringify!(mapped_raw_log), &self.mapped_raw_log())
                .field(stringify!(pub_lmt_position), &self.pub_lmt_position())
                .field(stringify!(pub_pos_position), &self.pub_pos_position())
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .field(stringify!(term_window_length), &self.term_window_length())
                .field(stringify!(trip_gain), &self.trip_gain())
                .field(stringify!(unblock_timeout_ns), &self.unblock_timeout_ns())
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .field(stringify!(liveness_timeout_ns), &self.liveness_timeout_ns())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(stringify!(is_exclusive), &self.is_exclusive())
                .field(stringify!(in_cool_down), &self.in_cool_down())
                .field(
                    stringify!(cool_down_expire_time_ns),
                    &self.cool_down_expire_time_ns(),
                )
                .field(stringify!(tag), &self.tag())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(starting_term_id), &self.starting_term_id())
                .field(
                    stringify!(starting_term_offset),
                    &self.starting_term_offset(),
                )
                .field(stringify!(channel_length), &self.channel_length())
                .field(
                    stringify!(log_file_name_length),
                    &self.log_file_name_length(),
                )
                .finish()
        }
    }
}
impl AeronIpcPublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_ipc_publication_t)
                );
                let inst: aeron_ipc_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_ipc_publication_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_ipc_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn mapped_raw_log(&self) -> AeronMappedRawLog {
        self.mapped_raw_log.into()
    }
    #[inline]
    pub fn log_meta_data(&self) -> AeronLogbufferMetadata {
        self.log_meta_data.into()
    }
    #[inline]
    pub fn pub_lmt_position(&self) -> AeronPosition {
        self.pub_lmt_position.into()
    }
    #[inline]
    pub fn pub_pos_position(&self) -> AeronPosition {
        self.pub_pos_position.into()
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline]
    pub fn term_window_length(&self) -> i64 {
        self.term_window_length.into()
    }
    #[inline]
    pub fn trip_gain(&self) -> i64 {
        self.trip_gain.into()
    }
    #[inline]
    pub fn unblock_timeout_ns(&self) -> i64 {
        self.unblock_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> i64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> i64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline]
    pub fn liveness_timeout_ns(&self) -> i64 {
        self.liveness_timeout_ns.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn is_exclusive(&self) -> bool {
        self.is_exclusive.into()
    }
    #[inline]
    pub fn in_cool_down(&self) -> bool {
        self.in_cool_down.into()
    }
    #[inline]
    pub fn cool_down_expire_time_ns(&self) -> i64 {
        self.cool_down_expire_time_ns.into()
    }
    #[inline]
    pub fn tag(&self) -> i64 {
        self.tag.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn starting_term_id(&self) -> i32 {
        self.starting_term_id.into()
    }
    #[inline]
    pub fn starting_term_offset(&self) -> usize {
        self.starting_term_offset.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline]
    pub fn channel(&self) -> &str {
        if self.channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.channel).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn log_file_name_length(&self) -> usize {
        self.log_file_name_length.into()
    }
    #[inline]
    pub fn log_file_name(&self) -> &str {
        if self.log_file_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.log_file_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn raw_log_close_func(&self) -> aeron_raw_log_close_func_t {
        self.raw_log_close_func.into()
    }
    #[inline]
    pub fn raw_log_free_func(&self) -> aeron_raw_log_free_func_t {
        self.raw_log_free_func.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_ipc_publication_stct__bindgen_ty_1 {
        self.log.into()
    }
    #[inline]
    pub fn unblocked_publications_counter(&self) -> &mut i64 {
        unsafe { &mut *self.unblocked_publications_counter }
    }
    #[inline]
    pub fn publications_revoked_counter(&self) -> &mut i64 {
        unsafe { &mut *self.publications_revoked_counter }
    }
    #[inline]
    pub fn mapped_bytes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.mapped_bytes_counter }
    }
    #[inline]
    pub fn free(&self) -> bool {
        unsafe {
            let result = aeron_ipc_publication_free(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn update_pub_pos_and_lmt(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_ipc_publication_update_pub_pos_and_lmt(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn clean_buffer(&self, position: i64) -> () {
        unsafe {
            let result = aeron_ipc_publication_clean_buffer(self.get_inner(), position.into());
            result.into()
        }
    }
    #[inline]
    pub fn reject(
        &self,
        position: i64,
        reason_length: i32,
        reason: &std::ffi::CStr,
        conductor: &AeronDriverConductor,
        now_ns: i64,
    ) -> () {
        unsafe {
            let result = aeron_ipc_publication_reject(
                self.get_inner(),
                position.into(),
                reason_length.into(),
                reason.as_ptr(),
                conductor.get_inner(),
                now_ns.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn check_for_blocked_publisher(&self, producer_position: i64, now_ns: i64) -> () {
        unsafe {
            let result = aeron_ipc_publication_check_for_blocked_publisher(
                self.get_inner(),
                producer_position.into(),
                now_ns.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_ipc_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_ipc_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_ipc_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronIpcPublication {
    type Target = aeron_ipc_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_ipc_publication_t> for AeronIpcPublication {
    #[inline]
    fn from(value: *mut aeron_ipc_publication_t) -> Self {
        AeronIpcPublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronIpcPublication> for *mut aeron_ipc_publication_t {
    #[inline]
    fn from(value: AeronIpcPublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronIpcPublication> for *mut aeron_ipc_publication_t {
    #[inline]
    fn from(value: &AeronIpcPublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronIpcPublication> for aeron_ipc_publication_t {
    #[inline]
    fn from(value: AeronIpcPublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_ipc_publication_t> for AeronIpcPublication {
    #[inline]
    fn from(value: *const aeron_ipc_publication_t) -> Self {
        AeronIpcPublication {
            inner: CResource::Borrowed(value as *mut aeron_ipc_publication_t),
        }
    }
}
impl From<aeron_ipc_publication_t> for AeronIpcPublication {
    #[inline]
    fn from(value: aeron_ipc_publication_t) -> Self {
        AeronIpcPublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronLingerResourceEntry {
    inner: CResource<aeron_linger_resource_entry_t>,
}
impl core::fmt::Debug for AeronLingerResourceEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLingerResourceEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLingerResourceEntry))
                .field("inner", &self.inner)
                .field(
                    stringify!(has_reached_end_of_life),
                    &self.has_reached_end_of_life(),
                )
                .field(stringify!(timeout_ns), &self.timeout_ns())
                .finish()
        }
    }
}
impl AeronLingerResourceEntry {
    #[inline]
    pub fn new(
        has_reached_end_of_life: bool,
        buffer: *mut u8,
        timeout_ns: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_linger_resource_entry_t {
                    has_reached_end_of_life: has_reached_end_of_life.into(),
                    buffer: buffer.into(),
                    timeout_ns: timeout_ns.into(),
                };
                let inner_ptr: *mut aeron_linger_resource_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_linger_resource_entry_t)
                );
                let inst: aeron_linger_resource_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_linger_resource_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_linger_resource_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn has_reached_end_of_life(&self) -> bool {
        self.has_reached_end_of_life.into()
    }
    #[inline]
    pub fn buffer(&self) -> *mut u8 {
        self.buffer.into()
    }
    #[inline]
    pub fn timeout_ns(&self) -> i64 {
        self.timeout_ns.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_linger_resource_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_linger_resource_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_linger_resource_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLingerResourceEntry {
    type Target = aeron_linger_resource_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_linger_resource_entry_t> for AeronLingerResourceEntry {
    #[inline]
    fn from(value: *mut aeron_linger_resource_entry_t) -> Self {
        AeronLingerResourceEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLingerResourceEntry> for *mut aeron_linger_resource_entry_t {
    #[inline]
    fn from(value: AeronLingerResourceEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLingerResourceEntry> for *mut aeron_linger_resource_entry_t {
    #[inline]
    fn from(value: &AeronLingerResourceEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronLingerResourceEntry> for aeron_linger_resource_entry_t {
    #[inline]
    fn from(value: AeronLingerResourceEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_linger_resource_entry_t> for AeronLingerResourceEntry {
    #[inline]
    fn from(value: *const aeron_linger_resource_entry_t) -> Self {
        AeronLingerResourceEntry {
            inner: CResource::Borrowed(value as *mut aeron_linger_resource_entry_t),
        }
    }
}
impl From<aeron_linger_resource_entry_t> for AeronLingerResourceEntry {
    #[inline]
    fn from(value: aeron_linger_resource_entry_t) -> Self {
        AeronLingerResourceEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLingerResourceEntry {
    fn default() -> Self {
        AeronLingerResourceEntry::new_zeroed_on_heap()
    }
}
impl AeronLingerResourceEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLinkedQueueNode {
    inner: CResource<aeron_linked_queue_node_t>,
}
impl core::fmt::Debug for AeronLinkedQueueNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLinkedQueueNode))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLinkedQueueNode))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronLinkedQueueNode {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_linked_queue_node_t)
                );
                let inst: aeron_linked_queue_node_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_linked_queue_node_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_linked_queue_node_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_linked_queue_node_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_linked_queue_node_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_linked_queue_node_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_linked_queue_node_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLinkedQueueNode {
    type Target = aeron_linked_queue_node_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_linked_queue_node_t> for AeronLinkedQueueNode {
    #[inline]
    fn from(value: *mut aeron_linked_queue_node_t) -> Self {
        AeronLinkedQueueNode {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLinkedQueueNode> for *mut aeron_linked_queue_node_t {
    #[inline]
    fn from(value: AeronLinkedQueueNode) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLinkedQueueNode> for *mut aeron_linked_queue_node_t {
    #[inline]
    fn from(value: &AeronLinkedQueueNode) -> Self {
        value.get_inner()
    }
}
impl From<AeronLinkedQueueNode> for aeron_linked_queue_node_t {
    #[inline]
    fn from(value: AeronLinkedQueueNode) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_linked_queue_node_t> for AeronLinkedQueueNode {
    #[inline]
    fn from(value: *const aeron_linked_queue_node_t) -> Self {
        AeronLinkedQueueNode {
            inner: CResource::Borrowed(value as *mut aeron_linked_queue_node_t),
        }
    }
}
impl From<aeron_linked_queue_node_t> for AeronLinkedQueueNode {
    #[inline]
    fn from(value: aeron_linked_queue_node_t) -> Self {
        AeronLinkedQueueNode {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronLinkedQueue {
    inner: CResource<aeron_linked_queue_t>,
}
impl core::fmt::Debug for AeronLinkedQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLinkedQueue))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLinkedQueue))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronLinkedQueue {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_linked_queue_t)
                );
                let inst: aeron_linked_queue_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_linked_queue_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_linked_queue_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn head(&self) -> AeronLinkedQueueNode {
        self.head.into()
    }
    #[inline]
    pub fn tail(&self) -> AeronLinkedQueueNode {
        self.tail.into()
    }
    #[inline]
    pub fn init(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_linked_queue_init(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_linked_queue_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn offer(&self, element: *mut ::std::os::raw::c_void) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_linked_queue_offer(self.get_inner(), element.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn offer_ex(
        &self,
        element: *mut ::std::os::raw::c_void,
        node: &AeronLinkedQueueNode,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_linked_queue_offer_ex(self.get_inner(), element.into(), node.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn peek(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_linked_queue_peek(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn poll(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            let result = aeron_linked_queue_poll(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_linked_queue_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_linked_queue_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_linked_queue_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLinkedQueue {
    type Target = aeron_linked_queue_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_linked_queue_t> for AeronLinkedQueue {
    #[inline]
    fn from(value: *mut aeron_linked_queue_t) -> Self {
        AeronLinkedQueue {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLinkedQueue> for *mut aeron_linked_queue_t {
    #[inline]
    fn from(value: AeronLinkedQueue) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLinkedQueue> for *mut aeron_linked_queue_t {
    #[inline]
    fn from(value: &AeronLinkedQueue) -> Self {
        value.get_inner()
    }
}
impl From<AeronLinkedQueue> for aeron_linked_queue_t {
    #[inline]
    fn from(value: AeronLinkedQueue) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_linked_queue_t> for AeronLinkedQueue {
    #[inline]
    fn from(value: *const aeron_linked_queue_t) -> Self {
        AeronLinkedQueue {
            inner: CResource::Borrowed(value as *mut aeron_linked_queue_t),
        }
    }
}
impl From<aeron_linked_queue_t> for AeronLinkedQueue {
    #[inline]
    fn from(value: aeron_linked_queue_t) -> Self {
        AeronLinkedQueue {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronLocalSockaddrKeyLayout {
    inner: CResource<aeron_local_sockaddr_key_layout_t>,
}
impl core::fmt::Debug for AeronLocalSockaddrKeyLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLocalSockaddrKeyLayout))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLocalSockaddrKeyLayout))
                .field("inner", &self.inner)
                .field(stringify!(channel_status_id), &self.channel_status_id())
                .field(stringify!(local_sockaddr_len), &self.local_sockaddr_len())
                .finish()
        }
    }
}
impl AeronLocalSockaddrKeyLayout {
    #[inline]
    pub fn new(
        channel_status_id: i32,
        local_sockaddr_len: i32,
        local_sockaddr: [::std::os::raw::c_char; 104usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_local_sockaddr_key_layout_t {
                    channel_status_id: channel_status_id.into(),
                    local_sockaddr_len: local_sockaddr_len.into(),
                    local_sockaddr: local_sockaddr.into(),
                };
                let inner_ptr: *mut aeron_local_sockaddr_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_local_sockaddr_key_layout_t)
                );
                let inst: aeron_local_sockaddr_key_layout_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_local_sockaddr_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_local_sockaddr_key_layout_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel_status_id(&self) -> i32 {
        self.channel_status_id.into()
    }
    #[inline]
    pub fn local_sockaddr_len(&self) -> i32 {
        self.local_sockaddr_len.into()
    }
    #[inline]
    pub fn local_sockaddr(&self) -> [::std::os::raw::c_char; 104usize] {
        self.local_sockaddr.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_local_sockaddr_key_layout_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_local_sockaddr_key_layout_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_local_sockaddr_key_layout_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLocalSockaddrKeyLayout {
    type Target = aeron_local_sockaddr_key_layout_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_local_sockaddr_key_layout_t> for AeronLocalSockaddrKeyLayout {
    #[inline]
    fn from(value: *mut aeron_local_sockaddr_key_layout_t) -> Self {
        AeronLocalSockaddrKeyLayout {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLocalSockaddrKeyLayout> for *mut aeron_local_sockaddr_key_layout_t {
    #[inline]
    fn from(value: AeronLocalSockaddrKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLocalSockaddrKeyLayout> for *mut aeron_local_sockaddr_key_layout_t {
    #[inline]
    fn from(value: &AeronLocalSockaddrKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<AeronLocalSockaddrKeyLayout> for aeron_local_sockaddr_key_layout_t {
    #[inline]
    fn from(value: AeronLocalSockaddrKeyLayout) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_local_sockaddr_key_layout_t> for AeronLocalSockaddrKeyLayout {
    #[inline]
    fn from(value: *const aeron_local_sockaddr_key_layout_t) -> Self {
        AeronLocalSockaddrKeyLayout {
            inner: CResource::Borrowed(value as *mut aeron_local_sockaddr_key_layout_t),
        }
    }
}
impl From<aeron_local_sockaddr_key_layout_t> for AeronLocalSockaddrKeyLayout {
    #[inline]
    fn from(value: aeron_local_sockaddr_key_layout_t) -> Self {
        AeronLocalSockaddrKeyLayout {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLocalSockaddrKeyLayout {
    fn default() -> Self {
        AeronLocalSockaddrKeyLayout::new_zeroed_on_heap()
    }
}
impl AeronLocalSockaddrKeyLayout {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLogBuffer {
    inner: CResource<aeron_log_buffer_t>,
}
impl core::fmt::Debug for AeronLogBuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLogBuffer))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLogBuffer))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronLogBuffer {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_log_buffer_t)
                );
                let inst: aeron_log_buffer_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_log_buffer_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_log_buffer_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_log_buffer_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_log_buffer_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_log_buffer_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLogBuffer {
    type Target = aeron_log_buffer_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_log_buffer_t> for AeronLogBuffer {
    #[inline]
    fn from(value: *mut aeron_log_buffer_t) -> Self {
        AeronLogBuffer {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLogBuffer> for *mut aeron_log_buffer_t {
    #[inline]
    fn from(value: AeronLogBuffer) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLogBuffer> for *mut aeron_log_buffer_t {
    #[inline]
    fn from(value: &AeronLogBuffer) -> Self {
        value.get_inner()
    }
}
impl From<AeronLogBuffer> for aeron_log_buffer_t {
    #[inline]
    fn from(value: AeronLogBuffer) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_log_buffer_t> for AeronLogBuffer {
    #[inline]
    fn from(value: *const aeron_log_buffer_t) -> Self {
        AeronLogBuffer {
            inner: CResource::Borrowed(value as *mut aeron_log_buffer_t),
        }
    }
}
impl From<aeron_log_buffer_t> for AeronLogBuffer {
    #[inline]
    fn from(value: aeron_log_buffer_t) -> Self {
        AeronLogBuffer {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronLogbufferMetadata {
    inner: CResource<aeron_logbuffer_metadata_t>,
}
impl core::fmt::Debug for AeronLogbufferMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLogbufferMetadata))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLogbufferMetadata))
                .field("inner", &self.inner)
                .field(stringify!(active_term_count), &self.active_term_count())
                .field(
                    stringify!(end_of_stream_position),
                    &self.end_of_stream_position(),
                )
                .field(stringify!(is_connected), &self.is_connected())
                .field(
                    stringify!(active_transport_count),
                    &self.active_transport_count(),
                )
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(
                    stringify!(default_frame_header_length),
                    &self.default_frame_header_length(),
                )
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(stringify!(term_length), &self.term_length())
                .field(stringify!(page_size), &self.page_size())
                .field(
                    stringify!(publication_window_length),
                    &self.publication_window_length(),
                )
                .field(
                    stringify!(receiver_window_length),
                    &self.receiver_window_length(),
                )
                .field(
                    stringify!(socket_sndbuf_length),
                    &self.socket_sndbuf_length(),
                )
                .field(
                    stringify!(os_default_socket_sndbuf_length),
                    &self.os_default_socket_sndbuf_length(),
                )
                .field(
                    stringify!(os_max_socket_sndbuf_length),
                    &self.os_max_socket_sndbuf_length(),
                )
                .field(
                    stringify!(socket_rcvbuf_length),
                    &self.socket_rcvbuf_length(),
                )
                .field(
                    stringify!(os_default_socket_rcvbuf_length),
                    &self.os_default_socket_rcvbuf_length(),
                )
                .field(
                    stringify!(os_max_socket_rcvbuf_length),
                    &self.os_max_socket_rcvbuf_length(),
                )
                .field(stringify!(max_resend), &self.max_resend())
                .field(stringify!(entity_tag), &self.entity_tag())
                .field(
                    stringify!(response_correlation_id),
                    &self.response_correlation_id(),
                )
                .field(stringify!(linger_timeout_ns), &self.linger_timeout_ns())
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .finish()
        }
    }
}
impl AeronLogbufferMetadata {
    #[inline]
    pub fn new(
        term_tail_counters: [i64; 3usize],
        active_term_count: i32,
        pad1: [u8; 100usize],
        end_of_stream_position: i64,
        is_connected: i32,
        active_transport_count: i32,
        pad2: [u8; 112usize],
        correlation_id: i64,
        initial_term_id: i32,
        default_frame_header_length: i32,
        mtu_length: i32,
        term_length: i32,
        page_size: i32,
        publication_window_length: i32,
        receiver_window_length: i32,
        socket_sndbuf_length: i32,
        os_default_socket_sndbuf_length: i32,
        os_max_socket_sndbuf_length: i32,
        socket_rcvbuf_length: i32,
        os_default_socket_rcvbuf_length: i32,
        os_max_socket_rcvbuf_length: i32,
        max_resend: i32,
        default_header: [u8; 128usize],
        entity_tag: i64,
        response_correlation_id: i64,
        linger_timeout_ns: i64,
        untethered_window_limit_timeout_ns: i64,
        untethered_resting_timeout_ns: i64,
        group: u8,
        is_response: u8,
        rejoin: u8,
        reliable: u8,
        sparse: u8,
        signal_eos: u8,
        spies_simulate_connection: u8,
        tether: u8,
        is_publication_revoked: u8,
        pad3: [u8; 3usize],
        untethered_linger_timeout_ns: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_logbuffer_metadata_t {
                    term_tail_counters: term_tail_counters.into(),
                    active_term_count: active_term_count.into(),
                    pad1: pad1.into(),
                    end_of_stream_position: end_of_stream_position.into(),
                    is_connected: is_connected.into(),
                    active_transport_count: active_transport_count.into(),
                    pad2: pad2.into(),
                    correlation_id: correlation_id.into(),
                    initial_term_id: initial_term_id.into(),
                    default_frame_header_length: default_frame_header_length.into(),
                    mtu_length: mtu_length.into(),
                    term_length: term_length.into(),
                    page_size: page_size.into(),
                    publication_window_length: publication_window_length.into(),
                    receiver_window_length: receiver_window_length.into(),
                    socket_sndbuf_length: socket_sndbuf_length.into(),
                    os_default_socket_sndbuf_length: os_default_socket_sndbuf_length.into(),
                    os_max_socket_sndbuf_length: os_max_socket_sndbuf_length.into(),
                    socket_rcvbuf_length: socket_rcvbuf_length.into(),
                    os_default_socket_rcvbuf_length: os_default_socket_rcvbuf_length.into(),
                    os_max_socket_rcvbuf_length: os_max_socket_rcvbuf_length.into(),
                    max_resend: max_resend.into(),
                    default_header: default_header.into(),
                    entity_tag: entity_tag.into(),
                    response_correlation_id: response_correlation_id.into(),
                    linger_timeout_ns: linger_timeout_ns.into(),
                    untethered_window_limit_timeout_ns: untethered_window_limit_timeout_ns.into(),
                    untethered_resting_timeout_ns: untethered_resting_timeout_ns.into(),
                    group: group.into(),
                    is_response: is_response.into(),
                    rejoin: rejoin.into(),
                    reliable: reliable.into(),
                    sparse: sparse.into(),
                    signal_eos: signal_eos.into(),
                    spies_simulate_connection: spies_simulate_connection.into(),
                    tether: tether.into(),
                    is_publication_revoked: is_publication_revoked.into(),
                    pad3: pad3.into(),
                    untethered_linger_timeout_ns: untethered_linger_timeout_ns.into(),
                };
                let inner_ptr: *mut aeron_logbuffer_metadata_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_logbuffer_metadata_t)
                );
                let inst: aeron_logbuffer_metadata_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_logbuffer_metadata_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_logbuffer_metadata_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn term_tail_counters(&self) -> [i64; 3usize] {
        self.term_tail_counters.into()
    }
    #[inline]
    pub fn active_term_count(&self) -> i32 {
        self.active_term_count.into()
    }
    #[inline]
    pub fn pad1(&self) -> [u8; 100usize] {
        self.pad1.into()
    }
    #[inline]
    pub fn end_of_stream_position(&self) -> i64 {
        self.end_of_stream_position.into()
    }
    #[inline]
    pub fn is_connected(&self) -> i32 {
        self.is_connected.into()
    }
    #[inline]
    pub fn active_transport_count(&self) -> i32 {
        self.active_transport_count.into()
    }
    #[inline]
    pub fn pad2(&self) -> [u8; 112usize] {
        self.pad2.into()
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn default_frame_header_length(&self) -> i32 {
        self.default_frame_header_length.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> i32 {
        self.mtu_length.into()
    }
    #[inline]
    pub fn term_length(&self) -> i32 {
        self.term_length.into()
    }
    #[inline]
    pub fn page_size(&self) -> i32 {
        self.page_size.into()
    }
    #[inline]
    pub fn publication_window_length(&self) -> i32 {
        self.publication_window_length.into()
    }
    #[inline]
    pub fn receiver_window_length(&self) -> i32 {
        self.receiver_window_length.into()
    }
    #[inline]
    pub fn socket_sndbuf_length(&self) -> i32 {
        self.socket_sndbuf_length.into()
    }
    #[inline]
    pub fn os_default_socket_sndbuf_length(&self) -> i32 {
        self.os_default_socket_sndbuf_length.into()
    }
    #[inline]
    pub fn os_max_socket_sndbuf_length(&self) -> i32 {
        self.os_max_socket_sndbuf_length.into()
    }
    #[inline]
    pub fn socket_rcvbuf_length(&self) -> i32 {
        self.socket_rcvbuf_length.into()
    }
    #[inline]
    pub fn os_default_socket_rcvbuf_length(&self) -> i32 {
        self.os_default_socket_rcvbuf_length.into()
    }
    #[inline]
    pub fn os_max_socket_rcvbuf_length(&self) -> i32 {
        self.os_max_socket_rcvbuf_length.into()
    }
    #[inline]
    pub fn max_resend(&self) -> i32 {
        self.max_resend.into()
    }
    #[inline]
    pub fn default_header(&self) -> [u8; 128usize] {
        self.default_header.into()
    }
    #[inline]
    pub fn entity_tag(&self) -> i64 {
        self.entity_tag.into()
    }
    #[inline]
    pub fn response_correlation_id(&self) -> i64 {
        self.response_correlation_id.into()
    }
    #[inline]
    pub fn linger_timeout_ns(&self) -> i64 {
        self.linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> i64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> i64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline]
    pub fn group(&self) -> u8 {
        self.group.into()
    }
    #[inline]
    pub fn is_response(&self) -> u8 {
        self.is_response.into()
    }
    #[inline]
    pub fn rejoin(&self) -> u8 {
        self.rejoin.into()
    }
    #[inline]
    pub fn reliable(&self) -> u8 {
        self.reliable.into()
    }
    #[inline]
    pub fn sparse(&self) -> u8 {
        self.sparse.into()
    }
    #[inline]
    pub fn signal_eos(&self) -> u8 {
        self.signal_eos.into()
    }
    #[inline]
    pub fn spies_simulate_connection(&self) -> u8 {
        self.spies_simulate_connection.into()
    }
    #[inline]
    pub fn tether(&self) -> u8 {
        self.tether.into()
    }
    #[inline]
    pub fn is_publication_revoked(&self) -> u8 {
        self.is_publication_revoked.into()
    }
    #[inline]
    pub fn pad3(&self) -> [u8; 3usize] {
        self.pad3.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_logbuffer_metadata_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_logbuffer_metadata_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_logbuffer_metadata_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLogbufferMetadata {
    type Target = aeron_logbuffer_metadata_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_logbuffer_metadata_t> for AeronLogbufferMetadata {
    #[inline]
    fn from(value: *mut aeron_logbuffer_metadata_t) -> Self {
        AeronLogbufferMetadata {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLogbufferMetadata> for *mut aeron_logbuffer_metadata_t {
    #[inline]
    fn from(value: AeronLogbufferMetadata) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLogbufferMetadata> for *mut aeron_logbuffer_metadata_t {
    #[inline]
    fn from(value: &AeronLogbufferMetadata) -> Self {
        value.get_inner()
    }
}
impl From<AeronLogbufferMetadata> for aeron_logbuffer_metadata_t {
    #[inline]
    fn from(value: AeronLogbufferMetadata) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_logbuffer_metadata_t> for AeronLogbufferMetadata {
    #[inline]
    fn from(value: *const aeron_logbuffer_metadata_t) -> Self {
        AeronLogbufferMetadata {
            inner: CResource::Borrowed(value as *mut aeron_logbuffer_metadata_t),
        }
    }
}
impl From<aeron_logbuffer_metadata_t> for AeronLogbufferMetadata {
    #[inline]
    fn from(value: aeron_logbuffer_metadata_t) -> Self {
        AeronLogbufferMetadata {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLogbufferMetadata {
    fn default() -> Self {
        AeronLogbufferMetadata::new_zeroed_on_heap()
    }
}
impl AeronLogbufferMetadata {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLossDetectorGap {
    inner: CResource<aeron_loss_detector_gap_t>,
}
impl core::fmt::Debug for AeronLossDetectorGap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLossDetectorGap))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLossDetectorGap))
                .field("inner", &self.inner)
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronLossDetectorGap {
    #[inline]
    pub fn new(term_id: i32, term_offset: i32, length: usize) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_loss_detector_gap_t {
                    term_id: term_id.into(),
                    term_offset: term_offset.into(),
                    length: length.into(),
                };
                let inner_ptr: *mut aeron_loss_detector_gap_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_loss_detector_gap_t)
                );
                let inst: aeron_loss_detector_gap_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_loss_detector_gap_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_loss_detector_gap_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_loss_detector_gap_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_loss_detector_gap_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_loss_detector_gap_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLossDetectorGap {
    type Target = aeron_loss_detector_gap_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_loss_detector_gap_t> for AeronLossDetectorGap {
    #[inline]
    fn from(value: *mut aeron_loss_detector_gap_t) -> Self {
        AeronLossDetectorGap {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLossDetectorGap> for *mut aeron_loss_detector_gap_t {
    #[inline]
    fn from(value: AeronLossDetectorGap) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLossDetectorGap> for *mut aeron_loss_detector_gap_t {
    #[inline]
    fn from(value: &AeronLossDetectorGap) -> Self {
        value.get_inner()
    }
}
impl From<AeronLossDetectorGap> for aeron_loss_detector_gap_t {
    #[inline]
    fn from(value: AeronLossDetectorGap) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_loss_detector_gap_t> for AeronLossDetectorGap {
    #[inline]
    fn from(value: *const aeron_loss_detector_gap_t) -> Self {
        AeronLossDetectorGap {
            inner: CResource::Borrowed(value as *mut aeron_loss_detector_gap_t),
        }
    }
}
impl From<aeron_loss_detector_gap_t> for AeronLossDetectorGap {
    #[inline]
    fn from(value: aeron_loss_detector_gap_t) -> Self {
        AeronLossDetectorGap {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLossDetectorGap {
    fn default() -> Self {
        AeronLossDetectorGap::new_zeroed_on_heap()
    }
}
impl AeronLossDetectorGap {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLossDetector {
    inner: CResource<aeron_loss_detector_t>,
}
impl core::fmt::Debug for AeronLossDetector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLossDetector))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLossDetector))
                .field("inner", &self.inner)
                .field(stringify!(scanned_gap), &self.scanned_gap())
                .field(stringify!(active_gap), &self.active_gap())
                .field(stringify!(expiry_ns), &self.expiry_ns())
                .finish()
        }
    }
}
impl AeronLossDetector {
    #[inline]
    pub fn new(
        on_gap_detected: aeron_term_gap_scanner_on_gap_detected_func_t,
        feedback_delay_state: &AeronFeedbackDelayGeneratorState,
        on_gap_detected_clientd: *mut ::std::os::raw::c_void,
        scanned_gap: AeronLossDetectorGap,
        active_gap: AeronLossDetectorGap,
        expiry_ns: i64,
    ) -> Result<Self, AeronCError> {
        let feedback_delay_state_copy = feedback_delay_state.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_loss_detector_t {
                    on_gap_detected: on_gap_detected.into(),
                    feedback_delay_state: feedback_delay_state.into(),
                    on_gap_detected_clientd: on_gap_detected_clientd.into(),
                    scanned_gap: scanned_gap.into(),
                    active_gap: active_gap.into(),
                    expiry_ns: expiry_ns.into(),
                };
                let inner_ptr: *mut aeron_loss_detector_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_loss_detector_t)
                );
                let inst: aeron_loss_detector_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_loss_detector_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_loss_detector_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn on_gap_detected(&self) -> aeron_term_gap_scanner_on_gap_detected_func_t {
        self.on_gap_detected.into()
    }
    #[inline]
    pub fn feedback_delay_state(&self) -> AeronFeedbackDelayGeneratorState {
        self.feedback_delay_state.into()
    }
    #[inline]
    pub fn on_gap_detected_clientd(&self) -> *mut ::std::os::raw::c_void {
        self.on_gap_detected_clientd.into()
    }
    #[inline]
    pub fn scanned_gap(&self) -> AeronLossDetectorGap {
        self.scanned_gap.into()
    }
    #[inline]
    pub fn active_gap(&self) -> AeronLossDetectorGap {
        self.active_gap.into()
    }
    #[inline]
    pub fn expiry_ns(&self) -> i64 {
        self.expiry_ns.into()
    }
    #[inline]
    pub fn init<
        AeronTermGapScannerGapDetectedFuncHandlerImpl: AeronTermGapScannerGapDetectedFuncCallback,
    >(
        &self,
        feedback_delay_state: &AeronFeedbackDelayGeneratorState,
        on_gap_detected: Option<&Handler<AeronTermGapScannerGapDetectedFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_loss_detector_init(
                self.get_inner(),
                feedback_delay_state.get_inner(),
                {
                    let callback: aeron_term_gap_scanner_on_gap_detected_func_t =
                        if on_gap_detected.is_none() {
                            None
                        } else {
                            Some(
                                aeron_term_gap_scanner_on_gap_detected_func_t_callback::<
                                    AeronTermGapScannerGapDetectedFuncHandlerImpl,
                                >,
                            )
                        };
                    callback
                },
                on_gap_detected
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn init_once<
        AeronTermGapScannerGapDetectedFuncHandlerImpl: FnMut(i32, i32, usize) -> (),
    >(
        &self,
        feedback_delay_state: &AeronFeedbackDelayGeneratorState,
        mut on_gap_detected: AeronTermGapScannerGapDetectedFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_loss_detector_init(
                self.get_inner(),
                feedback_delay_state.get_inner(),
                Some(
                    aeron_term_gap_scanner_on_gap_detected_func_t_callback_for_once_closure::<
                        AeronTermGapScannerGapDetectedFuncHandlerImpl,
                    >,
                ),
                &mut on_gap_detected as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn scan(
        &self,
        loss_found: &mut bool,
        buffer: *const u8,
        rebuild_position: i64,
        hwm_position: i64,
        now_ns: i64,
        term_length_mask: usize,
        position_bits_to_shift: usize,
        initial_term_id: i32,
    ) -> i32 {
        unsafe {
            let result = aeron_loss_detector_scan(
                self.get_inner(),
                loss_found as *mut _,
                buffer.into(),
                rebuild_position.into(),
                hwm_position.into(),
                now_ns.into(),
                term_length_mask.into(),
                position_bits_to_shift.into(),
                initial_term_id.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_loss_detector_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_loss_detector_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_loss_detector_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLossDetector {
    type Target = aeron_loss_detector_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_loss_detector_t> for AeronLossDetector {
    #[inline]
    fn from(value: *mut aeron_loss_detector_t) -> Self {
        AeronLossDetector {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLossDetector> for *mut aeron_loss_detector_t {
    #[inline]
    fn from(value: AeronLossDetector) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLossDetector> for *mut aeron_loss_detector_t {
    #[inline]
    fn from(value: &AeronLossDetector) -> Self {
        value.get_inner()
    }
}
impl From<AeronLossDetector> for aeron_loss_detector_t {
    #[inline]
    fn from(value: AeronLossDetector) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_loss_detector_t> for AeronLossDetector {
    #[inline]
    fn from(value: *const aeron_loss_detector_t) -> Self {
        AeronLossDetector {
            inner: CResource::Borrowed(value as *mut aeron_loss_detector_t),
        }
    }
}
impl From<aeron_loss_detector_t> for AeronLossDetector {
    #[inline]
    fn from(value: aeron_loss_detector_t) -> Self {
        AeronLossDetector {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLossDetector {
    fn default() -> Self {
        AeronLossDetector::new_zeroed_on_heap()
    }
}
impl AeronLossDetector {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLossReporterEntry {
    inner: CResource<aeron_loss_reporter_entry_t>,
}
impl core::fmt::Debug for AeronLossReporterEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLossReporterEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLossReporterEntry))
                .field("inner", &self.inner)
                .field(stringify!(observation_count), &self.observation_count())
                .field(stringify!(total_bytes_lost), &self.total_bytes_lost())
                .field(
                    stringify!(first_observation_timestamp),
                    &self.first_observation_timestamp(),
                )
                .field(
                    stringify!(last_observation_timestamp),
                    &self.last_observation_timestamp(),
                )
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .finish()
        }
    }
}
impl AeronLossReporterEntry {
    #[inline]
    pub fn new(
        observation_count: i64,
        total_bytes_lost: i64,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        session_id: i32,
        stream_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_loss_reporter_entry_t {
                    observation_count: observation_count.into(),
                    total_bytes_lost: total_bytes_lost.into(),
                    first_observation_timestamp: first_observation_timestamp.into(),
                    last_observation_timestamp: last_observation_timestamp.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                };
                let inner_ptr: *mut aeron_loss_reporter_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_loss_reporter_entry_t)
                );
                let inst: aeron_loss_reporter_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_loss_reporter_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_loss_reporter_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn observation_count(&self) -> i64 {
        self.observation_count.into()
    }
    #[inline]
    pub fn total_bytes_lost(&self) -> i64 {
        self.total_bytes_lost.into()
    }
    #[inline]
    pub fn first_observation_timestamp(&self) -> i64 {
        self.first_observation_timestamp.into()
    }
    #[inline]
    pub fn last_observation_timestamp(&self) -> i64 {
        self.last_observation_timestamp.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_loss_reporter_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_loss_reporter_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_loss_reporter_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLossReporterEntry {
    type Target = aeron_loss_reporter_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_loss_reporter_entry_t> for AeronLossReporterEntry {
    #[inline]
    fn from(value: *mut aeron_loss_reporter_entry_t) -> Self {
        AeronLossReporterEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLossReporterEntry> for *mut aeron_loss_reporter_entry_t {
    #[inline]
    fn from(value: AeronLossReporterEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLossReporterEntry> for *mut aeron_loss_reporter_entry_t {
    #[inline]
    fn from(value: &AeronLossReporterEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronLossReporterEntry> for aeron_loss_reporter_entry_t {
    #[inline]
    fn from(value: AeronLossReporterEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_loss_reporter_entry_t> for AeronLossReporterEntry {
    #[inline]
    fn from(value: *const aeron_loss_reporter_entry_t) -> Self {
        AeronLossReporterEntry {
            inner: CResource::Borrowed(value as *mut aeron_loss_reporter_entry_t),
        }
    }
}
impl From<aeron_loss_reporter_entry_t> for AeronLossReporterEntry {
    #[inline]
    fn from(value: aeron_loss_reporter_entry_t) -> Self {
        AeronLossReporterEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLossReporterEntry {
    fn default() -> Self {
        AeronLossReporterEntry::new_zeroed_on_heap()
    }
}
impl AeronLossReporterEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronLossReporter {
    inner: CResource<aeron_loss_reporter_t>,
}
impl core::fmt::Debug for AeronLossReporter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronLossReporter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronLossReporter))
                .field("inner", &self.inner)
                .field(stringify!(next_record_offset), &self.next_record_offset())
                .field(stringify!(capacity), &self.capacity())
                .finish()
        }
    }
}
impl AeronLossReporter {
    #[inline]
    pub fn new(
        buffer: *mut u8,
        next_record_offset: usize,
        capacity: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_loss_reporter_t {
                    buffer: buffer.into(),
                    next_record_offset: next_record_offset.into(),
                    capacity: capacity.into(),
                };
                let inner_ptr: *mut aeron_loss_reporter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_loss_reporter_t)
                );
                let inst: aeron_loss_reporter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_loss_reporter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_loss_reporter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn buffer(&self) -> *mut u8 {
        self.buffer.into()
    }
    #[inline]
    pub fn next_record_offset(&self) -> usize {
        self.next_record_offset.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn init(&self, buffer: &mut [u8]) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_loss_reporter_init(self.get_inner(), buffer.as_ptr() as *mut _, buffer.len());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn create_entry(
        &self,
        initial_bytes_lost: i64,
        timestamp_ms: i64,
        session_id: i32,
        stream_id: i32,
        channel: &str,
        source: &str,
    ) -> aeron_loss_reporter_entry_offset_t {
        unsafe {
            let result = aeron_loss_reporter_create_entry(
                self.get_inner(),
                initial_bytes_lost.into(),
                timestamp_ms.into(),
                session_id.into(),
                stream_id.into(),
                channel.as_ptr() as *const _,
                channel.len(),
                source.as_ptr() as *const _,
                source.len(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn record_observation(
        &self,
        offset: aeron_loss_reporter_entry_offset_t,
        bytes_lost: i64,
        timestamp_ms: i64,
    ) -> () {
        unsafe {
            let result = aeron_loss_reporter_record_observation(
                self.get_inner(),
                offset.into(),
                bytes_lost.into(),
                timestamp_ms.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn resolve_filename(
        directory: &std::ffi::CStr,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_loss_reporter_resolve_filename(
                directory.as_ptr(),
                filename_buffer.into(),
                filename_buffer_length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn read<
        AeronLossReporterReadEntryFuncHandlerImpl: AeronLossReporterReadEntryFuncCallback,
    >(
        buffer: *const u8,
        capacity: usize,
        entry_func: Option<&Handler<AeronLossReporterReadEntryFuncHandlerImpl>>,
    ) -> usize {
        unsafe {
            let result = aeron_loss_reporter_read(
                buffer.into(),
                capacity.into(),
                {
                    let callback: aeron_loss_reporter_read_entry_func_t = if entry_func.is_none() {
                        None
                    } else {
                        Some(
                            aeron_loss_reporter_read_entry_func_t_callback::<
                                AeronLossReporterReadEntryFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                entry_func
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn read_once<
        AeronLossReporterReadEntryFuncHandlerImpl: FnMut(i64, i64, i64, i64, i32, i32, &str, &str) -> (),
    >(
        buffer: *const u8,
        capacity: usize,
        mut entry_func: AeronLossReporterReadEntryFuncHandlerImpl,
    ) -> usize {
        unsafe {
            let result = aeron_loss_reporter_read(
                buffer.into(),
                capacity.into(),
                Some(
                    aeron_loss_reporter_read_entry_func_t_callback_for_once_closure::<
                        AeronLossReporterReadEntryFuncHandlerImpl,
                    >,
                ),
                &mut entry_func as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_loss_reporter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_loss_reporter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_loss_reporter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronLossReporter {
    type Target = aeron_loss_reporter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_loss_reporter_t> for AeronLossReporter {
    #[inline]
    fn from(value: *mut aeron_loss_reporter_t) -> Self {
        AeronLossReporter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronLossReporter> for *mut aeron_loss_reporter_t {
    #[inline]
    fn from(value: AeronLossReporter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronLossReporter> for *mut aeron_loss_reporter_t {
    #[inline]
    fn from(value: &AeronLossReporter) -> Self {
        value.get_inner()
    }
}
impl From<AeronLossReporter> for aeron_loss_reporter_t {
    #[inline]
    fn from(value: AeronLossReporter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_loss_reporter_t> for AeronLossReporter {
    #[inline]
    fn from(value: *const aeron_loss_reporter_t) -> Self {
        AeronLossReporter {
            inner: CResource::Borrowed(value as *mut aeron_loss_reporter_t),
        }
    }
}
impl From<aeron_loss_reporter_t> for AeronLossReporter {
    #[inline]
    fn from(value: aeron_loss_reporter_t) -> Self {
        AeronLossReporter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronLossReporter {
    fn default() -> Self {
        AeronLossReporter::new_zeroed_on_heap()
    }
}
impl AeronLossReporter {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronMappedBuffer {
    inner: CResource<aeron_mapped_buffer_t>,
}
impl core::fmt::Debug for AeronMappedBuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronMappedBuffer))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronMappedBuffer))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronMappedBuffer {
    #[inline]
    pub fn new(addr: &mut [u8]) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_mapped_buffer_t {
                    addr: addr.as_ptr() as *mut _,
                    length: addr.len(),
                };
                let inner_ptr: *mut aeron_mapped_buffer_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_mapped_buffer_t)
                );
                let inst: aeron_mapped_buffer_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_mapped_buffer_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_mapped_buffer_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn addr(&self) -> &mut [u8] {
        unsafe {
            if self.addr.is_null() {
                &mut [] as &mut [_]
            } else {
                std::slice::from_raw_parts_mut(self.addr, self.length.try_into().unwrap())
            }
        }
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_mapped_buffer_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_mapped_buffer_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_mapped_buffer_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronMappedBuffer {
    type Target = aeron_mapped_buffer_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_mapped_buffer_t> for AeronMappedBuffer {
    #[inline]
    fn from(value: *mut aeron_mapped_buffer_t) -> Self {
        AeronMappedBuffer {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronMappedBuffer> for *mut aeron_mapped_buffer_t {
    #[inline]
    fn from(value: AeronMappedBuffer) -> Self {
        value.get_inner()
    }
}
impl From<&AeronMappedBuffer> for *mut aeron_mapped_buffer_t {
    #[inline]
    fn from(value: &AeronMappedBuffer) -> Self {
        value.get_inner()
    }
}
impl From<AeronMappedBuffer> for aeron_mapped_buffer_t {
    #[inline]
    fn from(value: AeronMappedBuffer) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_mapped_buffer_t> for AeronMappedBuffer {
    #[inline]
    fn from(value: *const aeron_mapped_buffer_t) -> Self {
        AeronMappedBuffer {
            inner: CResource::Borrowed(value as *mut aeron_mapped_buffer_t),
        }
    }
}
impl From<aeron_mapped_buffer_t> for AeronMappedBuffer {
    #[inline]
    fn from(value: aeron_mapped_buffer_t) -> Self {
        AeronMappedBuffer {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronMappedBuffer {
    fn default() -> Self {
        AeronMappedBuffer::new_zeroed_on_heap()
    }
}
impl AeronMappedBuffer {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronMappedFile {
    inner: CResource<aeron_mapped_file_t>,
}
impl core::fmt::Debug for AeronMappedFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronMappedFile))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronMappedFile))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronMappedFile {
    #[inline]
    pub fn new(addr: *mut ::std::os::raw::c_void, length: usize) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_mapped_file_t {
                    addr: addr.into(),
                    length: length.into(),
                };
                let inner_ptr: *mut aeron_mapped_file_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_mapped_file_t)
                );
                let inst: aeron_mapped_file_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_mapped_file_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_mapped_file_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn addr(&self) -> *mut ::std::os::raw::c_void {
        self.addr.into()
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline]
    pub fn aeron_map_new_file(
        &self,
        path: &std::ffi::CStr,
        fill_with_zeroes: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_map_new_file(self.get_inner(), path.as_ptr(), fill_with_zeroes.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_map_existing_file(&self, path: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_map_existing_file(self.get_inner(), path.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_unmap(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_unmap(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_is_driver_active_with_cnc(
        &self,
        timeout_ms: i64,
        now_ms: i64,
        log_func: aeron_log_func_t,
    ) -> bool {
        unsafe {
            let result = aeron_is_driver_active_with_cnc(
                self.get_inner(),
                timeout_ms.into(),
                now_ms.into(),
                log_func.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_mapped_file_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_mapped_file_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_mapped_file_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronMappedFile {
    type Target = aeron_mapped_file_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_mapped_file_t> for AeronMappedFile {
    #[inline]
    fn from(value: *mut aeron_mapped_file_t) -> Self {
        AeronMappedFile {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronMappedFile> for *mut aeron_mapped_file_t {
    #[inline]
    fn from(value: AeronMappedFile) -> Self {
        value.get_inner()
    }
}
impl From<&AeronMappedFile> for *mut aeron_mapped_file_t {
    #[inline]
    fn from(value: &AeronMappedFile) -> Self {
        value.get_inner()
    }
}
impl From<AeronMappedFile> for aeron_mapped_file_t {
    #[inline]
    fn from(value: AeronMappedFile) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_mapped_file_t> for AeronMappedFile {
    #[inline]
    fn from(value: *const aeron_mapped_file_t) -> Self {
        AeronMappedFile {
            inner: CResource::Borrowed(value as *mut aeron_mapped_file_t),
        }
    }
}
impl From<aeron_mapped_file_t> for AeronMappedFile {
    #[inline]
    fn from(value: aeron_mapped_file_t) -> Self {
        AeronMappedFile {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronMappedFile {
    fn default() -> Self {
        AeronMappedFile::new_zeroed_on_heap()
    }
}
impl AeronMappedFile {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronMappedRawLog {
    inner: CResource<aeron_mapped_raw_log_t>,
}
impl core::fmt::Debug for AeronMappedRawLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronMappedRawLog))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronMappedRawLog))
                .field("inner", &self.inner)
                .field(stringify!(log_meta_data), &self.log_meta_data())
                .field(stringify!(mapped_file), &self.mapped_file())
                .field(stringify!(term_length), &self.term_length())
                .finish()
        }
    }
}
impl AeronMappedRawLog {
    #[inline]
    pub fn new(
        term_buffers: [aeron_mapped_buffer_t; 3usize],
        log_meta_data: AeronMappedBuffer,
        mapped_file: AeronMappedFile,
        term_length: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_mapped_raw_log_t {
                    term_buffers: term_buffers.into(),
                    log_meta_data: log_meta_data.into(),
                    mapped_file: mapped_file.into(),
                    term_length: term_length.into(),
                };
                let inner_ptr: *mut aeron_mapped_raw_log_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_mapped_raw_log_t)
                );
                let inst: aeron_mapped_raw_log_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_mapped_raw_log_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_mapped_raw_log_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn term_buffers(&self) -> [aeron_mapped_buffer_t; 3usize] {
        self.term_buffers.into()
    }
    #[inline]
    pub fn log_meta_data(&self) -> AeronMappedBuffer {
        self.log_meta_data.into()
    }
    #[inline]
    pub fn mapped_file(&self) -> AeronMappedFile {
        self.mapped_file.into()
    }
    #[inline]
    pub fn term_length(&self) -> usize {
        self.term_length.into()
    }
    #[inline]
    pub fn aeron_raw_log_map(
        &self,
        path: &std::ffi::CStr,
        use_sparse_files: bool,
        term_length: u64,
        page_size: u64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_raw_log_map(
                self.get_inner(),
                path.as_ptr(),
                use_sparse_files.into(),
                term_length.into(),
                page_size.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_raw_log_map_existing(
        &self,
        path: &std::ffi::CStr,
        pre_touch: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_raw_log_map_existing(self.get_inner(), path.as_ptr(), pre_touch.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_raw_log_close(&self, filename: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_raw_log_close(self.get_inner(), filename.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_raw_log_free(&self, filename: &std::ffi::CStr) -> bool {
        unsafe {
            let result = aeron_raw_log_free(self.get_inner(), filename.as_ptr());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_mapped_raw_log_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_mapped_raw_log_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_mapped_raw_log_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronMappedRawLog {
    type Target = aeron_mapped_raw_log_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_mapped_raw_log_t> for AeronMappedRawLog {
    #[inline]
    fn from(value: *mut aeron_mapped_raw_log_t) -> Self {
        AeronMappedRawLog {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronMappedRawLog> for *mut aeron_mapped_raw_log_t {
    #[inline]
    fn from(value: AeronMappedRawLog) -> Self {
        value.get_inner()
    }
}
impl From<&AeronMappedRawLog> for *mut aeron_mapped_raw_log_t {
    #[inline]
    fn from(value: &AeronMappedRawLog) -> Self {
        value.get_inner()
    }
}
impl From<AeronMappedRawLog> for aeron_mapped_raw_log_t {
    #[inline]
    fn from(value: AeronMappedRawLog) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_mapped_raw_log_t> for AeronMappedRawLog {
    #[inline]
    fn from(value: *const aeron_mapped_raw_log_t) -> Self {
        AeronMappedRawLog {
            inner: CResource::Borrowed(value as *mut aeron_mapped_raw_log_t),
        }
    }
}
impl From<aeron_mapped_raw_log_t> for AeronMappedRawLog {
    #[inline]
    fn from(value: aeron_mapped_raw_log_t) -> Self {
        AeronMappedRawLog {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronMappedRawLog {
    fn default() -> Self {
        AeronMappedRawLog::new_zeroed_on_heap()
    }
}
impl AeronMappedRawLog {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronMpscConcurrentArrayQueue {
    inner: CResource<aeron_mpsc_concurrent_array_queue_t>,
}
impl core::fmt::Debug for AeronMpscConcurrentArrayQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronMpscConcurrentArrayQueue))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronMpscConcurrentArrayQueue))
                .field("inner", &self.inner)
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(mask), &self.mask())
                .finish()
        }
    }
}
impl AeronMpscConcurrentArrayQueue {
    #[inline]
    pub fn new(
        padding: [i8; 56usize],
        producer: aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1,
        consumer: aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2,
        capacity: usize,
        mask: usize,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_mpsc_concurrent_array_queue_t {
                    padding: padding.into(),
                    producer: producer.into(),
                    consumer: consumer.into(),
                    capacity: capacity.into(),
                    mask: mask.into(),
                    buffer: buffer.into(),
                };
                let inner_ptr: *mut aeron_mpsc_concurrent_array_queue_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_mpsc_concurrent_array_queue_t)
                );
                let inst: aeron_mpsc_concurrent_array_queue_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_mpsc_concurrent_array_queue_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_mpsc_concurrent_array_queue_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding(&self) -> [i8; 56usize] {
        self.padding.into()
    }
    #[inline]
    pub fn producer(&self) -> aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1 {
        self.producer.into()
    }
    #[inline]
    pub fn consumer(&self) -> aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2 {
        self.consumer.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn mask(&self) -> usize {
        self.mask.into()
    }
    #[inline]
    pub fn buffer(&self) -> *mut *mut ::std::os::raw::c_void {
        self.buffer.into()
    }
    #[inline]
    pub fn init(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_mpsc_concurrent_array_queue_init(self.get_inner(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_mpsc_concurrent_array_queue_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_mpsc_concurrent_array_queue_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_mpsc_concurrent_array_queue_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_mpsc_concurrent_array_queue_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronMpscConcurrentArrayQueue {
    type Target = aeron_mpsc_concurrent_array_queue_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_mpsc_concurrent_array_queue_t> for AeronMpscConcurrentArrayQueue {
    #[inline]
    fn from(value: *mut aeron_mpsc_concurrent_array_queue_t) -> Self {
        AeronMpscConcurrentArrayQueue {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronMpscConcurrentArrayQueue> for *mut aeron_mpsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: AeronMpscConcurrentArrayQueue) -> Self {
        value.get_inner()
    }
}
impl From<&AeronMpscConcurrentArrayQueue> for *mut aeron_mpsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: &AeronMpscConcurrentArrayQueue) -> Self {
        value.get_inner()
    }
}
impl From<AeronMpscConcurrentArrayQueue> for aeron_mpsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: AeronMpscConcurrentArrayQueue) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_mpsc_concurrent_array_queue_t> for AeronMpscConcurrentArrayQueue {
    #[inline]
    fn from(value: *const aeron_mpsc_concurrent_array_queue_t) -> Self {
        AeronMpscConcurrentArrayQueue {
            inner: CResource::Borrowed(value as *mut aeron_mpsc_concurrent_array_queue_t),
        }
    }
}
impl From<aeron_mpsc_concurrent_array_queue_t> for AeronMpscConcurrentArrayQueue {
    #[inline]
    fn from(value: aeron_mpsc_concurrent_array_queue_t) -> Self {
        AeronMpscConcurrentArrayQueue {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronMpscConcurrentArrayQueue {
    fn default() -> Self {
        AeronMpscConcurrentArrayQueue::new_zeroed_on_heap()
    }
}
impl AeronMpscConcurrentArrayQueue {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronMpscRb {
    inner: CResource<aeron_mpsc_rb_t>,
}
impl core::fmt::Debug for AeronMpscRb {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronMpscRb))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronMpscRb))
                .field("inner", &self.inner)
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(max_message_length), &self.max_message_length())
                .finish()
        }
    }
}
impl AeronMpscRb {
    #[inline]
    pub fn new(
        buffer: *mut u8,
        descriptor: &AeronRbDescriptor,
        capacity: usize,
        max_message_length: usize,
    ) -> Result<Self, AeronCError> {
        let descriptor_copy = descriptor.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_mpsc_rb_t {
                    buffer: buffer.into(),
                    descriptor: descriptor.into(),
                    capacity: capacity.into(),
                    max_message_length: max_message_length.into(),
                };
                let inner_ptr: *mut aeron_mpsc_rb_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_mpsc_rb_t)
                );
                let inst: aeron_mpsc_rb_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_mpsc_rb_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_mpsc_rb_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn buffer(&self) -> *mut u8 {
        self.buffer.into()
    }
    #[inline]
    pub fn descriptor(&self) -> AeronRbDescriptor {
        self.descriptor.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn max_message_length(&self) -> usize {
        self.max_message_length.into()
    }
    #[inline]
    pub fn init(
        &self,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_mpsc_rb_init(self.get_inner(), buffer.into(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn write(
        &self,
        msg_type_id: i32,
        msg: *const ::std::os::raw::c_void,
        length: usize,
    ) -> aeron_rb_write_result_t {
        unsafe {
            let result = aeron_mpsc_rb_write(
                self.get_inner(),
                msg_type_id.into(),
                msg.into(),
                length.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn try_claim(&self, msg_type_id: i32, length: usize) -> i32 {
        unsafe {
            let result =
                aeron_mpsc_rb_try_claim(self.get_inner(), msg_type_id.into(), length.into());
            result.into()
        }
    }
    #[inline]
    pub fn commit(&self, offset: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_mpsc_rb_commit(self.get_inner(), offset.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn abort(&self, offset: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_mpsc_rb_abort(self.get_inner(), offset.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn read<AeronRbHandlerHandlerImpl: AeronRbHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronRbHandlerHandlerImpl>>,
        message_count_limit: usize,
    ) -> usize {
        unsafe {
            let result = aeron_mpsc_rb_read(
                self.get_inner(),
                {
                    let callback: aeron_rb_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_rb_handler_t_callback::<AeronRbHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                message_count_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn read_once<
        AeronRbHandlerHandlerImpl: FnMut(i32, *const ::std::os::raw::c_void, usize) -> (),
    >(
        &self,
        mut handler: AeronRbHandlerHandlerImpl,
        message_count_limit: usize,
    ) -> usize {
        unsafe {
            let result = aeron_mpsc_rb_read(
                self.get_inner(),
                Some(aeron_rb_handler_t_callback_for_once_closure::<AeronRbHandlerHandlerImpl>),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                message_count_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn controlled_read<
        AeronRbControlledHandlerHandlerImpl: AeronRbControlledHandlerCallback,
    >(
        &self,
        handler: Option<&Handler<AeronRbControlledHandlerHandlerImpl>>,
        message_count_limit: usize,
    ) -> usize {
        unsafe {
            let result = aeron_mpsc_rb_controlled_read(
                self.get_inner(),
                {
                    let callback: aeron_rb_controlled_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_rb_controlled_handler_t_callback::<
                                AeronRbControlledHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                message_count_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn controlled_read_once<
        AeronRbControlledHandlerHandlerImpl: FnMut(i32, *const ::std::os::raw::c_void, usize) -> aeron_rb_read_action_t,
    >(
        &self,
        mut handler: AeronRbControlledHandlerHandlerImpl,
        message_count_limit: usize,
    ) -> usize {
        unsafe {
            let result = aeron_mpsc_rb_controlled_read(
                self.get_inner(),
                Some(
                    aeron_rb_controlled_handler_t_callback_for_once_closure::<
                        AeronRbControlledHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                message_count_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn next_correlation_id(&self) -> i64 {
        unsafe {
            let result = aeron_mpsc_rb_next_correlation_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn consumer_heartbeat_time(&self, now_ms: i64) -> () {
        unsafe {
            let result = aeron_mpsc_rb_consumer_heartbeat_time(self.get_inner(), now_ms.into());
            result.into()
        }
    }
    #[inline]
    pub fn consumer_heartbeat_time_value(&self) -> i64 {
        unsafe {
            let result = aeron_mpsc_rb_consumer_heartbeat_time_value(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn unblock(&self) -> bool {
        unsafe {
            let result = aeron_mpsc_rb_unblock(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_mpsc_rb_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_mpsc_rb_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_mpsc_rb_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronMpscRb {
    type Target = aeron_mpsc_rb_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_mpsc_rb_t> for AeronMpscRb {
    #[inline]
    fn from(value: *mut aeron_mpsc_rb_t) -> Self {
        AeronMpscRb {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronMpscRb> for *mut aeron_mpsc_rb_t {
    #[inline]
    fn from(value: AeronMpscRb) -> Self {
        value.get_inner()
    }
}
impl From<&AeronMpscRb> for *mut aeron_mpsc_rb_t {
    #[inline]
    fn from(value: &AeronMpscRb) -> Self {
        value.get_inner()
    }
}
impl From<AeronMpscRb> for aeron_mpsc_rb_t {
    #[inline]
    fn from(value: AeronMpscRb) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_mpsc_rb_t> for AeronMpscRb {
    #[inline]
    fn from(value: *const aeron_mpsc_rb_t) -> Self {
        AeronMpscRb {
            inner: CResource::Borrowed(value as *mut aeron_mpsc_rb_t),
        }
    }
}
impl From<aeron_mpsc_rb_t> for AeronMpscRb {
    #[inline]
    fn from(value: aeron_mpsc_rb_t) -> Self {
        AeronMpscRb {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronMpscRb {
    fn default() -> Self {
        AeronMpscRb::new_zeroed_on_heap()
    }
}
impl AeronMpscRb {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronNakHeader {
    inner: CResource<aeron_nak_header_t>,
}
impl core::fmt::Debug for AeronNakHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronNakHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronNakHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronNakHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        session_id: i32,
        stream_id: i32,
        term_id: i32,
        term_offset: i32,
        length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_nak_header_t {
                    frame_header: frame_header.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    term_id: term_id.into(),
                    term_offset: term_offset.into(),
                    length: length.into(),
                };
                let inner_ptr: *mut aeron_nak_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_nak_header_t)
                );
                let inst: aeron_nak_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_nak_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_nak_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn length(&self) -> i32 {
        self.length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_nak_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_nak_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_nak_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronNakHeader {
    type Target = aeron_nak_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_nak_header_t> for AeronNakHeader {
    #[inline]
    fn from(value: *mut aeron_nak_header_t) -> Self {
        AeronNakHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronNakHeader> for *mut aeron_nak_header_t {
    #[inline]
    fn from(value: AeronNakHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronNakHeader> for *mut aeron_nak_header_t {
    #[inline]
    fn from(value: &AeronNakHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronNakHeader> for aeron_nak_header_t {
    #[inline]
    fn from(value: AeronNakHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_nak_header_t> for AeronNakHeader {
    #[inline]
    fn from(value: *const aeron_nak_header_t) -> Self {
        AeronNakHeader {
            inner: CResource::Borrowed(value as *mut aeron_nak_header_t),
        }
    }
}
impl From<aeron_nak_header_t> for AeronNakHeader {
    #[inline]
    fn from(value: aeron_nak_header_t) -> Self {
        AeronNakHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronNakHeader {
    fn default() -> Self {
        AeronNakHeader::new_zeroed_on_heap()
    }
}
impl AeronNakHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronNetworkPublicationEntry {
    inner: CResource<aeron_network_publication_entry_t>,
}
impl core::fmt::Debug for AeronNetworkPublicationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronNetworkPublicationEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronNetworkPublicationEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronNetworkPublicationEntry {
    #[inline]
    pub fn new(publication: &AeronNetworkPublication) -> Result<Self, AeronCError> {
        let publication_copy = publication.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_network_publication_entry_t {
                    publication: publication.into(),
                };
                let inner_ptr: *mut aeron_network_publication_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_network_publication_entry_t)
                );
                let inst: aeron_network_publication_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_network_publication_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_network_publication_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn publication(&self) -> AeronNetworkPublication {
        self.publication.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_network_publication_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_network_publication_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_network_publication_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronNetworkPublicationEntry {
    type Target = aeron_network_publication_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_network_publication_entry_t> for AeronNetworkPublicationEntry {
    #[inline]
    fn from(value: *mut aeron_network_publication_entry_t) -> Self {
        AeronNetworkPublicationEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronNetworkPublicationEntry> for *mut aeron_network_publication_entry_t {
    #[inline]
    fn from(value: AeronNetworkPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronNetworkPublicationEntry> for *mut aeron_network_publication_entry_t {
    #[inline]
    fn from(value: &AeronNetworkPublicationEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronNetworkPublicationEntry> for aeron_network_publication_entry_t {
    #[inline]
    fn from(value: AeronNetworkPublicationEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_network_publication_entry_t> for AeronNetworkPublicationEntry {
    #[inline]
    fn from(value: *const aeron_network_publication_entry_t) -> Self {
        AeronNetworkPublicationEntry {
            inner: CResource::Borrowed(value as *mut aeron_network_publication_entry_t),
        }
    }
}
impl From<aeron_network_publication_entry_t> for AeronNetworkPublicationEntry {
    #[inline]
    fn from(value: aeron_network_publication_entry_t) -> Self {
        AeronNetworkPublicationEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronNetworkPublicationEntry {
    fn default() -> Self {
        AeronNetworkPublicationEntry::new_zeroed_on_heap()
    }
}
impl AeronNetworkPublicationEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronNetworkPublication {
    inner: CResource<aeron_network_publication_t>,
}
impl core::fmt::Debug for AeronNetworkPublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronNetworkPublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronNetworkPublication))
                .field("inner", &self.inner)
                .field(stringify!(mapped_raw_log), &self.mapped_raw_log())
                .field(stringify!(pub_pos_position), &self.pub_pos_position())
                .field(stringify!(pub_lmt_position), &self.pub_lmt_position())
                .field(stringify!(snd_pos_position), &self.snd_pos_position())
                .field(stringify!(snd_lmt_position), &self.snd_lmt_position())
                .field(stringify!(snd_bpe_counter), &self.snd_bpe_counter())
                .field(
                    stringify!(snd_naks_received_counter),
                    &self.snd_naks_received_counter(),
                )
                .field(stringify!(retransmit_handler), &self.retransmit_handler())
                .field(
                    stringify!(has_initial_connection),
                    &self.has_initial_connection(),
                )
                .field(stringify!(track_sender_limits), &self.track_sender_limits())
                .field(
                    stringify!(time_of_last_data_or_heartbeat_ns),
                    &self.time_of_last_data_or_heartbeat_ns(),
                )
                .field(
                    stringify!(current_messages_per_send),
                    &self.current_messages_per_send(),
                )
                .field(
                    stringify!(status_message_deadline_ns),
                    &self.status_message_deadline_ns(),
                )
                .field(
                    stringify!(time_of_last_setup_ns),
                    &self.time_of_last_setup_ns(),
                )
                .field(stringify!(endpoint_address), &self.endpoint_address())
                .field(stringify!(term_buffer_length), &self.term_buffer_length())
                .field(stringify!(term_window_length), &self.term_window_length())
                .field(stringify!(trip_gain), &self.trip_gain())
                .field(stringify!(linger_timeout_ns), &self.linger_timeout_ns())
                .field(stringify!(unblock_timeout_ns), &self.unblock_timeout_ns())
                .field(
                    stringify!(connection_timeout_ns),
                    &self.connection_timeout_ns(),
                )
                .field(
                    stringify!(untethered_window_limit_timeout_ns),
                    &self.untethered_window_limit_timeout_ns(),
                )
                .field(
                    stringify!(untethered_linger_timeout_ns),
                    &self.untethered_linger_timeout_ns(),
                )
                .field(
                    stringify!(untethered_resting_timeout_ns),
                    &self.untethered_resting_timeout_ns(),
                )
                .field(stringify!(tag), &self.tag())
                .field(
                    stringify!(response_correlation_id),
                    &self.response_correlation_id(),
                )
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(stringify!(starting_term_id), &self.starting_term_id())
                .field(stringify!(term_length_mask), &self.term_length_mask())
                .field(
                    stringify!(starting_term_offset),
                    &self.starting_term_offset(),
                )
                .field(
                    stringify!(log_file_name_length),
                    &self.log_file_name_length(),
                )
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(
                    stringify!(max_messages_per_send),
                    &self.max_messages_per_send(),
                )
                .field(
                    stringify!(spies_simulate_connection),
                    &self.spies_simulate_connection(),
                )
                .field(stringify!(signal_eos), &self.signal_eos())
                .field(stringify!(is_setup_elicited), &self.is_setup_elicited())
                .field(stringify!(is_exclusive), &self.is_exclusive())
                .field(stringify!(is_response), &self.is_response())
                .field(stringify!(has_receivers), &self.has_receivers())
                .field(stringify!(has_spies), &self.has_spies())
                .field(stringify!(is_connected), &self.is_connected())
                .field(stringify!(is_end_of_stream), &self.is_end_of_stream())
                .field(stringify!(has_sender_released), &self.has_sender_released())
                .field(
                    stringify!(has_received_unicast_eos),
                    &self.has_received_unicast_eos(),
                )
                .field(
                    stringify!(receiver_liveness_tracker),
                    &self.receiver_liveness_tracker(),
                )
                .finish()
        }
    }
}
impl AeronNetworkPublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_network_publication_t)
                );
                let inst: aeron_network_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_network_publication_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_network_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn conductor_fields_pad(&self) -> [u8; 120usize] {
        self.conductor_fields_pad.into()
    }
    #[inline]
    pub fn mapped_raw_log(&self) -> AeronMappedRawLog {
        self.mapped_raw_log.into()
    }
    #[inline]
    pub fn pub_pos_position(&self) -> AeronPosition {
        self.pub_pos_position.into()
    }
    #[inline]
    pub fn pub_lmt_position(&self) -> AeronPosition {
        self.pub_lmt_position.into()
    }
    #[inline]
    pub fn snd_pos_position(&self) -> AeronPosition {
        self.snd_pos_position.into()
    }
    #[inline]
    pub fn snd_lmt_position(&self) -> AeronPosition {
        self.snd_lmt_position.into()
    }
    #[inline]
    pub fn snd_bpe_counter(&self) -> AeronAtomicCounter {
        self.snd_bpe_counter.into()
    }
    #[inline]
    pub fn snd_naks_received_counter(&self) -> AeronAtomicCounter {
        self.snd_naks_received_counter.into()
    }
    #[inline]
    pub fn retransmit_handler(&self) -> AeronRetransmitHandler {
        self.retransmit_handler.into()
    }
    #[inline]
    pub fn log_meta_data(&self) -> AeronLogbufferMetadata {
        self.log_meta_data.into()
    }
    #[inline]
    pub fn endpoint(&self) -> AeronSendChannelEndpoint {
        self.endpoint.into()
    }
    #[inline]
    pub fn flow_control(&self) -> AeronFlowControlStrategy {
        self.flow_control.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn sender_fields_pad_lhs(&self) -> [u8; 64usize] {
        self.sender_fields_pad_lhs.into()
    }
    #[inline]
    pub fn has_initial_connection(&self) -> bool {
        self.has_initial_connection.into()
    }
    #[inline]
    pub fn track_sender_limits(&self) -> bool {
        self.track_sender_limits.into()
    }
    #[inline]
    pub fn time_of_last_data_or_heartbeat_ns(&self) -> i64 {
        self.time_of_last_data_or_heartbeat_ns.into()
    }
    #[inline]
    pub fn current_messages_per_send(&self) -> usize {
        self.current_messages_per_send.into()
    }
    #[inline]
    pub fn status_message_deadline_ns(&self) -> i64 {
        self.status_message_deadline_ns.into()
    }
    #[inline]
    pub fn time_of_last_setup_ns(&self) -> i64 {
        self.time_of_last_setup_ns.into()
    }
    #[inline]
    pub fn sender_fields_pad_rhs(&self) -> [u8; 64usize] {
        self.sender_fields_pad_rhs.into()
    }
    #[inline]
    pub fn endpoint_address(&self) -> SockaddrStorage {
        self.endpoint_address.into()
    }
    #[inline]
    pub fn log_file_name(&self) -> &str {
        if self.log_file_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.log_file_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn term_buffer_length(&self) -> i64 {
        self.term_buffer_length.into()
    }
    #[inline]
    pub fn term_window_length(&self) -> i64 {
        self.term_window_length.into()
    }
    #[inline]
    pub fn trip_gain(&self) -> i64 {
        self.trip_gain.into()
    }
    #[inline]
    pub fn linger_timeout_ns(&self) -> i64 {
        self.linger_timeout_ns.into()
    }
    #[inline]
    pub fn unblock_timeout_ns(&self) -> i64 {
        self.unblock_timeout_ns.into()
    }
    #[inline]
    pub fn connection_timeout_ns(&self) -> i64 {
        self.connection_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_window_limit_timeout_ns(&self) -> i64 {
        self.untethered_window_limit_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_linger_timeout_ns(&self) -> i64 {
        self.untethered_linger_timeout_ns.into()
    }
    #[inline]
    pub fn untethered_resting_timeout_ns(&self) -> i64 {
        self.untethered_resting_timeout_ns.into()
    }
    #[inline]
    pub fn tag(&self) -> i64 {
        self.tag.into()
    }
    #[inline]
    pub fn response_correlation_id(&self) -> i64 {
        self.response_correlation_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn starting_term_id(&self) -> i32 {
        self.starting_term_id.into()
    }
    #[inline]
    pub fn term_length_mask(&self) -> i32 {
        self.term_length_mask.into()
    }
    #[inline]
    pub fn starting_term_offset(&self) -> usize {
        self.starting_term_offset.into()
    }
    #[inline]
    pub fn log_file_name_length(&self) -> usize {
        self.log_file_name_length.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> usize {
        self.mtu_length.into()
    }
    #[inline]
    pub fn max_messages_per_send(&self) -> usize {
        self.max_messages_per_send.into()
    }
    #[inline]
    pub fn spies_simulate_connection(&self) -> bool {
        self.spies_simulate_connection.into()
    }
    #[inline]
    pub fn signal_eos(&self) -> bool {
        self.signal_eos.into()
    }
    #[inline]
    pub fn is_setup_elicited(&self) -> bool {
        self.is_setup_elicited.into()
    }
    #[inline]
    pub fn is_exclusive(&self) -> bool {
        self.is_exclusive.into()
    }
    #[inline]
    pub fn is_response(&self) -> bool {
        self.is_response.into()
    }
    #[inline]
    pub fn has_receivers(&self) -> bool {
        self.has_receivers.into()
    }
    #[inline]
    pub fn has_spies(&self) -> bool {
        self.has_spies.into()
    }
    #[inline]
    pub fn is_connected(&self) -> bool {
        self.is_connected.into()
    }
    #[inline]
    pub fn is_end_of_stream(&self) -> bool {
        self.is_end_of_stream.into()
    }
    #[inline]
    pub fn has_sender_released(&self) -> bool {
        self.has_sender_released.into()
    }
    #[inline]
    pub fn has_received_unicast_eos(&self) -> bool {
        self.has_received_unicast_eos.into()
    }
    #[inline]
    pub fn raw_log_close_func(&self) -> aeron_raw_log_close_func_t {
        self.raw_log_close_func.into()
    }
    #[inline]
    pub fn raw_log_free_func(&self) -> aeron_raw_log_free_func_t {
        self.raw_log_free_func.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_network_publication_stct__bindgen_ty_1 {
        self.log.into()
    }
    #[inline]
    pub fn short_sends_counter(&self) -> &mut i64 {
        unsafe { &mut *self.short_sends_counter }
    }
    #[inline]
    pub fn heartbeats_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.heartbeats_sent_counter }
    }
    #[inline]
    pub fn sender_flow_control_limits_counter(&self) -> &mut i64 {
        unsafe { &mut *self.sender_flow_control_limits_counter }
    }
    #[inline]
    pub fn retransmits_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.retransmits_sent_counter }
    }
    #[inline]
    pub fn retransmitted_bytes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.retransmitted_bytes_counter }
    }
    #[inline]
    pub fn unblocked_publications_counter(&self) -> &mut i64 {
        unsafe { &mut *self.unblocked_publications_counter }
    }
    #[inline]
    pub fn publications_revoked_counter(&self) -> &mut i64 {
        unsafe { &mut *self.publications_revoked_counter }
    }
    #[inline]
    pub fn mapped_bytes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.mapped_bytes_counter }
    }
    #[inline]
    pub fn receiver_liveness_tracker(&self) -> AeronInt64CounterMap {
        self.receiver_liveness_tracker.into()
    }
    #[inline]
    pub fn location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: &std::ffi::CStr,
        correlation_id: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_location(
                dst.into(),
                length.into(),
                aeron_dir.as_ptr(),
                correlation_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn free(&self) -> bool {
        unsafe {
            let result = aeron_network_publication_free(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn send(&self, now_ns: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_send(self.get_inner(), now_ns.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn resend(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_resend(
                clientd.into(),
                term_id.into(),
                term_offset.into(),
                length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_data(
        &self,
        now_ns: i64,
        snd_pos: i64,
        term_offset: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_send_data(
                self.get_inner(),
                now_ns.into(),
                snd_pos.into(),
                term_offset.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_nak(&self, term_id: i32, term_offset: i32, length: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_on_nak(
                self.get_inner(),
                term_id.into(),
                term_offset.into(),
                length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_status_message(
        &self,
        conductor_proxy: &AeronDriverConductorProxy,
        buffer: &[u8],
        addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_on_status_message(
                self.get_inner(),
                conductor_proxy.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_error(
        &self,
        destination_registration_id: i64,
        buffer: &[u8],
        src_address: &SockaddrStorage,
        pStct: &AeronDriverConductorProxy,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_on_error(
                self.get_inner(),
                destination_registration_id.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                src_address.get_inner(),
                pStct.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_rttm(&self, buffer: &[u8], addr: &SockaddrStorage) -> () {
        unsafe {
            let result = aeron_network_publication_on_rttm(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn clean_buffer(&self, position: i64) -> () {
        unsafe {
            let result = aeron_network_publication_clean_buffer(self.get_inner(), position.into());
            result.into()
        }
    }
    #[inline]
    pub fn update_pub_pos_and_lmt(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_network_publication_update_pub_pos_and_lmt(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn check_for_blocked_publisher(
        &self,
        now_ns: i64,
        producer_position: i64,
        snd_pos: i64,
    ) -> () {
        unsafe {
            let result = aeron_network_publication_check_for_blocked_publisher(
                self.get_inner(),
                now_ns.into(),
                producer_position.into(),
                snd_pos.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_network_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_network_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_network_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronNetworkPublication {
    type Target = aeron_network_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_network_publication_t> for AeronNetworkPublication {
    #[inline]
    fn from(value: *mut aeron_network_publication_t) -> Self {
        AeronNetworkPublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronNetworkPublication> for *mut aeron_network_publication_t {
    #[inline]
    fn from(value: AeronNetworkPublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronNetworkPublication> for *mut aeron_network_publication_t {
    #[inline]
    fn from(value: &AeronNetworkPublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronNetworkPublication> for aeron_network_publication_t {
    #[inline]
    fn from(value: AeronNetworkPublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_network_publication_t> for AeronNetworkPublication {
    #[inline]
    fn from(value: *const aeron_network_publication_t) -> Self {
        AeronNetworkPublication {
            inner: CResource::Borrowed(value as *mut aeron_network_publication_t),
        }
    }
}
impl From<aeron_network_publication_t> for AeronNetworkPublication {
    #[inline]
    fn from(value: aeron_network_publication_t) -> Self {
        AeronNetworkPublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronAvailableCounterPair {
    inner: CResource<aeron_on_available_counter_pair_t>,
}
impl core::fmt::Debug for AeronAvailableCounterPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronAvailableCounterPair))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronAvailableCounterPair))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronAvailableCounterPair {
    #[inline]
    pub fn new<AeronAvailableCounterHandlerImpl: AeronAvailableCounterCallback>(
        handler: Option<&Handler<AeronAvailableCounterHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_on_available_counter_pair_t {
                    handler: {
                        let callback: aeron_on_available_counter_t = if handler.is_none() {
                            None
                        } else {
                            Some(
                                aeron_on_available_counter_t_callback::<
                                    AeronAvailableCounterHandlerImpl,
                                >,
                            )
                        };
                        callback
                    },
                    clientd: handler
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                };
                let inner_ptr: *mut aeron_on_available_counter_pair_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_on_available_counter_pair_t)
                );
                let inst: aeron_on_available_counter_pair_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_on_available_counter_pair_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_on_available_counter_pair_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn handler(&self) -> aeron_on_available_counter_t {
        self.handler.into()
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_on_available_counter_pair_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_on_available_counter_pair_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_on_available_counter_pair_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronAvailableCounterPair {
    type Target = aeron_on_available_counter_pair_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_on_available_counter_pair_t> for AeronAvailableCounterPair {
    #[inline]
    fn from(value: *mut aeron_on_available_counter_pair_t) -> Self {
        AeronAvailableCounterPair {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronAvailableCounterPair> for *mut aeron_on_available_counter_pair_t {
    #[inline]
    fn from(value: AeronAvailableCounterPair) -> Self {
        value.get_inner()
    }
}
impl From<&AeronAvailableCounterPair> for *mut aeron_on_available_counter_pair_t {
    #[inline]
    fn from(value: &AeronAvailableCounterPair) -> Self {
        value.get_inner()
    }
}
impl From<AeronAvailableCounterPair> for aeron_on_available_counter_pair_t {
    #[inline]
    fn from(value: AeronAvailableCounterPair) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_on_available_counter_pair_t> for AeronAvailableCounterPair {
    #[inline]
    fn from(value: *const aeron_on_available_counter_pair_t) -> Self {
        AeronAvailableCounterPair {
            inner: CResource::Borrowed(value as *mut aeron_on_available_counter_pair_t),
        }
    }
}
impl From<aeron_on_available_counter_pair_t> for AeronAvailableCounterPair {
    #[inline]
    fn from(value: aeron_on_available_counter_pair_t) -> Self {
        AeronAvailableCounterPair {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronAvailableCounterPair {
    fn default() -> Self {
        AeronAvailableCounterPair::new_zeroed_on_heap()
    }
}
impl AeronAvailableCounterPair {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronCloseClientPair {
    inner: CResource<aeron_on_close_client_pair_t>,
}
impl core::fmt::Debug for AeronCloseClientPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronCloseClientPair))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronCloseClientPair))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronCloseClientPair {
    #[inline]
    pub fn new<AeronCloseClientHandlerImpl: AeronCloseClientCallback>(
        handler: Option<&Handler<AeronCloseClientHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_on_close_client_pair_t {
                    handler: {
                        let callback: aeron_on_close_client_t = if handler.is_none() {
                            None
                        } else {
                            Some(aeron_on_close_client_t_callback::<AeronCloseClientHandlerImpl>)
                        };
                        callback
                    },
                    clientd: handler
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                };
                let inner_ptr: *mut aeron_on_close_client_pair_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_on_close_client_pair_t)
                );
                let inst: aeron_on_close_client_pair_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_on_close_client_pair_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_on_close_client_pair_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn handler(&self) -> aeron_on_close_client_t {
        self.handler.into()
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_on_close_client_pair_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_on_close_client_pair_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_on_close_client_pair_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronCloseClientPair {
    type Target = aeron_on_close_client_pair_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_on_close_client_pair_t> for AeronCloseClientPair {
    #[inline]
    fn from(value: *mut aeron_on_close_client_pair_t) -> Self {
        AeronCloseClientPair {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronCloseClientPair> for *mut aeron_on_close_client_pair_t {
    #[inline]
    fn from(value: AeronCloseClientPair) -> Self {
        value.get_inner()
    }
}
impl From<&AeronCloseClientPair> for *mut aeron_on_close_client_pair_t {
    #[inline]
    fn from(value: &AeronCloseClientPair) -> Self {
        value.get_inner()
    }
}
impl From<AeronCloseClientPair> for aeron_on_close_client_pair_t {
    #[inline]
    fn from(value: AeronCloseClientPair) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_on_close_client_pair_t> for AeronCloseClientPair {
    #[inline]
    fn from(value: *const aeron_on_close_client_pair_t) -> Self {
        AeronCloseClientPair {
            inner: CResource::Borrowed(value as *mut aeron_on_close_client_pair_t),
        }
    }
}
impl From<aeron_on_close_client_pair_t> for AeronCloseClientPair {
    #[inline]
    fn from(value: aeron_on_close_client_pair_t) -> Self {
        AeronCloseClientPair {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronCloseClientPair {
    fn default() -> Self {
        AeronCloseClientPair::new_zeroed_on_heap()
    }
}
impl AeronCloseClientPair {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUnavailableCounterPair {
    inner: CResource<aeron_on_unavailable_counter_pair_t>,
}
impl core::fmt::Debug for AeronUnavailableCounterPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUnavailableCounterPair))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUnavailableCounterPair))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUnavailableCounterPair {
    #[inline]
    pub fn new<AeronUnavailableCounterHandlerImpl: AeronUnavailableCounterCallback>(
        handler: Option<&Handler<AeronUnavailableCounterHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_on_unavailable_counter_pair_t {
                    handler: {
                        let callback: aeron_on_unavailable_counter_t = if handler.is_none() {
                            None
                        } else {
                            Some(
                                aeron_on_unavailable_counter_t_callback::<
                                    AeronUnavailableCounterHandlerImpl,
                                >,
                            )
                        };
                        callback
                    },
                    clientd: handler
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                };
                let inner_ptr: *mut aeron_on_unavailable_counter_pair_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_on_unavailable_counter_pair_t)
                );
                let inst: aeron_on_unavailable_counter_pair_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_on_unavailable_counter_pair_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_on_unavailable_counter_pair_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn handler(&self) -> aeron_on_unavailable_counter_t {
        self.handler.into()
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_on_unavailable_counter_pair_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_on_unavailable_counter_pair_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_on_unavailable_counter_pair_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUnavailableCounterPair {
    type Target = aeron_on_unavailable_counter_pair_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_on_unavailable_counter_pair_t> for AeronUnavailableCounterPair {
    #[inline]
    fn from(value: *mut aeron_on_unavailable_counter_pair_t) -> Self {
        AeronUnavailableCounterPair {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUnavailableCounterPair> for *mut aeron_on_unavailable_counter_pair_t {
    #[inline]
    fn from(value: AeronUnavailableCounterPair) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUnavailableCounterPair> for *mut aeron_on_unavailable_counter_pair_t {
    #[inline]
    fn from(value: &AeronUnavailableCounterPair) -> Self {
        value.get_inner()
    }
}
impl From<AeronUnavailableCounterPair> for aeron_on_unavailable_counter_pair_t {
    #[inline]
    fn from(value: AeronUnavailableCounterPair) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_on_unavailable_counter_pair_t> for AeronUnavailableCounterPair {
    #[inline]
    fn from(value: *const aeron_on_unavailable_counter_pair_t) -> Self {
        AeronUnavailableCounterPair {
            inner: CResource::Borrowed(value as *mut aeron_on_unavailable_counter_pair_t),
        }
    }
}
impl From<aeron_on_unavailable_counter_pair_t> for AeronUnavailableCounterPair {
    #[inline]
    fn from(value: aeron_on_unavailable_counter_pair_t) -> Self {
        AeronUnavailableCounterPair {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUnavailableCounterPair {
    fn default() -> Self {
        AeronUnavailableCounterPair::new_zeroed_on_heap()
    }
}
impl AeronUnavailableCounterPair {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronOperationSucceeded {
    inner: CResource<aeron_operation_succeeded_t>,
}
impl core::fmt::Debug for AeronOperationSucceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronOperationSucceeded))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronOperationSucceeded))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .finish()
        }
    }
}
impl AeronOperationSucceeded {
    #[inline]
    pub fn new(correlation_id: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_operation_succeeded_t {
                    correlation_id: correlation_id.into(),
                };
                let inner_ptr: *mut aeron_operation_succeeded_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_operation_succeeded_t)
                );
                let inst: aeron_operation_succeeded_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_operation_succeeded_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_operation_succeeded_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_operation_succeeded_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_operation_succeeded_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_operation_succeeded_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronOperationSucceeded {
    type Target = aeron_operation_succeeded_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_operation_succeeded_t> for AeronOperationSucceeded {
    #[inline]
    fn from(value: *mut aeron_operation_succeeded_t) -> Self {
        AeronOperationSucceeded {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronOperationSucceeded> for *mut aeron_operation_succeeded_t {
    #[inline]
    fn from(value: AeronOperationSucceeded) -> Self {
        value.get_inner()
    }
}
impl From<&AeronOperationSucceeded> for *mut aeron_operation_succeeded_t {
    #[inline]
    fn from(value: &AeronOperationSucceeded) -> Self {
        value.get_inner()
    }
}
impl From<AeronOperationSucceeded> for aeron_operation_succeeded_t {
    #[inline]
    fn from(value: AeronOperationSucceeded) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_operation_succeeded_t> for AeronOperationSucceeded {
    #[inline]
    fn from(value: *const aeron_operation_succeeded_t) -> Self {
        AeronOperationSucceeded {
            inner: CResource::Borrowed(value as *mut aeron_operation_succeeded_t),
        }
    }
}
impl From<aeron_operation_succeeded_t> for AeronOperationSucceeded {
    #[inline]
    fn from(value: aeron_operation_succeeded_t) -> Self {
        AeronOperationSucceeded {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronOperationSucceeded {
    fn default() -> Self {
        AeronOperationSucceeded::new_zeroed_on_heap()
    }
}
impl AeronOperationSucceeded {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronOptionHeader {
    inner: CResource<aeron_option_header_t>,
}
impl core::fmt::Debug for AeronOptionHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronOptionHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronOptionHeader))
                .field("inner", &self.inner)
                .field(stringify!(option_length), &self.option_length())
                .field(stringify!(type_), &self.type_())
                .finish()
        }
    }
}
impl AeronOptionHeader {
    #[inline]
    pub fn new(option_length: u16, type_: u16) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_option_header_t {
                    option_length: option_length.into(),
                    type_: type_.into(),
                };
                let inner_ptr: *mut aeron_option_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_option_header_t)
                );
                let inst: aeron_option_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_option_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_option_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn option_length(&self) -> u16 {
        self.option_length.into()
    }
    #[inline]
    pub fn type_(&self) -> u16 {
        self.type_.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_option_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_option_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_option_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronOptionHeader {
    type Target = aeron_option_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_option_header_t> for AeronOptionHeader {
    #[inline]
    fn from(value: *mut aeron_option_header_t) -> Self {
        AeronOptionHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronOptionHeader> for *mut aeron_option_header_t {
    #[inline]
    fn from(value: AeronOptionHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronOptionHeader> for *mut aeron_option_header_t {
    #[inline]
    fn from(value: &AeronOptionHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronOptionHeader> for aeron_option_header_t {
    #[inline]
    fn from(value: AeronOptionHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_option_header_t> for AeronOptionHeader {
    #[inline]
    fn from(value: *const aeron_option_header_t) -> Self {
        AeronOptionHeader {
            inner: CResource::Borrowed(value as *mut aeron_option_header_t),
        }
    }
}
impl From<aeron_option_header_t> for AeronOptionHeader {
    #[inline]
    fn from(value: aeron_option_header_t) -> Self {
        AeronOptionHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronOptionHeader {
    fn default() -> Self {
        AeronOptionHeader::new_zeroed_on_heap()
    }
}
impl AeronOptionHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronParsedAddress {
    inner: CResource<aeron_parsed_address_t>,
}
impl core::fmt::Debug for AeronParsedAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronParsedAddress))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronParsedAddress))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronParsedAddress {
    #[inline]
    pub fn new(
        host: [::std::os::raw::c_char; 384usize],
        port: [::std::os::raw::c_char; 8usize],
        ip_version_hint: ::std::os::raw::c_int,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_parsed_address_t {
                    host: host.into(),
                    port: port.into(),
                    ip_version_hint: ip_version_hint.into(),
                };
                let inner_ptr: *mut aeron_parsed_address_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_parsed_address_t)
                );
                let inst: aeron_parsed_address_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_parsed_address_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_parsed_address_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn host(&self) -> [::std::os::raw::c_char; 384usize] {
        self.host.into()
    }
    #[inline]
    pub fn port(&self) -> [::std::os::raw::c_char; 8usize] {
        self.port.into()
    }
    #[inline]
    pub fn ip_version_hint(&self) -> ::std::os::raw::c_int {
        self.ip_version_hint.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_parsed_address_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_parsed_address_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_parsed_address_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronParsedAddress {
    type Target = aeron_parsed_address_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_parsed_address_t> for AeronParsedAddress {
    #[inline]
    fn from(value: *mut aeron_parsed_address_t) -> Self {
        AeronParsedAddress {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronParsedAddress> for *mut aeron_parsed_address_t {
    #[inline]
    fn from(value: AeronParsedAddress) -> Self {
        value.get_inner()
    }
}
impl From<&AeronParsedAddress> for *mut aeron_parsed_address_t {
    #[inline]
    fn from(value: &AeronParsedAddress) -> Self {
        value.get_inner()
    }
}
impl From<AeronParsedAddress> for aeron_parsed_address_t {
    #[inline]
    fn from(value: AeronParsedAddress) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_parsed_address_t> for AeronParsedAddress {
    #[inline]
    fn from(value: *const aeron_parsed_address_t) -> Self {
        AeronParsedAddress {
            inner: CResource::Borrowed(value as *mut aeron_parsed_address_t),
        }
    }
}
impl From<aeron_parsed_address_t> for AeronParsedAddress {
    #[inline]
    fn from(value: aeron_parsed_address_t) -> Self {
        AeronParsedAddress {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronParsedAddress {
    fn default() -> Self {
        AeronParsedAddress::new_zeroed_on_heap()
    }
}
impl AeronParsedAddress {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronParsedInterface {
    inner: CResource<aeron_parsed_interface_t>,
}
impl core::fmt::Debug for AeronParsedInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronParsedInterface))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronParsedInterface))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronParsedInterface {
    #[inline]
    pub fn new(
        host: [::std::os::raw::c_char; 384usize],
        port: [::std::os::raw::c_char; 8usize],
        prefix: [::std::os::raw::c_char; 8usize],
        ip_version_hint: ::std::os::raw::c_int,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_parsed_interface_t {
                    host: host.into(),
                    port: port.into(),
                    prefix: prefix.into(),
                    ip_version_hint: ip_version_hint.into(),
                };
                let inner_ptr: *mut aeron_parsed_interface_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_parsed_interface_t)
                );
                let inst: aeron_parsed_interface_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_parsed_interface_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_parsed_interface_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn host(&self) -> [::std::os::raw::c_char; 384usize] {
        self.host.into()
    }
    #[inline]
    pub fn port(&self) -> [::std::os::raw::c_char; 8usize] {
        self.port.into()
    }
    #[inline]
    pub fn prefix(&self) -> [::std::os::raw::c_char; 8usize] {
        self.prefix.into()
    }
    #[inline]
    pub fn ip_version_hint(&self) -> ::std::os::raw::c_int {
        self.ip_version_hint.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_parsed_interface_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_parsed_interface_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_parsed_interface_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronParsedInterface {
    type Target = aeron_parsed_interface_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_parsed_interface_t> for AeronParsedInterface {
    #[inline]
    fn from(value: *mut aeron_parsed_interface_t) -> Self {
        AeronParsedInterface {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronParsedInterface> for *mut aeron_parsed_interface_t {
    #[inline]
    fn from(value: AeronParsedInterface) -> Self {
        value.get_inner()
    }
}
impl From<&AeronParsedInterface> for *mut aeron_parsed_interface_t {
    #[inline]
    fn from(value: &AeronParsedInterface) -> Self {
        value.get_inner()
    }
}
impl From<AeronParsedInterface> for aeron_parsed_interface_t {
    #[inline]
    fn from(value: AeronParsedInterface) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_parsed_interface_t> for AeronParsedInterface {
    #[inline]
    fn from(value: *const aeron_parsed_interface_t) -> Self {
        AeronParsedInterface {
            inner: CResource::Borrowed(value as *mut aeron_parsed_interface_t),
        }
    }
}
impl From<aeron_parsed_interface_t> for AeronParsedInterface {
    #[inline]
    fn from(value: aeron_parsed_interface_t) -> Self {
        AeronParsedInterface {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronParsedInterface {
    fn default() -> Self {
        AeronParsedInterface::new_zeroed_on_heap()
    }
}
impl AeronParsedInterface {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPerThreadError {
    inner: CResource<aeron_per_thread_error_t>,
}
impl core::fmt::Debug for AeronPerThreadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPerThreadError))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPerThreadError))
                .field("inner", &self.inner)
                .field(stringify!(offset), &self.offset())
                .finish()
        }
    }
}
impl AeronPerThreadError {
    #[inline]
    pub fn new(
        errcode: ::std::os::raw::c_int,
        offset: usize,
        errmsg: [::std::os::raw::c_char; 8192usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_per_thread_error_t {
                    errcode: errcode.into(),
                    offset: offset.into(),
                    errmsg: errmsg.into(),
                };
                let inner_ptr: *mut aeron_per_thread_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_per_thread_error_t)
                );
                let inst: aeron_per_thread_error_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_per_thread_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_per_thread_error_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn errcode(&self) -> ::std::os::raw::c_int {
        self.errcode.into()
    }
    #[inline]
    pub fn offset(&self) -> usize {
        self.offset.into()
    }
    #[inline]
    pub fn errmsg(&self) -> [::std::os::raw::c_char; 8192usize] {
        self.errmsg.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_per_thread_error_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_per_thread_error_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_per_thread_error_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPerThreadError {
    type Target = aeron_per_thread_error_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_per_thread_error_t> for AeronPerThreadError {
    #[inline]
    fn from(value: *mut aeron_per_thread_error_t) -> Self {
        AeronPerThreadError {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPerThreadError> for *mut aeron_per_thread_error_t {
    #[inline]
    fn from(value: AeronPerThreadError) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPerThreadError> for *mut aeron_per_thread_error_t {
    #[inline]
    fn from(value: &AeronPerThreadError) -> Self {
        value.get_inner()
    }
}
impl From<AeronPerThreadError> for aeron_per_thread_error_t {
    #[inline]
    fn from(value: AeronPerThreadError) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_per_thread_error_t> for AeronPerThreadError {
    #[inline]
    fn from(value: *const aeron_per_thread_error_t) -> Self {
        AeronPerThreadError {
            inner: CResource::Borrowed(value as *mut aeron_per_thread_error_t),
        }
    }
}
impl From<aeron_per_thread_error_t> for AeronPerThreadError {
    #[inline]
    fn from(value: aeron_per_thread_error_t) -> Self {
        AeronPerThreadError {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPerThreadError {
    fn default() -> Self {
        AeronPerThreadError::new_zeroed_on_heap()
    }
}
impl AeronPerThreadError {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPortManager {
    inner: CResource<aeron_port_manager_t>,
}
impl core::fmt::Debug for AeronPortManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPortManager))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPortManager))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronPortManager {
    #[inline]
    pub fn new<
        AeronPortManagerFreeManagedPortFuncHandlerImpl: AeronPortManagerFreeManagedPortFuncCallback,
    >(
        get_managed_port: aeron_port_manager_get_managed_port_func_t,
        free_managed_port: Option<&Handler<AeronPortManagerFreeManagedPortFuncHandlerImpl>>,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_port_manager_t {
                    get_managed_port: get_managed_port.into(),
                    free_managed_port: {
                        let callback: aeron_port_manager_free_managed_port_func_t =
                            if free_managed_port.is_none() {
                                None
                            } else {
                                Some(
                                    aeron_port_manager_free_managed_port_func_t_callback::<
                                        AeronPortManagerFreeManagedPortFuncHandlerImpl,
                                    >,
                                )
                            };
                        callback
                    },
                    state: free_managed_port
                        .map(|m| m.as_raw())
                        .unwrap_or_else(|| std::ptr::null_mut()),
                };
                let inner_ptr: *mut aeron_port_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_port_manager_t)
                );
                let inst: aeron_port_manager_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_port_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_port_manager_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn get_managed_port(&self) -> aeron_port_manager_get_managed_port_func_t {
        self.get_managed_port.into()
    }
    #[inline]
    pub fn free_managed_port(&self) -> aeron_port_manager_free_managed_port_func_t {
        self.free_managed_port.into()
    }
    #[inline]
    pub fn state(&self) -> *mut ::std::os::raw::c_void {
        self.state.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_port_manager_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_port_manager_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_port_manager_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPortManager {
    type Target = aeron_port_manager_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_port_manager_t> for AeronPortManager {
    #[inline]
    fn from(value: *mut aeron_port_manager_t) -> Self {
        AeronPortManager {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPortManager> for *mut aeron_port_manager_t {
    #[inline]
    fn from(value: AeronPortManager) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPortManager> for *mut aeron_port_manager_t {
    #[inline]
    fn from(value: &AeronPortManager) -> Self {
        value.get_inner()
    }
}
impl From<AeronPortManager> for aeron_port_manager_t {
    #[inline]
    fn from(value: AeronPortManager) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_port_manager_t> for AeronPortManager {
    #[inline]
    fn from(value: *const aeron_port_manager_t) -> Self {
        AeronPortManager {
            inner: CResource::Borrowed(value as *mut aeron_port_manager_t),
        }
    }
}
impl From<aeron_port_manager_t> for AeronPortManager {
    #[inline]
    fn from(value: aeron_port_manager_t) -> Self {
        AeronPortManager {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPortManager {
    fn default() -> Self {
        AeronPortManager::new_zeroed_on_heap()
    }
}
impl AeronPortManager {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPosition {
    inner: CResource<aeron_position_t>,
}
impl core::fmt::Debug for AeronPosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPosition))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPosition))
                .field("inner", &self.inner)
                .field(stringify!(counter_id), &self.counter_id())
                .finish()
        }
    }
}
impl AeronPosition {
    #[inline]
    pub fn new(counter_id: i32, value_addr: &mut i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_position_t {
                    counter_id: counter_id.into(),
                    value_addr: value_addr as *mut _,
                };
                let inner_ptr: *mut aeron_position_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_position_t)
                );
                let inst: aeron_position_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_position_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_position_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline]
    pub fn value_addr(&self) -> &mut i64 {
        unsafe { &mut *self.value_addr }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_position_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_position_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_position_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPosition {
    type Target = aeron_position_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_position_t> for AeronPosition {
    #[inline]
    fn from(value: *mut aeron_position_t) -> Self {
        AeronPosition {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPosition> for *mut aeron_position_t {
    #[inline]
    fn from(value: AeronPosition) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPosition> for *mut aeron_position_t {
    #[inline]
    fn from(value: &AeronPosition) -> Self {
        value.get_inner()
    }
}
impl From<AeronPosition> for aeron_position_t {
    #[inline]
    fn from(value: AeronPosition) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_position_t> for AeronPosition {
    #[inline]
    fn from(value: *const aeron_position_t) -> Self {
        AeronPosition {
            inner: CResource::Borrowed(value as *mut aeron_position_t),
        }
    }
}
impl From<aeron_position_t> for AeronPosition {
    #[inline]
    fn from(value: aeron_position_t) -> Self {
        AeronPosition {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPosition {
    fn default() -> Self {
        AeronPosition::new_zeroed_on_heap()
    }
}
impl AeronPosition {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationBuffersReady {
    inner: CResource<aeron_publication_buffers_ready_t>,
}
impl core::fmt::Debug for AeronPublicationBuffersReady {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationBuffersReady))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationBuffersReady))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(
                    stringify!(position_limit_counter_id),
                    &self.position_limit_counter_id(),
                )
                .field(
                    stringify!(channel_status_indicator_id),
                    &self.channel_status_indicator_id(),
                )
                .field(stringify!(log_file_length), &self.log_file_length())
                .finish()
        }
    }
}
impl AeronPublicationBuffersReady {
    #[inline]
    pub fn new(
        correlation_id: i64,
        registration_id: i64,
        session_id: i32,
        stream_id: i32,
        position_limit_counter_id: i32,
        channel_status_indicator_id: i32,
        log_file_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_buffers_ready_t {
                    correlation_id: correlation_id.into(),
                    registration_id: registration_id.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    position_limit_counter_id: position_limit_counter_id.into(),
                    channel_status_indicator_id: channel_status_indicator_id.into(),
                    log_file_length: log_file_length.into(),
                };
                let inner_ptr: *mut aeron_publication_buffers_ready_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_buffers_ready_t)
                );
                let inst: aeron_publication_buffers_ready_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_buffers_ready_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_buffers_ready_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn position_limit_counter_id(&self) -> i32 {
        self.position_limit_counter_id.into()
    }
    #[inline]
    pub fn channel_status_indicator_id(&self) -> i32 {
        self.channel_status_indicator_id.into()
    }
    #[inline]
    pub fn log_file_length(&self) -> i32 {
        self.log_file_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_buffers_ready_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_buffers_ready_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_buffers_ready_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationBuffersReady {
    type Target = aeron_publication_buffers_ready_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_buffers_ready_t> for AeronPublicationBuffersReady {
    #[inline]
    fn from(value: *mut aeron_publication_buffers_ready_t) -> Self {
        AeronPublicationBuffersReady {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationBuffersReady> for *mut aeron_publication_buffers_ready_t {
    #[inline]
    fn from(value: AeronPublicationBuffersReady) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationBuffersReady> for *mut aeron_publication_buffers_ready_t {
    #[inline]
    fn from(value: &AeronPublicationBuffersReady) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationBuffersReady> for aeron_publication_buffers_ready_t {
    #[inline]
    fn from(value: AeronPublicationBuffersReady) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_buffers_ready_t> for AeronPublicationBuffersReady {
    #[inline]
    fn from(value: *const aeron_publication_buffers_ready_t) -> Self {
        AeronPublicationBuffersReady {
            inner: CResource::Borrowed(value as *mut aeron_publication_buffers_ready_t),
        }
    }
}
impl From<aeron_publication_buffers_ready_t> for AeronPublicationBuffersReady {
    #[inline]
    fn from(value: aeron_publication_buffers_ready_t) -> Self {
        AeronPublicationBuffersReady {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationBuffersReady {
    fn default() -> Self {
        AeronPublicationBuffersReady::new_zeroed_on_heap()
    }
}
impl AeronPublicationBuffersReady {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationCommand {
    inner: CResource<aeron_publication_command_t>,
}
impl core::fmt::Debug for AeronPublicationCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronPublicationCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        stream_id: i32,
        channel_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_command_t {
                    correlated: correlated.into(),
                    stream_id: stream_id.into(),
                    channel_length: channel_length.into(),
                };
                let inner_ptr: *mut aeron_publication_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_command_t)
                );
                let inst: aeron_publication_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationCommand {
    type Target = aeron_publication_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_command_t> for AeronPublicationCommand {
    #[inline]
    fn from(value: *mut aeron_publication_command_t) -> Self {
        AeronPublicationCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationCommand> for *mut aeron_publication_command_t {
    #[inline]
    fn from(value: AeronPublicationCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationCommand> for *mut aeron_publication_command_t {
    #[inline]
    fn from(value: &AeronPublicationCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationCommand> for aeron_publication_command_t {
    #[inline]
    fn from(value: AeronPublicationCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_command_t> for AeronPublicationCommand {
    #[inline]
    fn from(value: *const aeron_publication_command_t) -> Self {
        AeronPublicationCommand {
            inner: CResource::Borrowed(value as *mut aeron_publication_command_t),
        }
    }
}
impl From<aeron_publication_command_t> for AeronPublicationCommand {
    #[inline]
    fn from(value: aeron_publication_command_t) -> Self {
        AeronPublicationCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationCommand {
    fn default() -> Self {
        AeronPublicationCommand::new_zeroed_on_heap()
    }
}
impl AeronPublicationCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[doc = "Configuration for a publication that does not change during it's lifetime."]
#[derive(Clone)]
pub struct AeronPublicationConstants {
    inner: CResource<aeron_publication_constants_t>,
}
impl core::fmt::Debug for AeronPublicationConstants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationConstants))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationConstants))
                .field("inner", &self.inner)
                .field(
                    stringify!(original_registration_id),
                    &self.original_registration_id(),
                )
                .field(stringify!(registration_id), &self.registration_id())
                .field(
                    stringify!(max_possible_position),
                    &self.max_possible_position(),
                )
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .field(stringify!(term_buffer_length), &self.term_buffer_length())
                .field(stringify!(max_message_length), &self.max_message_length())
                .field(stringify!(max_payload_length), &self.max_payload_length())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(
                    stringify!(publication_limit_counter_id),
                    &self.publication_limit_counter_id(),
                )
                .field(
                    stringify!(channel_status_indicator_id),
                    &self.channel_status_indicator_id(),
                )
                .finish()
        }
    }
}
impl AeronPublicationConstants {
    #[inline]
    pub fn new(
        channel: &std::ffi::CStr,
        original_registration_id: i64,
        registration_id: i64,
        max_possible_position: i64,
        position_bits_to_shift: usize,
        term_buffer_length: usize,
        max_message_length: usize,
        max_payload_length: usize,
        stream_id: i32,
        session_id: i32,
        initial_term_id: i32,
        publication_limit_counter_id: i32,
        channel_status_indicator_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_constants_t {
                    channel: channel.as_ptr(),
                    original_registration_id: original_registration_id.into(),
                    registration_id: registration_id.into(),
                    max_possible_position: max_possible_position.into(),
                    position_bits_to_shift: position_bits_to_shift.into(),
                    term_buffer_length: term_buffer_length.into(),
                    max_message_length: max_message_length.into(),
                    max_payload_length: max_payload_length.into(),
                    stream_id: stream_id.into(),
                    session_id: session_id.into(),
                    initial_term_id: initial_term_id.into(),
                    publication_limit_counter_id: publication_limit_counter_id.into(),
                    channel_status_indicator_id: channel_status_indicator_id.into(),
                };
                let inner_ptr: *mut aeron_publication_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_constants_t)
                );
                let inst: aeron_publication_constants_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_constants_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel(&self) -> &str {
        if self.channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.channel).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn original_registration_id(&self) -> i64 {
        self.original_registration_id.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn max_possible_position(&self) -> i64 {
        self.max_possible_position.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline]
    pub fn term_buffer_length(&self) -> usize {
        self.term_buffer_length.into()
    }
    #[inline]
    pub fn max_message_length(&self) -> usize {
        self.max_message_length.into()
    }
    #[inline]
    pub fn max_payload_length(&self) -> usize {
        self.max_payload_length.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn publication_limit_counter_id(&self) -> i32 {
        self.publication_limit_counter_id.into()
    }
    #[inline]
    pub fn channel_status_indicator_id(&self) -> i32 {
        self.channel_status_indicator_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_constants_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_constants_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_constants_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationConstants {
    type Target = aeron_publication_constants_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_constants_t> for AeronPublicationConstants {
    #[inline]
    fn from(value: *mut aeron_publication_constants_t) -> Self {
        AeronPublicationConstants {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationConstants> for *mut aeron_publication_constants_t {
    #[inline]
    fn from(value: AeronPublicationConstants) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationConstants> for *mut aeron_publication_constants_t {
    #[inline]
    fn from(value: &AeronPublicationConstants) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationConstants> for aeron_publication_constants_t {
    #[inline]
    fn from(value: AeronPublicationConstants) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_constants_t> for AeronPublicationConstants {
    #[inline]
    fn from(value: *const aeron_publication_constants_t) -> Self {
        AeronPublicationConstants {
            inner: CResource::Borrowed(value as *mut aeron_publication_constants_t),
        }
    }
}
impl From<aeron_publication_constants_t> for AeronPublicationConstants {
    #[inline]
    fn from(value: aeron_publication_constants_t) -> Self {
        AeronPublicationConstants {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationConstants {
    fn default() -> Self {
        AeronPublicationConstants::new_zeroed_on_heap()
    }
}
impl AeronPublicationConstants {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationError {
    inner: CResource<aeron_publication_error_t>,
}
impl core::fmt::Debug for AeronPublicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationError))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationError))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(
                    stringify!(destination_registration_id),
                    &self.destination_registration_id(),
                )
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(receiver_id), &self.receiver_id())
                .field(stringify!(group_tag), &self.group_tag())
                .field(stringify!(address_type), &self.address_type())
                .field(stringify!(source_port), &self.source_port())
                .field(stringify!(error_code), &self.error_code())
                .field(
                    stringify!(error_message_length),
                    &self.error_message_length(),
                )
                .finish()
        }
    }
}
impl AeronPublicationError {
    #[inline]
    pub fn new(
        registration_id: i64,
        destination_registration_id: i64,
        session_id: i32,
        stream_id: i32,
        receiver_id: i64,
        group_tag: i64,
        address_type: i16,
        source_port: u16,
        source_address: [u8; 16usize],
        error_code: i32,
        error_message_length: i32,
        error_message: [u8; 1usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_error_t {
                    registration_id: registration_id.into(),
                    destination_registration_id: destination_registration_id.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    receiver_id: receiver_id.into(),
                    group_tag: group_tag.into(),
                    address_type: address_type.into(),
                    source_port: source_port.into(),
                    source_address: source_address.into(),
                    error_code: error_code.into(),
                    error_message_length: error_message_length.into(),
                    error_message: error_message.into(),
                };
                let inner_ptr: *mut aeron_publication_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_error_t)
                );
                let inst: aeron_publication_error_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_error_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_error_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn destination_registration_id(&self) -> i64 {
        self.destination_registration_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn group_tag(&self) -> i64 {
        self.group_tag.into()
    }
    #[inline]
    pub fn address_type(&self) -> i16 {
        self.address_type.into()
    }
    #[inline]
    pub fn source_port(&self) -> u16 {
        self.source_port.into()
    }
    #[inline]
    pub fn source_address(&self) -> [u8; 16usize] {
        self.source_address.into()
    }
    #[inline]
    pub fn error_code(&self) -> i32 {
        self.error_code.into()
    }
    #[inline]
    pub fn error_message_length(&self) -> i32 {
        self.error_message_length.into()
    }
    #[inline]
    pub fn error_message(&self) -> [u8; 1usize] {
        self.error_message.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_error_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_error_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_error_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationError {
    type Target = aeron_publication_error_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_error_t> for AeronPublicationError {
    #[inline]
    fn from(value: *mut aeron_publication_error_t) -> Self {
        AeronPublicationError {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationError> for *mut aeron_publication_error_t {
    #[inline]
    fn from(value: AeronPublicationError) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationError> for *mut aeron_publication_error_t {
    #[inline]
    fn from(value: &AeronPublicationError) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationError> for aeron_publication_error_t {
    #[inline]
    fn from(value: AeronPublicationError) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_error_t> for AeronPublicationError {
    #[inline]
    fn from(value: *const aeron_publication_error_t) -> Self {
        AeronPublicationError {
            inner: CResource::Borrowed(value as *mut aeron_publication_error_t),
        }
    }
}
impl From<aeron_publication_error_t> for AeronPublicationError {
    #[inline]
    fn from(value: aeron_publication_error_t) -> Self {
        AeronPublicationError {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationError {
    fn default() -> Self {
        AeronPublicationError::new_zeroed_on_heap()
    }
}
impl AeronPublicationError {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationErrorValues {
    inner: CResource<aeron_publication_error_values_t>,
}
impl core::fmt::Debug for AeronPublicationErrorValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationErrorValues))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationErrorValues))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(
                    stringify!(destination_registration_id),
                    &self.destination_registration_id(),
                )
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(receiver_id), &self.receiver_id())
                .field(stringify!(group_tag), &self.group_tag())
                .field(stringify!(address_type), &self.address_type())
                .field(stringify!(source_port), &self.source_port())
                .field(stringify!(error_code), &self.error_code())
                .field(
                    stringify!(error_message_length),
                    &self.error_message_length(),
                )
                .finish()
        }
    }
}
impl AeronPublicationErrorValues {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_error_values_t)
                );
                let inst: aeron_publication_error_values_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_error_values_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_error_values_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn destination_registration_id(&self) -> i64 {
        self.destination_registration_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn group_tag(&self) -> i64 {
        self.group_tag.into()
    }
    #[inline]
    pub fn address_type(&self) -> i16 {
        self.address_type.into()
    }
    #[inline]
    pub fn source_port(&self) -> u16 {
        self.source_port.into()
    }
    #[inline]
    pub fn source_address(&self) -> [u8; 16usize] {
        self.source_address.into()
    }
    #[inline]
    pub fn error_code(&self) -> i32 {
        self.error_code.into()
    }
    #[inline]
    pub fn error_message_length(&self) -> i32 {
        self.error_message_length.into()
    }
    #[inline]
    pub fn error_message(&self) -> [u8; 1usize] {
        self.error_message.into()
    }
    #[inline]
    #[doc = "Delete a instance of `AeronPublicationErrorValues` that was created when making a copy"]
    #[doc = " (aeron_publication_error_values_copy). This should not be use on the pointer received via the aeron_frame_handler_t."]
    pub fn delete(&self) -> () {
        unsafe {
            let result = aeron_publication_error_values_delete(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_error_values_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_error_values_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_error_values_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationErrorValues {
    type Target = aeron_publication_error_values_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_error_values_t> for AeronPublicationErrorValues {
    #[inline]
    fn from(value: *mut aeron_publication_error_values_t) -> Self {
        AeronPublicationErrorValues {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationErrorValues> for *mut aeron_publication_error_values_t {
    #[inline]
    fn from(value: AeronPublicationErrorValues) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationErrorValues> for *mut aeron_publication_error_values_t {
    #[inline]
    fn from(value: &AeronPublicationErrorValues) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationErrorValues> for aeron_publication_error_values_t {
    #[inline]
    fn from(value: AeronPublicationErrorValues) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_error_values_t> for AeronPublicationErrorValues {
    #[inline]
    fn from(value: *const aeron_publication_error_values_t) -> Self {
        AeronPublicationErrorValues {
            inner: CResource::Borrowed(value as *mut aeron_publication_error_values_t),
        }
    }
}
impl From<aeron_publication_error_values_t> for AeronPublicationErrorValues {
    #[inline]
    fn from(value: aeron_publication_error_values_t) -> Self {
        AeronPublicationErrorValues {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronPublicationImageConnection {
    inner: CResource<aeron_publication_image_connection_t>,
}
impl core::fmt::Debug for AeronPublicationImageConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationImageConnection))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationImageConnection))
                .field("inner", &self.inner)
                .field(
                    stringify!(resolved_control_address_for_implicit_unicast_channels),
                    &self.resolved_control_address_for_implicit_unicast_channels(),
                )
                .field(stringify!(is_eos), &self.is_eos())
                .field(
                    stringify!(time_of_last_activity_ns),
                    &self.time_of_last_activity_ns(),
                )
                .field(
                    stringify!(time_of_last_frame_ns),
                    &self.time_of_last_frame_ns(),
                )
                .field(stringify!(eos_position), &self.eos_position())
                .finish()
        }
    }
}
impl AeronPublicationImageConnection {
    #[inline]
    pub fn new(
        padding_before: [u8; 64usize],
        resolved_control_address_for_implicit_unicast_channels: SockaddrStorage,
        destination: &AeronReceiveDestination,
        control_addr: &SockaddrStorage,
        is_eos: bool,
        time_of_last_activity_ns: i64,
        time_of_last_frame_ns: i64,
        eos_position: i64,
        padding_after: [u8; 64usize],
    ) -> Result<Self, AeronCError> {
        let destination_copy = destination.clone();
        let control_addr_copy = control_addr.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_image_connection_t {
                    padding_before: padding_before.into(),
                    resolved_control_address_for_implicit_unicast_channels:
                        resolved_control_address_for_implicit_unicast_channels.into(),
                    destination: destination.into(),
                    control_addr: control_addr.into(),
                    is_eos: is_eos.into(),
                    time_of_last_activity_ns: time_of_last_activity_ns.into(),
                    time_of_last_frame_ns: time_of_last_frame_ns.into(),
                    eos_position: eos_position.into(),
                    padding_after: padding_after.into(),
                };
                let inner_ptr: *mut aeron_publication_image_connection_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_image_connection_t)
                );
                let inst: aeron_publication_image_connection_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_image_connection_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_image_connection_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding_before(&self) -> [u8; 64usize] {
        self.padding_before.into()
    }
    #[inline]
    pub fn resolved_control_address_for_implicit_unicast_channels(&self) -> SockaddrStorage {
        self.resolved_control_address_for_implicit_unicast_channels
            .into()
    }
    #[inline]
    pub fn destination(&self) -> AeronReceiveDestination {
        self.destination.into()
    }
    #[inline]
    pub fn control_addr(&self) -> SockaddrStorage {
        self.control_addr.into()
    }
    #[inline]
    pub fn is_eos(&self) -> bool {
        self.is_eos.into()
    }
    #[inline]
    pub fn time_of_last_activity_ns(&self) -> i64 {
        self.time_of_last_activity_ns.into()
    }
    #[inline]
    pub fn time_of_last_frame_ns(&self) -> i64 {
        self.time_of_last_frame_ns.into()
    }
    #[inline]
    pub fn eos_position(&self) -> i64 {
        self.eos_position.into()
    }
    #[inline]
    pub fn padding_after(&self) -> [u8; 64usize] {
        self.padding_after.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_image_connection_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_image_connection_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_image_connection_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationImageConnection {
    type Target = aeron_publication_image_connection_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_image_connection_t> for AeronPublicationImageConnection {
    #[inline]
    fn from(value: *mut aeron_publication_image_connection_t) -> Self {
        AeronPublicationImageConnection {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationImageConnection> for *mut aeron_publication_image_connection_t {
    #[inline]
    fn from(value: AeronPublicationImageConnection) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationImageConnection> for *mut aeron_publication_image_connection_t {
    #[inline]
    fn from(value: &AeronPublicationImageConnection) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationImageConnection> for aeron_publication_image_connection_t {
    #[inline]
    fn from(value: AeronPublicationImageConnection) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_image_connection_t> for AeronPublicationImageConnection {
    #[inline]
    fn from(value: *const aeron_publication_image_connection_t) -> Self {
        AeronPublicationImageConnection {
            inner: CResource::Borrowed(value as *mut aeron_publication_image_connection_t),
        }
    }
}
impl From<aeron_publication_image_connection_t> for AeronPublicationImageConnection {
    #[inline]
    fn from(value: aeron_publication_image_connection_t) -> Self {
        AeronPublicationImageConnection {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationImageConnection {
    fn default() -> Self {
        AeronPublicationImageConnection::new_zeroed_on_heap()
    }
}
impl AeronPublicationImageConnection {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationImageEntry {
    inner: CResource<aeron_publication_image_entry_t>,
}
impl core::fmt::Debug for AeronPublicationImageEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationImageEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationImageEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronPublicationImageEntry {
    #[inline]
    pub fn new(image: &AeronPublicationImage) -> Result<Self, AeronCError> {
        let image_copy = image.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_image_entry_t {
                    image: image.into(),
                };
                let inner_ptr: *mut aeron_publication_image_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_image_entry_t)
                );
                let inst: aeron_publication_image_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_image_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_image_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn image(&self) -> AeronPublicationImage {
        self.image.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_image_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_image_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_image_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationImageEntry {
    type Target = aeron_publication_image_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_image_entry_t> for AeronPublicationImageEntry {
    #[inline]
    fn from(value: *mut aeron_publication_image_entry_t) -> Self {
        AeronPublicationImageEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationImageEntry> for *mut aeron_publication_image_entry_t {
    #[inline]
    fn from(value: AeronPublicationImageEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationImageEntry> for *mut aeron_publication_image_entry_t {
    #[inline]
    fn from(value: &AeronPublicationImageEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationImageEntry> for aeron_publication_image_entry_t {
    #[inline]
    fn from(value: AeronPublicationImageEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_image_entry_t> for AeronPublicationImageEntry {
    #[inline]
    fn from(value: *const aeron_publication_image_entry_t) -> Self {
        AeronPublicationImageEntry {
            inner: CResource::Borrowed(value as *mut aeron_publication_image_entry_t),
        }
    }
}
impl From<aeron_publication_image_entry_t> for AeronPublicationImageEntry {
    #[inline]
    fn from(value: aeron_publication_image_entry_t) -> Self {
        AeronPublicationImageEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationImageEntry {
    fn default() -> Self {
        AeronPublicationImageEntry::new_zeroed_on_heap()
    }
}
impl AeronPublicationImageEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublicationImage {
    inner: CResource<aeron_publication_image_t>,
}
impl core::fmt::Debug for AeronPublicationImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationImage))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationImage))
                .field("inner", &self.inner)
                .field(stringify!(source_address), &self.source_address())
                .field(
                    stringify!(source_identity_length),
                    &self.source_identity_length(),
                )
                .field(stringify!(loss_detector), &self.loss_detector())
                .field(
                    stringify!(feedback_delay_state),
                    &self.feedback_delay_state(),
                )
                .field(stringify!(mapped_raw_log), &self.mapped_raw_log())
                .field(stringify!(rcv_hwm_position), &self.rcv_hwm_position())
                .field(stringify!(rcv_pos_position), &self.rcv_pos_position())
                .field(stringify!(rcv_naks_sent), &self.rcv_naks_sent())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(stringify!(active_term_id), &self.active_term_id())
                .field(stringify!(term_length), &self.term_length())
                .field(stringify!(mtu_length), &self.mtu_length())
                .field(stringify!(term_length_mask), &self.term_length_mask())
                .field(
                    stringify!(log_file_name_length),
                    &self.log_file_name_length(),
                )
                .field(
                    stringify!(position_bits_to_shift),
                    &self.position_bits_to_shift(),
                )
                .field(
                    stringify!(last_loss_change_number),
                    &self.last_loss_change_number(),
                )
                .field(stringify!(begin_loss_change), &self.begin_loss_change())
                .field(stringify!(end_loss_change), &self.end_loss_change())
                .field(stringify!(loss_term_id), &self.loss_term_id())
                .field(stringify!(loss_term_offset), &self.loss_term_offset())
                .field(stringify!(loss_length), &self.loss_length())
                .field(stringify!(begin_sm_change), &self.begin_sm_change())
                .field(stringify!(end_sm_change), &self.end_sm_change())
                .field(
                    stringify!(last_overrun_threshold),
                    &self.last_overrun_threshold(),
                )
                .field(stringify!(next_sm_position), &self.next_sm_position())
                .field(
                    stringify!(next_sm_receiver_window_length),
                    &self.next_sm_receiver_window_length(),
                )
                .field(
                    stringify!(max_receiver_window_length),
                    &self.max_receiver_window_length(),
                )
                .field(
                    stringify!(last_sm_change_number),
                    &self.last_sm_change_number(),
                )
                .field(stringify!(last_sm_position), &self.last_sm_position())
                .field(stringify!(next_sm_deadline_ns), &self.next_sm_deadline_ns())
                .field(stringify!(sm_timeout_ns), &self.sm_timeout_ns())
                .field(
                    stringify!(time_of_last_packet_ns),
                    &self.time_of_last_packet_ns(),
                )
                .field(stringify!(is_sm_enabled), &self.is_sm_enabled())
                .field(stringify!(response_session_id), &self.response_session_id())
                .field(stringify!(is_end_of_stream), &self.is_end_of_stream())
                .field(stringify!(is_sending_eos_sm), &self.is_sending_eos_sm())
                .field(
                    stringify!(has_receiver_released),
                    &self.has_receiver_released(),
                )
                .finish()
        }
    }
}
impl AeronPublicationImage {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_image_t)
                );
                let inst: aeron_publication_image_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_image_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_image_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding_before(&self) -> [u8; 64usize] {
        self.padding_before.into()
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn padding_after(&self) -> [u8; 64usize] {
        self.padding_after.into()
    }
    #[inline]
    pub fn connections(&self) -> aeron_publication_image_stct_image_connection_entries {
        self.connections.into()
    }
    #[inline]
    pub fn source_address(&self) -> SockaddrStorage {
        self.source_address.into()
    }
    #[inline]
    pub fn source_identity_length(&self) -> usize {
        self.source_identity_length.into()
    }
    #[inline]
    pub fn source_identity(&self) -> [::std::os::raw::c_char; 54usize] {
        self.source_identity.into()
    }
    #[inline]
    pub fn loss_detector(&self) -> AeronLossDetector {
        self.loss_detector.into()
    }
    #[inline]
    pub fn feedback_delay_state(&self) -> AeronFeedbackDelayGeneratorState {
        self.feedback_delay_state.into()
    }
    #[inline]
    pub fn mapped_raw_log(&self) -> AeronMappedRawLog {
        self.mapped_raw_log.into()
    }
    #[inline]
    pub fn rcv_hwm_position(&self) -> AeronPosition {
        self.rcv_hwm_position.into()
    }
    #[inline]
    pub fn rcv_pos_position(&self) -> AeronPosition {
        self.rcv_pos_position.into()
    }
    #[inline]
    pub fn rcv_naks_sent(&self) -> AeronAtomicCounter {
        self.rcv_naks_sent.into()
    }
    #[inline]
    pub fn log_meta_data(&self) -> AeronLogbufferMetadata {
        self.log_meta_data.into()
    }
    #[inline]
    pub fn endpoint(&self) -> AeronReceiveChannelEndpoint {
        self.endpoint.into()
    }
    #[inline]
    pub fn congestion_control(&self) -> AeronCongestionControlStrategy {
        self.congestion_control.into()
    }
    #[inline]
    pub fn nano_clock(&self) -> aeron_clock_func_t {
        self.nano_clock.into()
    }
    #[inline]
    pub fn epoch_clock(&self) -> aeron_clock_func_t {
        self.epoch_clock.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn log_file_name(&self) -> &str {
        if self.log_file_name.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.log_file_name)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn active_term_id(&self) -> i32 {
        self.active_term_id.into()
    }
    #[inline]
    pub fn term_length(&self) -> i32 {
        self.term_length.into()
    }
    #[inline]
    pub fn mtu_length(&self) -> i32 {
        self.mtu_length.into()
    }
    #[inline]
    pub fn term_length_mask(&self) -> i32 {
        self.term_length_mask.into()
    }
    #[inline]
    pub fn log_file_name_length(&self) -> usize {
        self.log_file_name_length.into()
    }
    #[inline]
    pub fn position_bits_to_shift(&self) -> usize {
        self.position_bits_to_shift.into()
    }
    #[inline]
    pub fn raw_log_close_func(&self) -> aeron_raw_log_close_func_t {
        self.raw_log_close_func.into()
    }
    #[inline]
    pub fn raw_log_free_func(&self) -> aeron_raw_log_free_func_t {
        self.raw_log_free_func.into()
    }
    #[inline]
    pub fn log(&self) -> aeron_publication_image_stct__bindgen_ty_1 {
        self.log.into()
    }
    #[inline]
    pub fn last_loss_change_number(&self) -> i64 {
        self.last_loss_change_number.into()
    }
    #[inline]
    pub fn begin_loss_change(&self) -> i64 {
        self.begin_loss_change.into()
    }
    #[inline]
    pub fn end_loss_change(&self) -> i64 {
        self.end_loss_change.into()
    }
    #[inline]
    pub fn loss_term_id(&self) -> i32 {
        self.loss_term_id.into()
    }
    #[inline]
    pub fn loss_term_offset(&self) -> i32 {
        self.loss_term_offset.into()
    }
    #[inline]
    pub fn loss_length(&self) -> usize {
        self.loss_length.into()
    }
    #[inline]
    pub fn begin_sm_change(&self) -> i64 {
        self.begin_sm_change.into()
    }
    #[inline]
    pub fn end_sm_change(&self) -> i64 {
        self.end_sm_change.into()
    }
    #[inline]
    pub fn last_overrun_threshold(&self) -> i64 {
        self.last_overrun_threshold.into()
    }
    #[inline]
    pub fn next_sm_position(&self) -> i64 {
        self.next_sm_position.into()
    }
    #[inline]
    pub fn next_sm_receiver_window_length(&self) -> i32 {
        self.next_sm_receiver_window_length.into()
    }
    #[inline]
    pub fn max_receiver_window_length(&self) -> i32 {
        self.max_receiver_window_length.into()
    }
    #[inline]
    pub fn last_sm_change_number(&self) -> i64 {
        self.last_sm_change_number.into()
    }
    #[inline]
    pub fn last_sm_position(&self) -> i64 {
        self.last_sm_position.into()
    }
    #[inline]
    pub fn next_sm_deadline_ns(&self) -> i64 {
        self.next_sm_deadline_ns.into()
    }
    #[inline]
    pub fn sm_timeout_ns(&self) -> i64 {
        self.sm_timeout_ns.into()
    }
    #[inline]
    pub fn time_of_last_packet_ns(&self) -> i64 {
        self.time_of_last_packet_ns.into()
    }
    #[inline]
    pub fn invalidation_reason(&self) -> &str {
        if self.invalidation_reason.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.invalidation_reason)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn is_sm_enabled(&self) -> bool {
        self.is_sm_enabled.into()
    }
    #[inline]
    pub fn response_session_id(&self) -> i64 {
        self.response_session_id.into()
    }
    #[inline]
    pub fn is_end_of_stream(&self) -> bool {
        self.is_end_of_stream.into()
    }
    #[inline]
    pub fn is_sending_eos_sm(&self) -> bool {
        self.is_sending_eos_sm.into()
    }
    #[inline]
    pub fn has_receiver_released(&self) -> bool {
        self.has_receiver_released.into()
    }
    #[inline]
    pub fn heartbeats_received_counter(&self) -> &mut i64 {
        unsafe { &mut *self.heartbeats_received_counter }
    }
    #[inline]
    pub fn flow_control_under_runs_counter(&self) -> &mut i64 {
        unsafe { &mut *self.flow_control_under_runs_counter }
    }
    #[inline]
    pub fn flow_control_over_runs_counter(&self) -> &mut i64 {
        unsafe { &mut *self.flow_control_over_runs_counter }
    }
    #[inline]
    pub fn status_messages_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.status_messages_sent_counter }
    }
    #[inline]
    pub fn nak_messages_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.nak_messages_sent_counter }
    }
    #[inline]
    pub fn loss_gap_fills_counter(&self) -> &mut i64 {
        unsafe { &mut *self.loss_gap_fills_counter }
    }
    #[inline]
    pub fn mapped_bytes_counter(&self) -> &mut i64 {
        unsafe { &mut *self.mapped_bytes_counter }
    }
    #[inline]
    pub fn publication_images_revoked_counter(&self) -> &mut i64 {
        unsafe { &mut *self.publication_images_revoked_counter }
    }
    #[inline]
    pub fn location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: &std::ffi::CStr,
        correlation_id: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_location(
                dst.into(),
                length.into(),
                aeron_dir.as_ptr(),
                correlation_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn free(&self) -> bool {
        unsafe {
            let result = aeron_publication_image_free(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn clean_buffer_to(&self, position: i64) -> () {
        unsafe {
            let result = aeron_publication_image_clean_buffer_to(self.get_inner(), position.into());
            result.into()
        }
    }
    #[inline]
    pub fn on_gap_detected(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> () {
        unsafe {
            let result = aeron_publication_image_on_gap_detected(
                clientd.into(),
                term_id.into(),
                term_offset.into(),
                length.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn track_rebuild(&self, now_ns: i64) -> () {
        unsafe {
            let result = aeron_publication_image_track_rebuild(self.get_inner(), now_ns.into());
            result.into()
        }
    }
    #[inline]
    pub fn insert_packet(
        &self,
        destination: &AeronReceiveDestination,
        term_id: i32,
        term_offset: i32,
        buffer: &[u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_insert_packet(
                self.get_inner(),
                destination.get_inner(),
                term_id.into(),
                term_offset.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_rttm(
        &self,
        header: &AeronRttmHeader,
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_on_rttm(
                self.get_inner(),
                header.get_inner(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_pending_status_message(&self, now_ns: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_send_pending_status_message(
                self.get_inner(),
                now_ns.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_pending_loss(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_send_pending_loss(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn initiate_rttm(&self, now_ns: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_image_initiate_rttm(self.get_inner(), now_ns.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_destination(
        &self,
        destination: &AeronReceiveDestination,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_publication_image_add_destination(self.get_inner(), destination.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_destination(&self, channel: &AeronUdpChannel) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_publication_image_remove_destination(self.get_inner(), channel.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_connection_if_unknown(
        &self,
        destination: &AeronReceiveDestination,
        src_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_publication_image_add_connection_if_unknown(
                self.get_inner(),
                destination.get_inner(),
                src_addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn receiver_release(&self) -> () {
        unsafe {
            let result = aeron_publication_image_receiver_release(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn invalidate(&self, reason_length: i32, reason: &std::ffi::CStr) -> () {
        unsafe {
            let result = aeron_publication_image_invalidate(
                self.get_inner(),
                reason_length.into(),
                reason.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn remove_response_session_id(&self) -> () {
        unsafe {
            let result = aeron_publication_image_remove_response_session_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn stop_status_messages_if_not_active(&self) -> () {
        unsafe {
            let result =
                aeron_publication_image_stop_status_messages_if_not_active(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_image_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_image_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_image_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationImage {
    type Target = aeron_publication_image_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_image_t> for AeronPublicationImage {
    #[inline]
    fn from(value: *mut aeron_publication_image_t) -> Self {
        AeronPublicationImage {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationImage> for *mut aeron_publication_image_t {
    #[inline]
    fn from(value: AeronPublicationImage) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationImage> for *mut aeron_publication_image_t {
    #[inline]
    fn from(value: &AeronPublicationImage) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationImage> for aeron_publication_image_t {
    #[inline]
    fn from(value: AeronPublicationImage) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_image_t> for AeronPublicationImage {
    #[inline]
    fn from(value: *const aeron_publication_image_t) -> Self {
        AeronPublicationImage {
            inner: CResource::Borrowed(value as *mut aeron_publication_image_t),
        }
    }
}
impl From<aeron_publication_image_t> for AeronPublicationImage {
    #[inline]
    fn from(value: aeron_publication_image_t) -> Self {
        AeronPublicationImage {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronPublicationLink {
    inner: CResource<aeron_publication_link_t>,
}
impl core::fmt::Debug for AeronPublicationLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublicationLink))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublicationLink))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .finish()
        }
    }
}
impl AeronPublicationLink {
    #[inline]
    pub fn new(
        resource: &AeronDriverManagedResource,
        registration_id: i64,
    ) -> Result<Self, AeronCError> {
        let resource_copy = resource.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_publication_link_t {
                    resource: resource.into(),
                    registration_id: registration_id.into(),
                };
                let inner_ptr: *mut aeron_publication_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_link_t)
                );
                let inst: aeron_publication_link_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_link_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn resource(&self) -> AeronDriverManagedResource {
        self.resource.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_link_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_link_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_link_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublicationLink {
    type Target = aeron_publication_link_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_link_t> for AeronPublicationLink {
    #[inline]
    fn from(value: *mut aeron_publication_link_t) -> Self {
        AeronPublicationLink {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublicationLink> for *mut aeron_publication_link_t {
    #[inline]
    fn from(value: AeronPublicationLink) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublicationLink> for *mut aeron_publication_link_t {
    #[inline]
    fn from(value: &AeronPublicationLink) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublicationLink> for aeron_publication_link_t {
    #[inline]
    fn from(value: AeronPublicationLink) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_link_t> for AeronPublicationLink {
    #[inline]
    fn from(value: *const aeron_publication_link_t) -> Self {
        AeronPublicationLink {
            inner: CResource::Borrowed(value as *mut aeron_publication_link_t),
        }
    }
}
impl From<aeron_publication_link_t> for AeronPublicationLink {
    #[inline]
    fn from(value: aeron_publication_link_t) -> Self {
        AeronPublicationLink {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronPublicationLink {
    fn default() -> Self {
        AeronPublicationLink::new_zeroed_on_heap()
    }
}
impl AeronPublicationLink {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronPublication {
    inner: CResource<aeron_publication_t>,
}
impl core::fmt::Debug for AeronPublication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronPublication))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronPublication))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronPublication {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_publication_t)
                );
                let inst: aeron_publication_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_publication_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            Some(|c| unsafe { aeron_publication_is_closed(c) }),
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_publication_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Non-blocking publish of a buffer containing a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` to publish."]
    #[doc = " \n - `length` of the buffer."]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn offer<AeronReservedValueSupplierHandlerImpl: AeronReservedValueSupplierCallback>(
        &self,
        buffer: &[u8],
        reserved_value_supplier: Option<&Handler<AeronReservedValueSupplierHandlerImpl>>,
    ) -> i64 {
        unsafe {
            let result = aeron_publication_offer(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                {
                    let callback: aeron_reserved_value_supplier_t =
                        if reserved_value_supplier.is_none() {
                            None
                        } else {
                            Some(
                                aeron_reserved_value_supplier_t_callback::<
                                    AeronReservedValueSupplierHandlerImpl,
                                >,
                            )
                        };
                    callback
                },
                reserved_value_supplier
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish of a buffer containing a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` to publish."]
    #[doc = " \n - `length` of the buffer."]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn offer_once<AeronReservedValueSupplierHandlerImpl: FnMut(*mut u8, usize) -> i64>(
        &self,
        buffer: &[u8],
        mut reserved_value_supplier: AeronReservedValueSupplierHandlerImpl,
    ) -> i64 {
        unsafe {
            let result = aeron_publication_offer(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                Some(
                    aeron_reserved_value_supplier_t_callback_for_once_closure::<
                        AeronReservedValueSupplierHandlerImpl,
                    >,
                ),
                &mut reserved_value_supplier as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish by gathering buffer vectors into a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `iov` array for the vectors"]
    #[doc = " \n - `iovcnt` of the number of vectors"]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn offerv<AeronReservedValueSupplierHandlerImpl: AeronReservedValueSupplierCallback>(
        &self,
        iov: &AeronIovec,
        iovcnt: usize,
        reserved_value_supplier: Option<&Handler<AeronReservedValueSupplierHandlerImpl>>,
    ) -> i64 {
        unsafe {
            let result = aeron_publication_offerv(
                self.get_inner(),
                iov.get_inner(),
                iovcnt.into(),
                {
                    let callback: aeron_reserved_value_supplier_t =
                        if reserved_value_supplier.is_none() {
                            None
                        } else {
                            Some(
                                aeron_reserved_value_supplier_t_callback::<
                                    AeronReservedValueSupplierHandlerImpl,
                                >,
                            )
                        };
                    callback
                },
                reserved_value_supplier
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Non-blocking publish by gathering buffer vectors into a message."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `iov` array for the vectors"]
    #[doc = " \n - `iovcnt` of the number of vectors"]
    #[doc = " \n - `reserved_value_supplier` to use for setting the reserved value field or NULL."]
    #[doc = " \n - `clientd` to pass to the reserved_value_supplier."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn offerv_once<AeronReservedValueSupplierHandlerImpl: FnMut(*mut u8, usize) -> i64>(
        &self,
        iov: &AeronIovec,
        iovcnt: usize,
        mut reserved_value_supplier: AeronReservedValueSupplierHandlerImpl,
    ) -> i64 {
        unsafe {
            let result = aeron_publication_offerv(
                self.get_inner(),
                iov.get_inner(),
                iovcnt.into(),
                Some(
                    aeron_reserved_value_supplier_t_callback_for_once_closure::<
                        AeronReservedValueSupplierHandlerImpl,
                    >,
                ),
                &mut reserved_value_supplier as *mut _ as *mut std::os::raw::c_void,
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Try to claim a range in the publication log into which a message can be written with zero copy semantics."]
    #[doc = " Once the message has been written then aeron_buffer_claim_commit should be called thus making it available."]
    #[doc = " A claim length cannot be greater than max payload length."]
    #[doc = " \n"]
    #[doc = " <b>Note:</b> This method can only be used for message lengths less than MTU length minus header."]
    #[doc = " If the claim is held for more than the aeron.publication.unblock.timeout system property then the driver will"]
    #[doc = " assume the publication thread is dead and will unblock the claim thus allowing other threads to make progress"]
    #[doc = " and other claims to be sent to reach end-of-stream (EOS)."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " `AeronBufferClaim` buffer_claim;"]
    #[doc = ""]
    #[doc = " if (`AeronPublication`ry_claim(publication, length, &buffer_claim) > 0L)"]
    #[doc = " {"]
    #[doc = "     // work with buffer_claim->data directly."]
    #[doc = "     aeron_buffer_claim_commit(&buffer_claim);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `length` of the message."]
    #[doc = " \n - `buffer_claim` to be populated if the claim succeeds."]
    #[doc = " \n# Return\n the new stream position otherwise a negative error value."]
    pub fn try_claim(&self, length: usize, buffer_claim: &AeronBufferClaim) -> i64 {
        unsafe {
            let result = aeron_publication_try_claim(
                self.get_inner(),
                length.into(),
                buffer_claim.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the status of the media channel for this publication."]
    #[doc = " \n"]
    #[doc = " The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well."]
    #[doc = ""]
    #[doc = " \n# Return\n 1 for ACTIVE, -1 for ERRORED"]
    pub fn channel_status(&self) -> i64 {
        unsafe {
            let result = aeron_publication_channel_status(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Has the publication closed?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if this publication is closed."]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_publication_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Has the publication seen an active Subscriber recently?"]
    #[doc = ""]
    #[doc = " \n# Return\n true if this publication has recently seen an active subscriber otherwise false."]
    pub fn is_connected(&self) -> bool {
        unsafe {
            let result = aeron_publication_is_connected(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a publication."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `publication` to get the constants for."]
    #[doc = " \n - `constants` structure to fill in with the constants"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn constants(&self, constants: &AeronPublicationConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a publication."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronPublicationConstants, AeronCError> {
        let result = AeronPublicationConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Get the current position to which the publication has advanced for this stream."]
    #[doc = ""]
    #[doc = " \n# Return\n the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn position(&self) -> i64 {
        unsafe {
            let result = aeron_publication_position(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the position limit beyond which this publication will be back pressured."]
    #[doc = ""]
    #[doc = " This should only be used as a guide to determine when back pressure is likely to be applied."]
    #[doc = ""]
    #[doc = " \n# Return\n the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn position_limit(&self) -> i64 {
        unsafe {
            let result = aeron_publication_position_limit(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Asynchronously close the publication. Will callback on the on_complete notification when the publication is closed."]
    #[doc = " The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the publication has been closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn close<AeronNotificationHandlerImpl: AeronNotificationCallback>(
        &self,
        on_close_complete: Option<&Handler<AeronNotificationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_publication_close(
                self.get_inner(),
                {
                    let callback: aeron_notification_t = if on_close_complete.is_none() {
                        None
                    } else {
                        Some(aeron_notification_t_callback::<AeronNotificationHandlerImpl>)
                    };
                    callback
                },
                on_close_complete
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Asynchronously close the publication. Will callback on the on_complete notification when the publication is closed."]
    #[doc = " The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the publication has been closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn close_once<AeronNotificationHandlerImpl: FnMut() -> ()>(
        &self,
        mut on_close_complete: AeronNotificationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_publication_close(
                self.get_inner(),
                Some(
                    aeron_notification_t_callback_for_once_closure::<AeronNotificationHandlerImpl>,
                ),
                &mut on_close_complete as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Get the publication's channel"]
    #[doc = ""]
    #[doc = " \n# Return\n channel uri string"]
    pub fn channel(&self) -> &str {
        unsafe {
            let result = aeron_publication_channel(self.get_inner());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Get the publication's stream id"]
    #[doc = ""]
    #[doc = " \n# Return\n stream id"]
    pub fn stream_id(&self) -> i32 {
        unsafe {
            let result = aeron_publication_stream_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the publication's session id"]
    #[doc = " \n# Return\n session id"]
    pub fn session_id(&self) -> i32 {
        unsafe {
            let result = aeron_publication_session_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get all of the local socket addresses for this publication. Typically only one representing the control address."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `address_vec` to hold the received addresses"]
    #[doc = " \n - `address_vec_len` available length of the vector to hold the addresses"]
    #[doc = " \n# Return\n number of addresses found or -1 if there is an error."]
    #[doc = " @see aeron_subscription_local_`Sockaddr`s"]
    pub fn local_sockaddrs(
        &self,
        address_vec: &AeronIovec,
        address_vec_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_publication_local_sockaddrs(
                self.get_inner(),
                address_vec.get_inner(),
                address_vec_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_publication_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_publication_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_publication_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronPublication {
    type Target = aeron_publication_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_publication_t> for AeronPublication {
    #[inline]
    fn from(value: *mut aeron_publication_t) -> Self {
        AeronPublication {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronPublication> for *mut aeron_publication_t {
    #[inline]
    fn from(value: AeronPublication) -> Self {
        value.get_inner()
    }
}
impl From<&AeronPublication> for *mut aeron_publication_t {
    #[inline]
    fn from(value: &AeronPublication) -> Self {
        value.get_inner()
    }
}
impl From<AeronPublication> for aeron_publication_t {
    #[inline]
    fn from(value: AeronPublication) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_publication_t> for AeronPublication {
    #[inline]
    fn from(value: *const aeron_publication_t) -> Self {
        AeronPublication {
            inner: CResource::Borrowed(value as *mut aeron_publication_t),
        }
    }
}
impl From<aeron_publication_t> for AeronPublication {
    #[inline]
    fn from(value: aeron_publication_t) -> Self {
        AeronPublication {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronPublication {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronPublication));
                    let result = self.close_with_no_args();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronPublication));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronRbDescriptor {
    inner: CResource<aeron_rb_descriptor_t>,
}
impl core::fmt::Debug for AeronRbDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRbDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRbDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(tail_position), &self.tail_position())
                .field(stringify!(head_cache_position), &self.head_cache_position())
                .field(stringify!(head_position), &self.head_position())
                .field(stringify!(correlation_counter), &self.correlation_counter())
                .field(stringify!(consumer_heartbeat), &self.consumer_heartbeat())
                .finish()
        }
    }
}
impl AeronRbDescriptor {
    #[inline]
    pub fn new(
        begin_pad: [u8; 128usize],
        tail_position: i64,
        tail_pad: [u8; 120usize],
        head_cache_position: i64,
        head_cache_pad: [u8; 120usize],
        head_position: i64,
        head_pad: [u8; 120usize],
        correlation_counter: i64,
        correlation_counter_pad: [u8; 120usize],
        consumer_heartbeat: i64,
        consumer_heartbeat_pad: [u8; 120usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_rb_descriptor_t {
                    begin_pad: begin_pad.into(),
                    tail_position: tail_position.into(),
                    tail_pad: tail_pad.into(),
                    head_cache_position: head_cache_position.into(),
                    head_cache_pad: head_cache_pad.into(),
                    head_position: head_position.into(),
                    head_pad: head_pad.into(),
                    correlation_counter: correlation_counter.into(),
                    correlation_counter_pad: correlation_counter_pad.into(),
                    consumer_heartbeat: consumer_heartbeat.into(),
                    consumer_heartbeat_pad: consumer_heartbeat_pad.into(),
                };
                let inner_ptr: *mut aeron_rb_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_rb_descriptor_t)
                );
                let inst: aeron_rb_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_rb_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_rb_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn begin_pad(&self) -> [u8; 128usize] {
        self.begin_pad.into()
    }
    #[inline]
    pub fn tail_position(&self) -> i64 {
        self.tail_position.into()
    }
    #[inline]
    pub fn tail_pad(&self) -> [u8; 120usize] {
        self.tail_pad.into()
    }
    #[inline]
    pub fn head_cache_position(&self) -> i64 {
        self.head_cache_position.into()
    }
    #[inline]
    pub fn head_cache_pad(&self) -> [u8; 120usize] {
        self.head_cache_pad.into()
    }
    #[inline]
    pub fn head_position(&self) -> i64 {
        self.head_position.into()
    }
    #[inline]
    pub fn head_pad(&self) -> [u8; 120usize] {
        self.head_pad.into()
    }
    #[inline]
    pub fn correlation_counter(&self) -> i64 {
        self.correlation_counter.into()
    }
    #[inline]
    pub fn correlation_counter_pad(&self) -> [u8; 120usize] {
        self.correlation_counter_pad.into()
    }
    #[inline]
    pub fn consumer_heartbeat(&self) -> i64 {
        self.consumer_heartbeat.into()
    }
    #[inline]
    pub fn consumer_heartbeat_pad(&self) -> [u8; 120usize] {
        self.consumer_heartbeat_pad.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_rb_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_rb_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_rb_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRbDescriptor {
    type Target = aeron_rb_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_rb_descriptor_t> for AeronRbDescriptor {
    #[inline]
    fn from(value: *mut aeron_rb_descriptor_t) -> Self {
        AeronRbDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRbDescriptor> for *mut aeron_rb_descriptor_t {
    #[inline]
    fn from(value: AeronRbDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRbDescriptor> for *mut aeron_rb_descriptor_t {
    #[inline]
    fn from(value: &AeronRbDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronRbDescriptor> for aeron_rb_descriptor_t {
    #[inline]
    fn from(value: AeronRbDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_rb_descriptor_t> for AeronRbDescriptor {
    #[inline]
    fn from(value: *const aeron_rb_descriptor_t) -> Self {
        AeronRbDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_rb_descriptor_t),
        }
    }
}
impl From<aeron_rb_descriptor_t> for AeronRbDescriptor {
    #[inline]
    fn from(value: aeron_rb_descriptor_t) -> Self {
        AeronRbDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRbDescriptor {
    fn default() -> Self {
        AeronRbDescriptor::new_zeroed_on_heap()
    }
}
impl AeronRbDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRbRecordDescriptor {
    inner: CResource<aeron_rb_record_descriptor_t>,
}
impl core::fmt::Debug for AeronRbRecordDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRbRecordDescriptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRbRecordDescriptor))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .field(stringify!(msg_type_id), &self.msg_type_id())
                .finish()
        }
    }
}
impl AeronRbRecordDescriptor {
    #[inline]
    pub fn new(length: i32, msg_type_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_rb_record_descriptor_t {
                    length: length.into(),
                    msg_type_id: msg_type_id.into(),
                };
                let inner_ptr: *mut aeron_rb_record_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_rb_record_descriptor_t)
                );
                let inst: aeron_rb_record_descriptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_rb_record_descriptor_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_rb_record_descriptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn length(&self) -> i32 {
        self.length.into()
    }
    #[inline]
    pub fn msg_type_id(&self) -> i32 {
        self.msg_type_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_rb_record_descriptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_rb_record_descriptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_rb_record_descriptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRbRecordDescriptor {
    type Target = aeron_rb_record_descriptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_rb_record_descriptor_t> for AeronRbRecordDescriptor {
    #[inline]
    fn from(value: *mut aeron_rb_record_descriptor_t) -> Self {
        AeronRbRecordDescriptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRbRecordDescriptor> for *mut aeron_rb_record_descriptor_t {
    #[inline]
    fn from(value: AeronRbRecordDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRbRecordDescriptor> for *mut aeron_rb_record_descriptor_t {
    #[inline]
    fn from(value: &AeronRbRecordDescriptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronRbRecordDescriptor> for aeron_rb_record_descriptor_t {
    #[inline]
    fn from(value: AeronRbRecordDescriptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_rb_record_descriptor_t> for AeronRbRecordDescriptor {
    #[inline]
    fn from(value: *const aeron_rb_record_descriptor_t) -> Self {
        AeronRbRecordDescriptor {
            inner: CResource::Borrowed(value as *mut aeron_rb_record_descriptor_t),
        }
    }
}
impl From<aeron_rb_record_descriptor_t> for AeronRbRecordDescriptor {
    #[inline]
    fn from(value: aeron_rb_record_descriptor_t) -> Self {
        AeronRbRecordDescriptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRbRecordDescriptor {
    fn default() -> Self {
        AeronRbRecordDescriptor::new_zeroed_on_heap()
    }
}
impl AeronRbRecordDescriptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronReceiveChannelEndpointEntry {
    inner: CResource<aeron_receive_channel_endpoint_entry_t>,
}
impl core::fmt::Debug for AeronReceiveChannelEndpointEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronReceiveChannelEndpointEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronReceiveChannelEndpointEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronReceiveChannelEndpointEntry {
    #[inline]
    pub fn new(endpoint: &AeronReceiveChannelEndpoint) -> Result<Self, AeronCError> {
        let endpoint_copy = endpoint.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_receive_channel_endpoint_entry_t {
                    endpoint: endpoint.into(),
                };
                let inner_ptr: *mut aeron_receive_channel_endpoint_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_receive_channel_endpoint_entry_t)
                );
                let inst: aeron_receive_channel_endpoint_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_receive_channel_endpoint_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_receive_channel_endpoint_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn endpoint(&self) -> AeronReceiveChannelEndpoint {
        self.endpoint.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_receive_channel_endpoint_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_receive_channel_endpoint_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_receive_channel_endpoint_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronReceiveChannelEndpointEntry {
    type Target = aeron_receive_channel_endpoint_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_receive_channel_endpoint_entry_t> for AeronReceiveChannelEndpointEntry {
    #[inline]
    fn from(value: *mut aeron_receive_channel_endpoint_entry_t) -> Self {
        AeronReceiveChannelEndpointEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronReceiveChannelEndpointEntry> for *mut aeron_receive_channel_endpoint_entry_t {
    #[inline]
    fn from(value: AeronReceiveChannelEndpointEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronReceiveChannelEndpointEntry> for *mut aeron_receive_channel_endpoint_entry_t {
    #[inline]
    fn from(value: &AeronReceiveChannelEndpointEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronReceiveChannelEndpointEntry> for aeron_receive_channel_endpoint_entry_t {
    #[inline]
    fn from(value: AeronReceiveChannelEndpointEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_receive_channel_endpoint_entry_t> for AeronReceiveChannelEndpointEntry {
    #[inline]
    fn from(value: *const aeron_receive_channel_endpoint_entry_t) -> Self {
        AeronReceiveChannelEndpointEntry {
            inner: CResource::Borrowed(value as *mut aeron_receive_channel_endpoint_entry_t),
        }
    }
}
impl From<aeron_receive_channel_endpoint_entry_t> for AeronReceiveChannelEndpointEntry {
    #[inline]
    fn from(value: aeron_receive_channel_endpoint_entry_t) -> Self {
        AeronReceiveChannelEndpointEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronReceiveChannelEndpointEntry {
    fn default() -> Self {
        AeronReceiveChannelEndpointEntry::new_zeroed_on_heap()
    }
}
impl AeronReceiveChannelEndpointEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronReceiveChannelEndpoint {
    inner: CResource<aeron_receive_channel_endpoint_t>,
}
impl core::fmt::Debug for AeronReceiveChannelEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronReceiveChannelEndpoint))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronReceiveChannelEndpoint))
                .field("inner", &self.inner)
                .field(stringify!(dispatcher), &self.dispatcher())
                .field(
                    stringify!(stream_id_to_refcnt_map),
                    &self.stream_id_to_refcnt_map(),
                )
                .field(
                    stringify!(stream_and_session_id_to_refcnt_map),
                    &self.stream_and_session_id_to_refcnt_map(),
                )
                .field(
                    stringify!(response_stream_id_to_refcnt_map),
                    &self.response_stream_id_to_refcnt_map(),
                )
                .field(stringify!(channel_status), &self.channel_status())
                .field(stringify!(receiver_id), &self.receiver_id())
                .field(
                    stringify!(has_receiver_released),
                    &self.has_receiver_released(),
                )
                .finish()
        }
    }
}
impl AeronReceiveChannelEndpoint {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_receive_channel_endpoint_t)
                );
                let inst: aeron_receive_channel_endpoint_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_receive_channel_endpoint_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_receive_channel_endpoint_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct
    {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn destinations(&self) -> aeron_receive_channel_endpoint_stct_destination_stct {
        self.destinations.into()
    }
    #[inline]
    pub fn dispatcher(&self) -> AeronDataPacketDispatcher {
        self.dispatcher.into()
    }
    #[inline]
    pub fn stream_id_to_refcnt_map(&self) -> AeronInt64CounterMap {
        self.stream_id_to_refcnt_map.into()
    }
    #[inline]
    pub fn stream_and_session_id_to_refcnt_map(&self) -> AeronInt64CounterMap {
        self.stream_and_session_id_to_refcnt_map.into()
    }
    #[inline]
    pub fn response_stream_id_to_refcnt_map(&self) -> AeronInt64CounterMap {
        self.response_stream_id_to_refcnt_map.into()
    }
    #[inline]
    pub fn channel_status(&self) -> AeronAtomicCounter {
        self.channel_status.into()
    }
    #[inline]
    pub fn receiver_proxy(&self) -> AeronDriverReceiverProxy {
        self.receiver_proxy.into()
    }
    #[inline]
    pub fn transport_bindings(&self) -> *mut aeron_udp_channel_transport_bindings_t {
        self.transport_bindings.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn send_nak_message(&self) -> aeron_driver_nak_message_func_t {
        self.send_nak_message.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn has_receiver_released(&self) -> bool {
        self.has_receiver_released.into()
    }
    #[inline]
    pub fn group_tag(&self) -> aeron_receive_channel_endpoint_stct__bindgen_ty_1 {
        self.group_tag.into()
    }
    #[inline]
    pub fn short_sends_counter(&self) -> &mut i64 {
        unsafe { &mut *self.short_sends_counter }
    }
    #[inline]
    pub fn possible_ttl_asymmetry_counter(&self) -> &mut i64 {
        unsafe { &mut *self.possible_ttl_asymmetry_counter }
    }
    #[inline]
    pub fn errors_frames_sent_counter(&self) -> &mut i64 {
        unsafe { &mut *self.errors_frames_sent_counter }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_receive_channel_endpoint_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send(
        &self,
        destination: &AeronReceiveDestination,
        address: &SockaddrStorage,
        iov: &Iovec,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_send(
                self.get_inner(),
                destination.get_inner(),
                address.get_inner(),
                iov.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn elicit_setup(&self, stream_id: i32, session_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_elicit_setup(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_sm(
        &self,
        destination: &AeronReceiveDestination,
        control_addr: &SockaddrStorage,
        stream_id: i32,
        session_id: i32,
        term_id: i32,
        term_offset: i32,
        receiver_window: i32,
        flags: u8,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_send_sm(
                self.get_inner(),
                destination.get_inner(),
                control_addr.get_inner(),
                stream_id.into(),
                session_id.into(),
                term_id.into(),
                term_offset.into(),
                receiver_window.into(),
                flags.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_nak(
        &self,
        destination: &AeronReceiveDestination,
        addr: &SockaddrStorage,
        stream_id: i32,
        session_id: i32,
        term_id: i32,
        term_offset: i32,
        length: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_send_nak(
                self.get_inner(),
                destination.get_inner(),
                addr.get_inner(),
                stream_id.into(),
                session_id.into(),
                term_id.into(),
                term_offset.into(),
                length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_rttm(
        &self,
        destination: &AeronReceiveDestination,
        addr: &SockaddrStorage,
        stream_id: i32,
        session_id: i32,
        echo_timestamp: i64,
        reception_delta: i64,
        is_reply: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_send_rttm(
                self.get_inner(),
                destination.get_inner(),
                addr.get_inner(),
                stream_id.into(),
                session_id.into(),
                echo_timestamp.into(),
                reception_delta.into(),
                is_reply.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send_response_setup(
        &self,
        destination: &AeronReceiveDestination,
        addr: &SockaddrStorage,
        stream_id: i32,
        session_id: i32,
        response_session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_send_response_setup(
                self.get_inner(),
                destination.get_inner(),
                addr.get_inner(),
                stream_id.into(),
                session_id.into(),
                response_session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_receiver_channel_endpoint_send_error_frame(
        &self,
        destination: &AeronReceiveDestination,
        control_addr: &SockaddrStorage,
        session_id: i32,
        stream_id: i32,
        error_code: i32,
        invalidation_reason: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receiver_channel_endpoint_send_error_frame(
                self.get_inner(),
                destination.get_inner(),
                control_addr.get_inner(),
                session_id.into(),
                stream_id.into(),
                error_code.into(),
                invalidation_reason.as_ptr(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_data(
        &self,
        destination: &AeronReceiveDestination,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
        media_receive_timestamp: &Timespec,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_data(
                self.get_inner(),
                destination.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
                media_receive_timestamp.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_setup(
        &self,
        destination: &AeronReceiveDestination,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_setup(
                self.get_inner(),
                destination.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_rttm(
        &self,
        destination: &AeronReceiveDestination,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_rttm(
                self.get_inner(),
                destination.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_unconnected_stream(
        &self,
        destination: &AeronReceiveDestination,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_unconnected_stream(
                self.get_inner(),
                destination.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn matches_tag(&self, channel: &AeronUdpChannel) -> Result<bool, AeronCError> {
        unsafe {
            let mut mut_result: bool = Default::default();
            let err_code = aeron_receive_channel_endpoint_matches_tag(
                self.get_inner(),
                channel.get_inner(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn try_remove_endpoint(&self) -> () {
        unsafe {
            let result = aeron_receive_channel_endpoint_try_remove_endpoint(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn incref_to_stream(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_receive_channel_endpoint_incref_to_stream(self.get_inner(), stream_id.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn decref_to_stream(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_receive_channel_endpoint_decref_to_stream(self.get_inner(), stream_id.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn incref_to_stream_and_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_incref_to_stream_and_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn decref_to_stream_and_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_decref_to_stream_and_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn incref_to_response_stream(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_incref_to_response_stream(
                self.get_inner(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn decref_to_response_stream(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_decref_to_response_stream(
                self.get_inner(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_subscription(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_add_subscription(
                self.get_inner(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_subscription(&self, stream_id: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_remove_subscription(
                self.get_inner(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_subscription_by_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_add_subscription_by_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_subscription_by_session(
        &self,
        stream_id: i32,
        session_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_remove_subscription_by_session(
                self.get_inner(),
                stream_id.into(),
                session_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_destination(
        &self,
        destination: &AeronReceiveDestination,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_add_destination(
                self.get_inner(),
                destination.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_add_publication_image(
        &self,
        image: &AeronPublicationImage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_add_publication_image(
                self.get_inner(),
                image.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_remove_publication_image(
        &self,
        image: &AeronPublicationImage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_on_remove_publication_image(
                self.get_inner(),
                image.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_receiver_channel_endpoint_validate_sender_mtu_length(
        &self,
        sender_mtu_length: usize,
        window_max_length: usize,
        ctx: &AeronDriverContext,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receiver_channel_endpoint_validate_sender_mtu_length(
                self.get_inner(),
                sender_mtu_length.into(),
                window_max_length.into(),
                ctx.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn check_for_re_resolution(
        &self,
        now_ns: i64,
        conductor_proxy: &AeronDriverConductorProxy,
    ) -> () {
        unsafe {
            let result = aeron_receive_channel_endpoint_check_for_re_resolution(
                self.get_inner(),
                now_ns.into(),
                conductor_proxy.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn update_control_address(
        &self,
        destination: &AeronReceiveDestination,
        address: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_receive_channel_endpoint_update_control_address(
                self.get_inner(),
                destination.get_inner(),
                address.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn add_poll_transports(
        &self,
        poller: *mut aeron_udp_transport_poller_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_receive_channel_endpoint_add_poll_transports(self.get_inner(), poller.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_poll_transports(
        &self,
        poller: *mut aeron_udp_transport_poller_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_remove_poll_transports(
                self.get_inner(),
                poller.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_pending_setup(
        &self,
        receiver: &AeronDriverReceiver,
        session_id: i32,
        stream_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_add_pending_setup(
                self.get_inner(),
                receiver.get_inner(),
                session_id.into(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn add_pending_setup_destination(
        &self,
        receiver: &AeronDriverReceiver,
        destination: &AeronReceiveDestination,
        session_id: i32,
        stream_id: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_receive_channel_endpoint_add_pending_setup_destination(
                self.get_inner(),
                receiver.get_inner(),
                destination.get_inner(),
                session_id.into(),
                stream_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_receive_channel_endpoint_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_receive_channel_endpoint_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_receive_channel_endpoint_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronReceiveChannelEndpoint {
    type Target = aeron_receive_channel_endpoint_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_receive_channel_endpoint_t> for AeronReceiveChannelEndpoint {
    #[inline]
    fn from(value: *mut aeron_receive_channel_endpoint_t) -> Self {
        AeronReceiveChannelEndpoint {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronReceiveChannelEndpoint> for *mut aeron_receive_channel_endpoint_t {
    #[inline]
    fn from(value: AeronReceiveChannelEndpoint) -> Self {
        value.get_inner()
    }
}
impl From<&AeronReceiveChannelEndpoint> for *mut aeron_receive_channel_endpoint_t {
    #[inline]
    fn from(value: &AeronReceiveChannelEndpoint) -> Self {
        value.get_inner()
    }
}
impl From<AeronReceiveChannelEndpoint> for aeron_receive_channel_endpoint_t {
    #[inline]
    fn from(value: AeronReceiveChannelEndpoint) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_receive_channel_endpoint_t> for AeronReceiveChannelEndpoint {
    #[inline]
    fn from(value: *const aeron_receive_channel_endpoint_t) -> Self {
        AeronReceiveChannelEndpoint {
            inner: CResource::Borrowed(value as *mut aeron_receive_channel_endpoint_t),
        }
    }
}
impl From<aeron_receive_channel_endpoint_t> for AeronReceiveChannelEndpoint {
    #[inline]
    fn from(value: aeron_receive_channel_endpoint_t) -> Self {
        AeronReceiveChannelEndpoint {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronReceiveChannelEndpoint {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronReceiveChannelEndpoint));
                    let result = self.close();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronReceiveChannelEndpoint));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronReceiveDestinationEntry {
    inner: CResource<aeron_receive_destination_entry_t>,
}
impl core::fmt::Debug for AeronReceiveDestinationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronReceiveDestinationEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronReceiveDestinationEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronReceiveDestinationEntry {
    #[inline]
    pub fn new(destination: &AeronReceiveDestination) -> Result<Self, AeronCError> {
        let destination_copy = destination.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_receive_destination_entry_t {
                    destination: destination.into(),
                };
                let inner_ptr: *mut aeron_receive_destination_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_receive_destination_entry_t)
                );
                let inst: aeron_receive_destination_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_receive_destination_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_receive_destination_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn destination(&self) -> AeronReceiveDestination {
        self.destination.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_receive_destination_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_receive_destination_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_receive_destination_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronReceiveDestinationEntry {
    type Target = aeron_receive_destination_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_receive_destination_entry_t> for AeronReceiveDestinationEntry {
    #[inline]
    fn from(value: *mut aeron_receive_destination_entry_t) -> Self {
        AeronReceiveDestinationEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronReceiveDestinationEntry> for *mut aeron_receive_destination_entry_t {
    #[inline]
    fn from(value: AeronReceiveDestinationEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronReceiveDestinationEntry> for *mut aeron_receive_destination_entry_t {
    #[inline]
    fn from(value: &AeronReceiveDestinationEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronReceiveDestinationEntry> for aeron_receive_destination_entry_t {
    #[inline]
    fn from(value: AeronReceiveDestinationEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_receive_destination_entry_t> for AeronReceiveDestinationEntry {
    #[inline]
    fn from(value: *const aeron_receive_destination_entry_t) -> Self {
        AeronReceiveDestinationEntry {
            inner: CResource::Borrowed(value as *mut aeron_receive_destination_entry_t),
        }
    }
}
impl From<aeron_receive_destination_entry_t> for AeronReceiveDestinationEntry {
    #[inline]
    fn from(value: aeron_receive_destination_entry_t) -> Self {
        AeronReceiveDestinationEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronReceiveDestinationEntry {
    fn default() -> Self {
        AeronReceiveDestinationEntry::new_zeroed_on_heap()
    }
}
impl AeronReceiveDestinationEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronReceiveDestination {
    inner: CResource<aeron_receive_destination_t>,
}
impl core::fmt::Debug for AeronReceiveDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronReceiveDestination))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronReceiveDestination))
                .field("inner", &self.inner)
                .field(
                    stringify!(local_sockaddr_indicator),
                    &self.local_sockaddr_indicator(),
                )
                .field(
                    stringify!(current_control_addr),
                    &self.current_control_addr(),
                )
                .field(stringify!(bind_addr), &self.bind_addr())
                .field(stringify!(so_rcvbuf), &self.so_rcvbuf())
                .field(stringify!(has_control_addr), &self.has_control_addr())
                .field(
                    stringify!(time_of_last_activity_ns),
                    &self.time_of_last_activity_ns(),
                )
                .finish()
        }
    }
}
impl AeronReceiveDestination {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_receive_destination_t)
                );
                let inst: aeron_receive_destination_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_receive_destination_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_receive_destination_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn transport(&self) -> aeron_udp_channel_transport_t {
        self.transport.into()
    }
    #[inline]
    pub fn data_paths(&self) -> AeronUdpChannelDataPaths {
        self.data_paths.into()
    }
    #[inline]
    pub fn port_manager(&self) -> AeronPortManager {
        self.port_manager.into()
    }
    #[inline]
    pub fn local_sockaddr_indicator(&self) -> AeronAtomicCounter {
        self.local_sockaddr_indicator.into()
    }
    #[inline]
    pub fn current_control_addr(&self) -> SockaddrStorage {
        self.current_control_addr.into()
    }
    #[inline]
    pub fn bind_addr(&self) -> SockaddrStorage {
        self.bind_addr.into()
    }
    #[inline]
    pub fn so_rcvbuf(&self) -> usize {
        self.so_rcvbuf.into()
    }
    #[inline]
    pub fn has_control_addr(&self) -> bool {
        self.has_control_addr.into()
    }
    #[inline]
    pub fn time_of_last_activity_ns(&self) -> i64 {
        self.time_of_last_activity_ns.into()
    }
    #[inline]
    pub fn padding(&self) -> [u8; 64usize] {
        self.padding.into()
    }
    #[inline]
    pub fn delete(&self, counters_manager: &AeronCountersManager) -> () {
        unsafe {
            let result =
                aeron_receive_destination_delete(self.get_inner(), counters_manager.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_receive_destination_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_receive_destination_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_receive_destination_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronReceiveDestination {
    type Target = aeron_receive_destination_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_receive_destination_t> for AeronReceiveDestination {
    #[inline]
    fn from(value: *mut aeron_receive_destination_t) -> Self {
        AeronReceiveDestination {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronReceiveDestination> for *mut aeron_receive_destination_t {
    #[inline]
    fn from(value: AeronReceiveDestination) -> Self {
        value.get_inner()
    }
}
impl From<&AeronReceiveDestination> for *mut aeron_receive_destination_t {
    #[inline]
    fn from(value: &AeronReceiveDestination) -> Self {
        value.get_inner()
    }
}
impl From<AeronReceiveDestination> for aeron_receive_destination_t {
    #[inline]
    fn from(value: AeronReceiveDestination) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_receive_destination_t> for AeronReceiveDestination {
    #[inline]
    fn from(value: *const aeron_receive_destination_t) -> Self {
        AeronReceiveDestination {
            inner: CResource::Borrowed(value as *mut aeron_receive_destination_t),
        }
    }
}
impl From<aeron_receive_destination_t> for AeronReceiveDestination {
    #[inline]
    fn from(value: aeron_receive_destination_t) -> Self {
        AeronReceiveDestination {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronRejectImageCommand {
    inner: CResource<aeron_reject_image_command_t>,
}
impl core::fmt::Debug for AeronRejectImageCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRejectImageCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRejectImageCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(
                    stringify!(image_correlation_id),
                    &self.image_correlation_id(),
                )
                .field(stringify!(position), &self.position())
                .field(stringify!(reason_length), &self.reason_length())
                .finish()
        }
    }
}
impl AeronRejectImageCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        image_correlation_id: i64,
        position: i64,
        reason_length: i32,
        reason_text: [u8; 1usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_reject_image_command_t {
                    correlated: correlated.into(),
                    image_correlation_id: image_correlation_id.into(),
                    position: position.into(),
                    reason_length: reason_length.into(),
                    reason_text: reason_text.into(),
                };
                let inner_ptr: *mut aeron_reject_image_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_reject_image_command_t)
                );
                let inst: aeron_reject_image_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_reject_image_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_reject_image_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn image_correlation_id(&self) -> i64 {
        self.image_correlation_id.into()
    }
    #[inline]
    pub fn position(&self) -> i64 {
        self.position.into()
    }
    #[inline]
    pub fn reason_length(&self) -> i32 {
        self.reason_length.into()
    }
    #[inline]
    pub fn reason_text(&self) -> [u8; 1usize] {
        self.reason_text.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_reject_image_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_reject_image_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_reject_image_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRejectImageCommand {
    type Target = aeron_reject_image_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_reject_image_command_t> for AeronRejectImageCommand {
    #[inline]
    fn from(value: *mut aeron_reject_image_command_t) -> Self {
        AeronRejectImageCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRejectImageCommand> for *mut aeron_reject_image_command_t {
    #[inline]
    fn from(value: AeronRejectImageCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRejectImageCommand> for *mut aeron_reject_image_command_t {
    #[inline]
    fn from(value: &AeronRejectImageCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronRejectImageCommand> for aeron_reject_image_command_t {
    #[inline]
    fn from(value: AeronRejectImageCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_reject_image_command_t> for AeronRejectImageCommand {
    #[inline]
    fn from(value: *const aeron_reject_image_command_t) -> Self {
        AeronRejectImageCommand {
            inner: CResource::Borrowed(value as *mut aeron_reject_image_command_t),
        }
    }
}
impl From<aeron_reject_image_command_t> for AeronRejectImageCommand {
    #[inline]
    fn from(value: aeron_reject_image_command_t) -> Self {
        AeronRejectImageCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRejectImageCommand {
    fn default() -> Self {
        AeronRejectImageCommand::new_zeroed_on_heap()
    }
}
impl AeronRejectImageCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRemoveCounterCommand {
    inner: CResource<aeron_remove_counter_command_t>,
}
impl core::fmt::Debug for AeronRemoveCounterCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRemoveCounterCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRemoveCounterCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(registration_id), &self.registration_id())
                .finish()
        }
    }
}
impl AeronRemoveCounterCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_id: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_remove_counter_command_t {
                    correlated: correlated.into(),
                    registration_id: registration_id.into(),
                };
                let inner_ptr: *mut aeron_remove_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_remove_counter_command_t)
                );
                let inst: aeron_remove_counter_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_remove_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_remove_counter_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_remove_counter_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_remove_counter_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_remove_counter_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRemoveCounterCommand {
    type Target = aeron_remove_counter_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_remove_counter_command_t> for AeronRemoveCounterCommand {
    #[inline]
    fn from(value: *mut aeron_remove_counter_command_t) -> Self {
        AeronRemoveCounterCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRemoveCounterCommand> for *mut aeron_remove_counter_command_t {
    #[inline]
    fn from(value: AeronRemoveCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRemoveCounterCommand> for *mut aeron_remove_counter_command_t {
    #[inline]
    fn from(value: &AeronRemoveCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronRemoveCounterCommand> for aeron_remove_counter_command_t {
    #[inline]
    fn from(value: AeronRemoveCounterCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_remove_counter_command_t> for AeronRemoveCounterCommand {
    #[inline]
    fn from(value: *const aeron_remove_counter_command_t) -> Self {
        AeronRemoveCounterCommand {
            inner: CResource::Borrowed(value as *mut aeron_remove_counter_command_t),
        }
    }
}
impl From<aeron_remove_counter_command_t> for AeronRemoveCounterCommand {
    #[inline]
    fn from(value: aeron_remove_counter_command_t) -> Self {
        AeronRemoveCounterCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRemoveCounterCommand {
    fn default() -> Self {
        AeronRemoveCounterCommand::new_zeroed_on_heap()
    }
}
impl AeronRemoveCounterCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRemovePublicationCommand {
    inner: CResource<aeron_remove_publication_command_t>,
}
impl core::fmt::Debug for AeronRemovePublicationCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRemovePublicationCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRemovePublicationCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(flags), &self.flags())
                .finish()
        }
    }
}
impl AeronRemovePublicationCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_id: i64,
        flags: u64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_remove_publication_command_t {
                    correlated: correlated.into(),
                    registration_id: registration_id.into(),
                    flags: flags.into(),
                };
                let inner_ptr: *mut aeron_remove_publication_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_remove_publication_command_t)
                );
                let inst: aeron_remove_publication_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_remove_publication_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_remove_publication_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn flags(&self) -> u64 {
        self.flags.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_remove_publication_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_remove_publication_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_remove_publication_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRemovePublicationCommand {
    type Target = aeron_remove_publication_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_remove_publication_command_t> for AeronRemovePublicationCommand {
    #[inline]
    fn from(value: *mut aeron_remove_publication_command_t) -> Self {
        AeronRemovePublicationCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRemovePublicationCommand> for *mut aeron_remove_publication_command_t {
    #[inline]
    fn from(value: AeronRemovePublicationCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRemovePublicationCommand> for *mut aeron_remove_publication_command_t {
    #[inline]
    fn from(value: &AeronRemovePublicationCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronRemovePublicationCommand> for aeron_remove_publication_command_t {
    #[inline]
    fn from(value: AeronRemovePublicationCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_remove_publication_command_t> for AeronRemovePublicationCommand {
    #[inline]
    fn from(value: *const aeron_remove_publication_command_t) -> Self {
        AeronRemovePublicationCommand {
            inner: CResource::Borrowed(value as *mut aeron_remove_publication_command_t),
        }
    }
}
impl From<aeron_remove_publication_command_t> for AeronRemovePublicationCommand {
    #[inline]
    fn from(value: aeron_remove_publication_command_t) -> Self {
        AeronRemovePublicationCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRemovePublicationCommand {
    fn default() -> Self {
        AeronRemovePublicationCommand::new_zeroed_on_heap()
    }
}
impl AeronRemovePublicationCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRemoveSubscriptionCommand {
    inner: CResource<aeron_remove_subscription_command_t>,
}
impl core::fmt::Debug for AeronRemoveSubscriptionCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRemoveSubscriptionCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRemoveSubscriptionCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(registration_id), &self.registration_id())
                .finish()
        }
    }
}
impl AeronRemoveSubscriptionCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_id: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_remove_subscription_command_t {
                    correlated: correlated.into(),
                    registration_id: registration_id.into(),
                };
                let inner_ptr: *mut aeron_remove_subscription_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_remove_subscription_command_t)
                );
                let inst: aeron_remove_subscription_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_remove_subscription_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_remove_subscription_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_remove_subscription_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_remove_subscription_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_remove_subscription_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRemoveSubscriptionCommand {
    type Target = aeron_remove_subscription_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_remove_subscription_command_t> for AeronRemoveSubscriptionCommand {
    #[inline]
    fn from(value: *mut aeron_remove_subscription_command_t) -> Self {
        AeronRemoveSubscriptionCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRemoveSubscriptionCommand> for *mut aeron_remove_subscription_command_t {
    #[inline]
    fn from(value: AeronRemoveSubscriptionCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRemoveSubscriptionCommand> for *mut aeron_remove_subscription_command_t {
    #[inline]
    fn from(value: &AeronRemoveSubscriptionCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronRemoveSubscriptionCommand> for aeron_remove_subscription_command_t {
    #[inline]
    fn from(value: AeronRemoveSubscriptionCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_remove_subscription_command_t> for AeronRemoveSubscriptionCommand {
    #[inline]
    fn from(value: *const aeron_remove_subscription_command_t) -> Self {
        AeronRemoveSubscriptionCommand {
            inner: CResource::Borrowed(value as *mut aeron_remove_subscription_command_t),
        }
    }
}
impl From<aeron_remove_subscription_command_t> for AeronRemoveSubscriptionCommand {
    #[inline]
    fn from(value: aeron_remove_subscription_command_t) -> Self {
        AeronRemoveSubscriptionCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRemoveSubscriptionCommand {
    fn default() -> Self {
        AeronRemoveSubscriptionCommand::new_zeroed_on_heap()
    }
}
impl AeronRemoveSubscriptionCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronResolutionHeaderIpv4 {
    inner: CResource<aeron_resolution_header_ipv4_t>,
}
impl core::fmt::Debug for AeronResolutionHeaderIpv4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronResolutionHeaderIpv4))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronResolutionHeaderIpv4))
                .field("inner", &self.inner)
                .field(stringify!(resolution_header), &self.resolution_header())
                .field(stringify!(name_length), &self.name_length())
                .finish()
        }
    }
}
impl AeronResolutionHeaderIpv4 {
    #[inline]
    pub fn new(
        resolution_header: AeronResolutionHeader,
        addr: [u8; 4usize],
        name_length: i16,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_resolution_header_ipv4_t {
                    resolution_header: resolution_header.into(),
                    addr: addr.into(),
                    name_length: name_length.into(),
                };
                let inner_ptr: *mut aeron_resolution_header_ipv4_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_resolution_header_ipv4_t)
                );
                let inst: aeron_resolution_header_ipv4_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_resolution_header_ipv4_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_resolution_header_ipv4_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn resolution_header(&self) -> AeronResolutionHeader {
        self.resolution_header.into()
    }
    #[inline]
    pub fn addr(&self) -> [u8; 4usize] {
        self.addr.into()
    }
    #[inline]
    pub fn name_length(&self) -> i16 {
        self.name_length.into()
    }
    #[inline]
    pub fn aeron_res_header_entry_length_ipv4(&self) -> usize {
        unsafe {
            let result = aeron_res_header_entry_length_ipv4(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_resolution_header_ipv4_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_resolution_header_ipv4_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_resolution_header_ipv4_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronResolutionHeaderIpv4 {
    type Target = aeron_resolution_header_ipv4_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_resolution_header_ipv4_t> for AeronResolutionHeaderIpv4 {
    #[inline]
    fn from(value: *mut aeron_resolution_header_ipv4_t) -> Self {
        AeronResolutionHeaderIpv4 {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronResolutionHeaderIpv4> for *mut aeron_resolution_header_ipv4_t {
    #[inline]
    fn from(value: AeronResolutionHeaderIpv4) -> Self {
        value.get_inner()
    }
}
impl From<&AeronResolutionHeaderIpv4> for *mut aeron_resolution_header_ipv4_t {
    #[inline]
    fn from(value: &AeronResolutionHeaderIpv4) -> Self {
        value.get_inner()
    }
}
impl From<AeronResolutionHeaderIpv4> for aeron_resolution_header_ipv4_t {
    #[inline]
    fn from(value: AeronResolutionHeaderIpv4) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_resolution_header_ipv4_t> for AeronResolutionHeaderIpv4 {
    #[inline]
    fn from(value: *const aeron_resolution_header_ipv4_t) -> Self {
        AeronResolutionHeaderIpv4 {
            inner: CResource::Borrowed(value as *mut aeron_resolution_header_ipv4_t),
        }
    }
}
impl From<aeron_resolution_header_ipv4_t> for AeronResolutionHeaderIpv4 {
    #[inline]
    fn from(value: aeron_resolution_header_ipv4_t) -> Self {
        AeronResolutionHeaderIpv4 {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronResolutionHeaderIpv4 {
    fn default() -> Self {
        AeronResolutionHeaderIpv4::new_zeroed_on_heap()
    }
}
impl AeronResolutionHeaderIpv4 {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronResolutionHeaderIpv6 {
    inner: CResource<aeron_resolution_header_ipv6_t>,
}
impl core::fmt::Debug for AeronResolutionHeaderIpv6 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronResolutionHeaderIpv6))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronResolutionHeaderIpv6))
                .field("inner", &self.inner)
                .field(stringify!(resolution_header), &self.resolution_header())
                .field(stringify!(name_length), &self.name_length())
                .finish()
        }
    }
}
impl AeronResolutionHeaderIpv6 {
    #[inline]
    pub fn new(
        resolution_header: AeronResolutionHeader,
        addr: [u8; 16usize],
        name_length: i16,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_resolution_header_ipv6_t {
                    resolution_header: resolution_header.into(),
                    addr: addr.into(),
                    name_length: name_length.into(),
                };
                let inner_ptr: *mut aeron_resolution_header_ipv6_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_resolution_header_ipv6_t)
                );
                let inst: aeron_resolution_header_ipv6_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_resolution_header_ipv6_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_resolution_header_ipv6_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn resolution_header(&self) -> AeronResolutionHeader {
        self.resolution_header.into()
    }
    #[inline]
    pub fn addr(&self) -> [u8; 16usize] {
        self.addr.into()
    }
    #[inline]
    pub fn name_length(&self) -> i16 {
        self.name_length.into()
    }
    #[inline]
    pub fn aeron_res_header_entry_length_ipv6(&self) -> usize {
        unsafe {
            let result = aeron_res_header_entry_length_ipv6(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_resolution_header_ipv6_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_resolution_header_ipv6_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_resolution_header_ipv6_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronResolutionHeaderIpv6 {
    type Target = aeron_resolution_header_ipv6_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_resolution_header_ipv6_t> for AeronResolutionHeaderIpv6 {
    #[inline]
    fn from(value: *mut aeron_resolution_header_ipv6_t) -> Self {
        AeronResolutionHeaderIpv6 {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronResolutionHeaderIpv6> for *mut aeron_resolution_header_ipv6_t {
    #[inline]
    fn from(value: AeronResolutionHeaderIpv6) -> Self {
        value.get_inner()
    }
}
impl From<&AeronResolutionHeaderIpv6> for *mut aeron_resolution_header_ipv6_t {
    #[inline]
    fn from(value: &AeronResolutionHeaderIpv6) -> Self {
        value.get_inner()
    }
}
impl From<AeronResolutionHeaderIpv6> for aeron_resolution_header_ipv6_t {
    #[inline]
    fn from(value: AeronResolutionHeaderIpv6) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_resolution_header_ipv6_t> for AeronResolutionHeaderIpv6 {
    #[inline]
    fn from(value: *const aeron_resolution_header_ipv6_t) -> Self {
        AeronResolutionHeaderIpv6 {
            inner: CResource::Borrowed(value as *mut aeron_resolution_header_ipv6_t),
        }
    }
}
impl From<aeron_resolution_header_ipv6_t> for AeronResolutionHeaderIpv6 {
    #[inline]
    fn from(value: aeron_resolution_header_ipv6_t) -> Self {
        AeronResolutionHeaderIpv6 {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronResolutionHeaderIpv6 {
    fn default() -> Self {
        AeronResolutionHeaderIpv6::new_zeroed_on_heap()
    }
}
impl AeronResolutionHeaderIpv6 {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronResolutionHeader {
    inner: CResource<aeron_resolution_header_t>,
}
impl core::fmt::Debug for AeronResolutionHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronResolutionHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronResolutionHeader))
                .field("inner", &self.inner)
                .field(stringify!(udp_port), &self.udp_port())
                .field(stringify!(age_in_ms), &self.age_in_ms())
                .finish()
        }
    }
}
impl AeronResolutionHeader {
    #[inline]
    pub fn new(
        res_type: i8,
        res_flags: u8,
        udp_port: u16,
        age_in_ms: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_resolution_header_t {
                    res_type: res_type.into(),
                    res_flags: res_flags.into(),
                    udp_port: udp_port.into(),
                    age_in_ms: age_in_ms.into(),
                };
                let inner_ptr: *mut aeron_resolution_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_resolution_header_t)
                );
                let inst: aeron_resolution_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_resolution_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_resolution_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn res_type(&self) -> i8 {
        self.res_type.into()
    }
    #[inline]
    pub fn res_flags(&self) -> u8 {
        self.res_flags.into()
    }
    #[inline]
    pub fn udp_port(&self) -> u16 {
        self.udp_port.into()
    }
    #[inline]
    pub fn age_in_ms(&self) -> i32 {
        self.age_in_ms.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_resolution_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_resolution_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_resolution_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronResolutionHeader {
    type Target = aeron_resolution_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_resolution_header_t> for AeronResolutionHeader {
    #[inline]
    fn from(value: *mut aeron_resolution_header_t) -> Self {
        AeronResolutionHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronResolutionHeader> for *mut aeron_resolution_header_t {
    #[inline]
    fn from(value: AeronResolutionHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronResolutionHeader> for *mut aeron_resolution_header_t {
    #[inline]
    fn from(value: &AeronResolutionHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronResolutionHeader> for aeron_resolution_header_t {
    #[inline]
    fn from(value: AeronResolutionHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_resolution_header_t> for AeronResolutionHeader {
    #[inline]
    fn from(value: *const aeron_resolution_header_t) -> Self {
        AeronResolutionHeader {
            inner: CResource::Borrowed(value as *mut aeron_resolution_header_t),
        }
    }
}
impl From<aeron_resolution_header_t> for AeronResolutionHeader {
    #[inline]
    fn from(value: aeron_resolution_header_t) -> Self {
        AeronResolutionHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronResolutionHeader {
    fn default() -> Self {
        AeronResolutionHeader::new_zeroed_on_heap()
    }
}
impl AeronResolutionHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronResponseSetupHeader {
    inner: CResource<aeron_response_setup_header_t>,
}
impl core::fmt::Debug for AeronResponseSetupHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronResponseSetupHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronResponseSetupHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(response_session_id), &self.response_session_id())
                .finish()
        }
    }
}
impl AeronResponseSetupHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        session_id: i32,
        stream_id: i32,
        response_session_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_response_setup_header_t {
                    frame_header: frame_header.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    response_session_id: response_session_id.into(),
                };
                let inner_ptr: *mut aeron_response_setup_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_response_setup_header_t)
                );
                let inst: aeron_response_setup_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_response_setup_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_response_setup_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn response_session_id(&self) -> i32 {
        self.response_session_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_response_setup_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_response_setup_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_response_setup_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronResponseSetupHeader {
    type Target = aeron_response_setup_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_response_setup_header_t> for AeronResponseSetupHeader {
    #[inline]
    fn from(value: *mut aeron_response_setup_header_t) -> Self {
        AeronResponseSetupHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronResponseSetupHeader> for *mut aeron_response_setup_header_t {
    #[inline]
    fn from(value: AeronResponseSetupHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronResponseSetupHeader> for *mut aeron_response_setup_header_t {
    #[inline]
    fn from(value: &AeronResponseSetupHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronResponseSetupHeader> for aeron_response_setup_header_t {
    #[inline]
    fn from(value: AeronResponseSetupHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_response_setup_header_t> for AeronResponseSetupHeader {
    #[inline]
    fn from(value: *const aeron_response_setup_header_t) -> Self {
        AeronResponseSetupHeader {
            inner: CResource::Borrowed(value as *mut aeron_response_setup_header_t),
        }
    }
}
impl From<aeron_response_setup_header_t> for AeronResponseSetupHeader {
    #[inline]
    fn from(value: aeron_response_setup_header_t) -> Self {
        AeronResponseSetupHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronResponseSetupHeader {
    fn default() -> Self {
        AeronResponseSetupHeader::new_zeroed_on_heap()
    }
}
impl AeronResponseSetupHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRetransmitAction {
    inner: CResource<aeron_retransmit_action_t>,
}
impl core::fmt::Debug for AeronRetransmitAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRetransmitAction))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRetransmitAction))
                .field("inner", &self.inner)
                .field(stringify!(expiry_ns), &self.expiry_ns())
                .field(stringify!(term_id), &self.term_id())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronRetransmitAction {
    #[inline]
    pub fn new(
        expiry_ns: i64,
        term_id: i32,
        term_offset: i32,
        length: usize,
        state: aeron_retransmit_action_state_t,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_retransmit_action_t {
                    expiry_ns: expiry_ns.into(),
                    term_id: term_id.into(),
                    term_offset: term_offset.into(),
                    length: length.into(),
                    state: state.into(),
                };
                let inner_ptr: *mut aeron_retransmit_action_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_retransmit_action_t)
                );
                let inst: aeron_retransmit_action_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_retransmit_action_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_retransmit_action_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn expiry_ns(&self) -> i64 {
        self.expiry_ns.into()
    }
    #[inline]
    pub fn term_id(&self) -> i32 {
        self.term_id.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline]
    pub fn state(&self) -> aeron_retransmit_action_state_t {
        self.state.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_retransmit_action_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_retransmit_action_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_retransmit_action_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRetransmitAction {
    type Target = aeron_retransmit_action_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_retransmit_action_t> for AeronRetransmitAction {
    #[inline]
    fn from(value: *mut aeron_retransmit_action_t) -> Self {
        AeronRetransmitAction {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRetransmitAction> for *mut aeron_retransmit_action_t {
    #[inline]
    fn from(value: AeronRetransmitAction) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRetransmitAction> for *mut aeron_retransmit_action_t {
    #[inline]
    fn from(value: &AeronRetransmitAction) -> Self {
        value.get_inner()
    }
}
impl From<AeronRetransmitAction> for aeron_retransmit_action_t {
    #[inline]
    fn from(value: AeronRetransmitAction) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_retransmit_action_t> for AeronRetransmitAction {
    #[inline]
    fn from(value: *const aeron_retransmit_action_t) -> Self {
        AeronRetransmitAction {
            inner: CResource::Borrowed(value as *mut aeron_retransmit_action_t),
        }
    }
}
impl From<aeron_retransmit_action_t> for AeronRetransmitAction {
    #[inline]
    fn from(value: aeron_retransmit_action_t) -> Self {
        AeronRetransmitAction {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRetransmitAction {
    fn default() -> Self {
        AeronRetransmitAction::new_zeroed_on_heap()
    }
}
impl AeronRetransmitAction {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRetransmitHandler {
    inner: CResource<aeron_retransmit_handler_t>,
}
impl core::fmt::Debug for AeronRetransmitHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRetransmitHandler))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRetransmitHandler))
                .field("inner", &self.inner)
                .field(stringify!(delay_timeout_ns), &self.delay_timeout_ns())
                .field(stringify!(linger_timeout_ns), &self.linger_timeout_ns())
                .field(stringify!(has_group_semantics), &self.has_group_semantics())
                .field(stringify!(max_retransmits), &self.max_retransmits())
                .finish()
        }
    }
}
impl AeronRetransmitHandler {
    #[inline]
    pub fn new(
        retransmit_action_pool: &AeronRetransmitAction,
        delay_timeout_ns: u64,
        linger_timeout_ns: u64,
        invalid_packets_counter: &mut i64,
        active_retransmit_count: ::std::os::raw::c_int,
        has_group_semantics: bool,
        max_retransmits: usize,
        retransmit_overflow_counter: &mut i64,
    ) -> Result<Self, AeronCError> {
        let retransmit_action_pool_copy = retransmit_action_pool.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_retransmit_handler_t {
                    retransmit_action_pool: retransmit_action_pool.into(),
                    delay_timeout_ns: delay_timeout_ns.into(),
                    linger_timeout_ns: linger_timeout_ns.into(),
                    invalid_packets_counter: invalid_packets_counter as *mut _,
                    active_retransmit_count: active_retransmit_count.into(),
                    has_group_semantics: has_group_semantics.into(),
                    max_retransmits: max_retransmits.into(),
                    retransmit_overflow_counter: retransmit_overflow_counter as *mut _,
                };
                let inner_ptr: *mut aeron_retransmit_handler_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_retransmit_handler_t)
                );
                let inst: aeron_retransmit_handler_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_retransmit_handler_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_retransmit_handler_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn retransmit_action_pool(&self) -> AeronRetransmitAction {
        self.retransmit_action_pool.into()
    }
    #[inline]
    pub fn delay_timeout_ns(&self) -> u64 {
        self.delay_timeout_ns.into()
    }
    #[inline]
    pub fn linger_timeout_ns(&self) -> u64 {
        self.linger_timeout_ns.into()
    }
    #[inline]
    pub fn invalid_packets_counter(&self) -> &mut i64 {
        unsafe { &mut *self.invalid_packets_counter }
    }
    #[inline]
    pub fn active_retransmit_count(&self) -> ::std::os::raw::c_int {
        self.active_retransmit_count.into()
    }
    #[inline]
    pub fn has_group_semantics(&self) -> bool {
        self.has_group_semantics.into()
    }
    #[inline]
    pub fn max_retransmits(&self) -> usize {
        self.max_retransmits.into()
    }
    #[inline]
    pub fn retransmit_overflow_counter(&self) -> &mut i64 {
        unsafe { &mut *self.retransmit_overflow_counter }
    }
    #[inline]
    pub fn init(
        &self,
        invalid_packets_counter: &mut i64,
        delay_timeout_ns: u64,
        linger_timeout_ns: u64,
        has_group_semantics: bool,
        max_retransmits: u32,
        retransmit_overflow_counter: &mut i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_retransmit_handler_init(
                self.get_inner(),
                invalid_packets_counter as *mut _,
                delay_timeout_ns.into(),
                linger_timeout_ns.into(),
                has_group_semantics.into(),
                max_retransmits.into(),
                retransmit_overflow_counter as *mut _,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_retransmit_handler_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn on_nak<
        AeronRetransmitHandlerResendFuncHandlerImpl: AeronRetransmitHandlerResendFuncCallback,
    >(
        &self,
        term_id: i32,
        term_offset: i32,
        length: usize,
        term_length: usize,
        mtu_length: usize,
        flow_control: &AeronFlowControlStrategy,
        now_ns: i64,
        resend: Option<&Handler<AeronRetransmitHandlerResendFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_retransmit_handler_on_nak(
                self.get_inner(),
                term_id.into(),
                term_offset.into(),
                length.into(),
                term_length.into(),
                mtu_length.into(),
                flow_control.get_inner(),
                now_ns.into(),
                {
                    let callback: aeron_retransmit_handler_resend_func_t = if resend.is_none() {
                        None
                    } else {
                        Some(
                            aeron_retransmit_handler_resend_func_t_callback::<
                                AeronRetransmitHandlerResendFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                resend
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn on_nak_once<
        AeronRetransmitHandlerResendFuncHandlerImpl: FnMut(i32, i32, usize) -> ::std::os::raw::c_int,
    >(
        &self,
        term_id: i32,
        term_offset: i32,
        length: usize,
        term_length: usize,
        mtu_length: usize,
        flow_control: &AeronFlowControlStrategy,
        now_ns: i64,
        mut resend: AeronRetransmitHandlerResendFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_retransmit_handler_on_nak(
                self.get_inner(),
                term_id.into(),
                term_offset.into(),
                length.into(),
                term_length.into(),
                mtu_length.into(),
                flow_control.get_inner(),
                now_ns.into(),
                Some(
                    aeron_retransmit_handler_resend_func_t_callback_for_once_closure::<
                        AeronRetransmitHandlerResendFuncHandlerImpl,
                    >,
                ),
                &mut resend as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn process_timeouts<
        AeronRetransmitHandlerResendFuncHandlerImpl: AeronRetransmitHandlerResendFuncCallback,
    >(
        &self,
        now_ns: i64,
        resend: Option<&Handler<AeronRetransmitHandlerResendFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_retransmit_handler_process_timeouts(
                self.get_inner(),
                now_ns.into(),
                {
                    let callback: aeron_retransmit_handler_resend_func_t = if resend.is_none() {
                        None
                    } else {
                        Some(
                            aeron_retransmit_handler_resend_func_t_callback::<
                                AeronRetransmitHandlerResendFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                resend
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn process_timeouts_once<
        AeronRetransmitHandlerResendFuncHandlerImpl: FnMut(i32, i32, usize) -> ::std::os::raw::c_int,
    >(
        &self,
        now_ns: i64,
        mut resend: AeronRetransmitHandlerResendFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_retransmit_handler_process_timeouts(
                self.get_inner(),
                now_ns.into(),
                Some(
                    aeron_retransmit_handler_resend_func_t_callback_for_once_closure::<
                        AeronRetransmitHandlerResendFuncHandlerImpl,
                    >,
                ),
                &mut resend as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_retransmit_handler_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_retransmit_handler_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_retransmit_handler_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRetransmitHandler {
    type Target = aeron_retransmit_handler_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_retransmit_handler_t> for AeronRetransmitHandler {
    #[inline]
    fn from(value: *mut aeron_retransmit_handler_t) -> Self {
        AeronRetransmitHandler {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRetransmitHandler> for *mut aeron_retransmit_handler_t {
    #[inline]
    fn from(value: AeronRetransmitHandler) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRetransmitHandler> for *mut aeron_retransmit_handler_t {
    #[inline]
    fn from(value: &AeronRetransmitHandler) -> Self {
        value.get_inner()
    }
}
impl From<AeronRetransmitHandler> for aeron_retransmit_handler_t {
    #[inline]
    fn from(value: AeronRetransmitHandler) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_retransmit_handler_t> for AeronRetransmitHandler {
    #[inline]
    fn from(value: *const aeron_retransmit_handler_t) -> Self {
        AeronRetransmitHandler {
            inner: CResource::Borrowed(value as *mut aeron_retransmit_handler_t),
        }
    }
}
impl From<aeron_retransmit_handler_t> for AeronRetransmitHandler {
    #[inline]
    fn from(value: aeron_retransmit_handler_t) -> Self {
        AeronRetransmitHandler {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRetransmitHandler {
    fn default() -> Self {
        AeronRetransmitHandler::new_zeroed_on_heap()
    }
}
impl AeronRetransmitHandler {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronRttmHeader {
    inner: CResource<aeron_rttm_header_t>,
}
impl core::fmt::Debug for AeronRttmHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronRttmHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronRttmHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(echo_timestamp), &self.echo_timestamp())
                .field(stringify!(reception_delta), &self.reception_delta())
                .field(stringify!(receiver_id), &self.receiver_id())
                .finish()
        }
    }
}
impl AeronRttmHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        session_id: i32,
        stream_id: i32,
        echo_timestamp: i64,
        reception_delta: i64,
        receiver_id: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_rttm_header_t {
                    frame_header: frame_header.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    echo_timestamp: echo_timestamp.into(),
                    reception_delta: reception_delta.into(),
                    receiver_id: receiver_id.into(),
                };
                let inner_ptr: *mut aeron_rttm_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_rttm_header_t)
                );
                let inst: aeron_rttm_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_rttm_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_rttm_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn echo_timestamp(&self) -> i64 {
        self.echo_timestamp.into()
    }
    #[inline]
    pub fn reception_delta(&self) -> i64 {
        self.reception_delta.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_rttm_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_rttm_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_rttm_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronRttmHeader {
    type Target = aeron_rttm_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_rttm_header_t> for AeronRttmHeader {
    #[inline]
    fn from(value: *mut aeron_rttm_header_t) -> Self {
        AeronRttmHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronRttmHeader> for *mut aeron_rttm_header_t {
    #[inline]
    fn from(value: AeronRttmHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronRttmHeader> for *mut aeron_rttm_header_t {
    #[inline]
    fn from(value: &AeronRttmHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronRttmHeader> for aeron_rttm_header_t {
    #[inline]
    fn from(value: AeronRttmHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_rttm_header_t> for AeronRttmHeader {
    #[inline]
    fn from(value: *const aeron_rttm_header_t) -> Self {
        AeronRttmHeader {
            inner: CResource::Borrowed(value as *mut aeron_rttm_header_t),
        }
    }
}
impl From<aeron_rttm_header_t> for AeronRttmHeader {
    #[inline]
    fn from(value: aeron_rttm_header_t) -> Self {
        AeronRttmHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronRttmHeader {
    fn default() -> Self {
        AeronRttmHeader::new_zeroed_on_heap()
    }
}
impl AeronRttmHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSendChannelEndpointEntry {
    inner: CResource<aeron_send_channel_endpoint_entry_t>,
}
impl core::fmt::Debug for AeronSendChannelEndpointEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSendChannelEndpointEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSendChannelEndpointEntry))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronSendChannelEndpointEntry {
    #[inline]
    pub fn new(endpoint: &AeronSendChannelEndpoint) -> Result<Self, AeronCError> {
        let endpoint_copy = endpoint.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_send_channel_endpoint_entry_t {
                    endpoint: endpoint.into(),
                };
                let inner_ptr: *mut aeron_send_channel_endpoint_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_send_channel_endpoint_entry_t)
                );
                let inst: aeron_send_channel_endpoint_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_send_channel_endpoint_entry_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_send_channel_endpoint_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn endpoint(&self) -> AeronSendChannelEndpoint {
        self.endpoint.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_send_channel_endpoint_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_send_channel_endpoint_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_send_channel_endpoint_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSendChannelEndpointEntry {
    type Target = aeron_send_channel_endpoint_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_send_channel_endpoint_entry_t> for AeronSendChannelEndpointEntry {
    #[inline]
    fn from(value: *mut aeron_send_channel_endpoint_entry_t) -> Self {
        AeronSendChannelEndpointEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSendChannelEndpointEntry> for *mut aeron_send_channel_endpoint_entry_t {
    #[inline]
    fn from(value: AeronSendChannelEndpointEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSendChannelEndpointEntry> for *mut aeron_send_channel_endpoint_entry_t {
    #[inline]
    fn from(value: &AeronSendChannelEndpointEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronSendChannelEndpointEntry> for aeron_send_channel_endpoint_entry_t {
    #[inline]
    fn from(value: AeronSendChannelEndpointEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_send_channel_endpoint_entry_t> for AeronSendChannelEndpointEntry {
    #[inline]
    fn from(value: *const aeron_send_channel_endpoint_entry_t) -> Self {
        AeronSendChannelEndpointEntry {
            inner: CResource::Borrowed(value as *mut aeron_send_channel_endpoint_entry_t),
        }
    }
}
impl From<aeron_send_channel_endpoint_entry_t> for AeronSendChannelEndpointEntry {
    #[inline]
    fn from(value: aeron_send_channel_endpoint_entry_t) -> Self {
        AeronSendChannelEndpointEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSendChannelEndpointEntry {
    fn default() -> Self {
        AeronSendChannelEndpointEntry::new_zeroed_on_heap()
    }
}
impl AeronSendChannelEndpointEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSendChannelEndpoint {
    inner: CResource<aeron_send_channel_endpoint_t>,
}
impl core::fmt::Debug for AeronSendChannelEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSendChannelEndpoint))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSendChannelEndpoint))
                .field("inner", &self.inner)
                .field(stringify!(has_sender_released), &self.has_sender_released())
                .field(stringify!(channel_status), &self.channel_status())
                .field(
                    stringify!(local_sockaddr_indicator),
                    &self.local_sockaddr_indicator(),
                )
                .field(
                    stringify!(tracker_num_destinations),
                    &self.tracker_num_destinations(),
                )
                .field(
                    stringify!(publication_dispatch_map),
                    &self.publication_dispatch_map(),
                )
                .field(stringify!(current_data_addr), &self.current_data_addr())
                .field(stringify!(bind_addr), &self.bind_addr())
                .field(stringify!(time_of_last_sm_ns), &self.time_of_last_sm_ns())
                .finish()
        }
    }
}
impl AeronSendChannelEndpoint {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_send_channel_endpoint_t)
                );
                let inst: aeron_send_channel_endpoint_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_send_channel_endpoint_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_send_channel_endpoint_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn conductor_fields(
        &self,
    ) -> aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct {
        self.conductor_fields.into()
    }
    #[inline]
    pub fn has_sender_released(&self) -> bool {
        self.has_sender_released.into()
    }
    #[inline]
    pub fn transport(&self) -> aeron_udp_channel_transport_t {
        self.transport.into()
    }
    #[inline]
    pub fn channel_status(&self) -> AeronAtomicCounter {
        self.channel_status.into()
    }
    #[inline]
    pub fn local_sockaddr_indicator(&self) -> AeronAtomicCounter {
        self.local_sockaddr_indicator.into()
    }
    #[inline]
    pub fn tracker_num_destinations(&self) -> AeronAtomicCounter {
        self.tracker_num_destinations.into()
    }
    #[inline]
    pub fn destination_tracker(&self) -> AeronUdpDestinationTracker {
        self.destination_tracker.into()
    }
    #[inline]
    pub fn sender_proxy(&self) -> AeronDriverSenderProxy {
        self.sender_proxy.into()
    }
    #[inline]
    pub fn publication_dispatch_map(&self) -> AeronInt64ToPtrHashMap {
        self.publication_dispatch_map.into()
    }
    #[inline]
    pub fn transport_bindings(&self) -> *mut aeron_udp_channel_transport_bindings_t {
        self.transport_bindings.into()
    }
    #[inline]
    pub fn data_paths(&self) -> AeronUdpChannelDataPaths {
        self.data_paths.into()
    }
    #[inline]
    pub fn current_data_addr(&self) -> SockaddrStorage {
        self.current_data_addr.into()
    }
    #[inline]
    pub fn bind_addr(&self) -> SockaddrStorage {
        self.bind_addr.into()
    }
    #[inline]
    pub fn port_manager(&self) -> AeronPortManager {
        self.port_manager.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn time_of_last_sm_ns(&self) -> i64 {
        self.time_of_last_sm_ns.into()
    }
    #[inline]
    pub fn on_nak_message(&self) -> aeron_driver_nak_message_func_t {
        self.on_nak_message.into()
    }
    #[inline]
    pub fn padding(&self) -> [u8; 64usize] {
        self.padding.into()
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_send_channel_endpoint_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_send_channel_send(
        &self,
        iov: &Iovec,
        iov_length: usize,
    ) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_send_channel_send(
                self.get_inner(),
                iov.get_inner(),
                iov_length.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_send_channel_send_endpoint_address(
        &self,
        endpoint_address: &SockaddrStorage,
        iov: &Iovec,
        iov_length: usize,
    ) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_send_channel_send_endpoint_address(
                self.get_inner(),
                endpoint_address.get_inner(),
                iov.get_inner(),
                iov_length.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn add_publication(
        &self,
        publication: &AeronNetworkPublication,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_add_publication(
                self.get_inner(),
                publication.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn remove_publication(
        &self,
        publication: &AeronNetworkPublication,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_remove_publication(
                self.get_inner(),
                publication.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_nak(&self, buffer: &mut [u8], addr: &SockaddrStorage) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_on_nak(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_status_message(
        &self,
        conductor_proxy: &AeronDriverConductorProxy,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_on_status_message(
                self.get_inner(),
                conductor_proxy.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_error(
        &self,
        conductor_proxy: &AeronDriverConductorProxy,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_on_error(
                self.get_inner(),
                conductor_proxy.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn on_rttm(&self, buffer: &mut [u8], addr: &SockaddrStorage) -> () {
        unsafe {
            let result = aeron_send_channel_endpoint_on_rttm(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn on_response_setup(
        &self,
        conductor_proxy: &AeronDriverConductorProxy,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result = aeron_send_channel_endpoint_on_response_setup(
                self.get_inner(),
                conductor_proxy.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn check_for_re_resolution(
        &self,
        now_ns: i64,
        conductor_proxy: &AeronDriverConductorProxy,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_send_channel_endpoint_check_for_re_resolution(
                self.get_inner(),
                now_ns.into(),
                conductor_proxy.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn matches_tag(&self, channel: &AeronUdpChannel) -> Result<bool, AeronCError> {
        unsafe {
            let mut mut_result: bool = Default::default();
            let err_code = aeron_send_channel_endpoint_matches_tag(
                self.get_inner(),
                channel.get_inner(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_send_channel_endpoint_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_send_channel_endpoint_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_send_channel_endpoint_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSendChannelEndpoint {
    type Target = aeron_send_channel_endpoint_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_send_channel_endpoint_t> for AeronSendChannelEndpoint {
    #[inline]
    fn from(value: *mut aeron_send_channel_endpoint_t) -> Self {
        AeronSendChannelEndpoint {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSendChannelEndpoint> for *mut aeron_send_channel_endpoint_t {
    #[inline]
    fn from(value: AeronSendChannelEndpoint) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSendChannelEndpoint> for *mut aeron_send_channel_endpoint_t {
    #[inline]
    fn from(value: &AeronSendChannelEndpoint) -> Self {
        value.get_inner()
    }
}
impl From<AeronSendChannelEndpoint> for aeron_send_channel_endpoint_t {
    #[inline]
    fn from(value: AeronSendChannelEndpoint) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_send_channel_endpoint_t> for AeronSendChannelEndpoint {
    #[inline]
    fn from(value: *const aeron_send_channel_endpoint_t) -> Self {
        AeronSendChannelEndpoint {
            inner: CResource::Borrowed(value as *mut aeron_send_channel_endpoint_t),
        }
    }
}
impl From<aeron_send_channel_endpoint_t> for AeronSendChannelEndpoint {
    #[inline]
    fn from(value: aeron_send_channel_endpoint_t) -> Self {
        AeronSendChannelEndpoint {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronSendChannelEndpoint {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronSendChannelEndpoint));
                    let result = self.close();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronSendChannelEndpoint));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronSetupHeader {
    inner: CResource<aeron_setup_header_t>,
}
impl core::fmt::Debug for AeronSetupHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSetupHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSetupHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(term_offset), &self.term_offset())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(initial_term_id), &self.initial_term_id())
                .field(stringify!(active_term_id), &self.active_term_id())
                .field(stringify!(term_length), &self.term_length())
                .field(stringify!(mtu), &self.mtu())
                .field(stringify!(ttl), &self.ttl())
                .finish()
        }
    }
}
impl AeronSetupHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        term_offset: i32,
        session_id: i32,
        stream_id: i32,
        initial_term_id: i32,
        active_term_id: i32,
        term_length: i32,
        mtu: i32,
        ttl: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_setup_header_t {
                    frame_header: frame_header.into(),
                    term_offset: term_offset.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    initial_term_id: initial_term_id.into(),
                    active_term_id: active_term_id.into(),
                    term_length: term_length.into(),
                    mtu: mtu.into(),
                    ttl: ttl.into(),
                };
                let inner_ptr: *mut aeron_setup_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_setup_header_t)
                );
                let inst: aeron_setup_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_setup_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_setup_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn term_offset(&self) -> i32 {
        self.term_offset.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn initial_term_id(&self) -> i32 {
        self.initial_term_id.into()
    }
    #[inline]
    pub fn active_term_id(&self) -> i32 {
        self.active_term_id.into()
    }
    #[inline]
    pub fn term_length(&self) -> i32 {
        self.term_length.into()
    }
    #[inline]
    pub fn mtu(&self) -> i32 {
        self.mtu.into()
    }
    #[inline]
    pub fn ttl(&self) -> i32 {
        self.ttl.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_setup_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_setup_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_setup_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSetupHeader {
    type Target = aeron_setup_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_setup_header_t> for AeronSetupHeader {
    #[inline]
    fn from(value: *mut aeron_setup_header_t) -> Self {
        AeronSetupHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSetupHeader> for *mut aeron_setup_header_t {
    #[inline]
    fn from(value: AeronSetupHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSetupHeader> for *mut aeron_setup_header_t {
    #[inline]
    fn from(value: &AeronSetupHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronSetupHeader> for aeron_setup_header_t {
    #[inline]
    fn from(value: AeronSetupHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_setup_header_t> for AeronSetupHeader {
    #[inline]
    fn from(value: *const aeron_setup_header_t) -> Self {
        AeronSetupHeader {
            inner: CResource::Borrowed(value as *mut aeron_setup_header_t),
        }
    }
}
impl From<aeron_setup_header_t> for AeronSetupHeader {
    #[inline]
    fn from(value: aeron_setup_header_t) -> Self {
        AeronSetupHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSetupHeader {
    fn default() -> Self {
        AeronSetupHeader::new_zeroed_on_heap()
    }
}
impl AeronSetupHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSpscConcurrentArrayQueue {
    inner: CResource<aeron_spsc_concurrent_array_queue_t>,
}
impl core::fmt::Debug for AeronSpscConcurrentArrayQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSpscConcurrentArrayQueue))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSpscConcurrentArrayQueue))
                .field("inner", &self.inner)
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(mask), &self.mask())
                .finish()
        }
    }
}
impl AeronSpscConcurrentArrayQueue {
    #[inline]
    pub fn new(
        padding: [i8; 56usize],
        producer: aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1,
        consumer: aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2,
        capacity: usize,
        mask: usize,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_spsc_concurrent_array_queue_t {
                    padding: padding.into(),
                    producer: producer.into(),
                    consumer: consumer.into(),
                    capacity: capacity.into(),
                    mask: mask.into(),
                    buffer: buffer.into(),
                };
                let inner_ptr: *mut aeron_spsc_concurrent_array_queue_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_spsc_concurrent_array_queue_t)
                );
                let inst: aeron_spsc_concurrent_array_queue_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_spsc_concurrent_array_queue_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_spsc_concurrent_array_queue_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding(&self) -> [i8; 56usize] {
        self.padding.into()
    }
    #[inline]
    pub fn producer(&self) -> aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1 {
        self.producer.into()
    }
    #[inline]
    pub fn consumer(&self) -> aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2 {
        self.consumer.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn mask(&self) -> usize {
        self.mask.into()
    }
    #[inline]
    pub fn buffer(&self) -> *mut *mut ::std::os::raw::c_void {
        self.buffer.into()
    }
    #[inline]
    pub fn init(&self, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_spsc_concurrent_array_queue_init(self.get_inner(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_spsc_concurrent_array_queue_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_spsc_concurrent_array_queue_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_spsc_concurrent_array_queue_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_spsc_concurrent_array_queue_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSpscConcurrentArrayQueue {
    type Target = aeron_spsc_concurrent_array_queue_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_spsc_concurrent_array_queue_t> for AeronSpscConcurrentArrayQueue {
    #[inline]
    fn from(value: *mut aeron_spsc_concurrent_array_queue_t) -> Self {
        AeronSpscConcurrentArrayQueue {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSpscConcurrentArrayQueue> for *mut aeron_spsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: AeronSpscConcurrentArrayQueue) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSpscConcurrentArrayQueue> for *mut aeron_spsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: &AeronSpscConcurrentArrayQueue) -> Self {
        value.get_inner()
    }
}
impl From<AeronSpscConcurrentArrayQueue> for aeron_spsc_concurrent_array_queue_t {
    #[inline]
    fn from(value: AeronSpscConcurrentArrayQueue) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_spsc_concurrent_array_queue_t> for AeronSpscConcurrentArrayQueue {
    #[inline]
    fn from(value: *const aeron_spsc_concurrent_array_queue_t) -> Self {
        AeronSpscConcurrentArrayQueue {
            inner: CResource::Borrowed(value as *mut aeron_spsc_concurrent_array_queue_t),
        }
    }
}
impl From<aeron_spsc_concurrent_array_queue_t> for AeronSpscConcurrentArrayQueue {
    #[inline]
    fn from(value: aeron_spsc_concurrent_array_queue_t) -> Self {
        AeronSpscConcurrentArrayQueue {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSpscConcurrentArrayQueue {
    fn default() -> Self {
        AeronSpscConcurrentArrayQueue::new_zeroed_on_heap()
    }
}
impl AeronSpscConcurrentArrayQueue {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStaticCounterCommand {
    inner: CResource<aeron_static_counter_command_t>,
}
impl core::fmt::Debug for AeronStaticCounterCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStaticCounterCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStaticCounterCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(type_id), &self.type_id())
                .finish()
        }
    }
}
impl AeronStaticCounterCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_id: i64,
        type_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_static_counter_command_t {
                    correlated: correlated.into(),
                    registration_id: registration_id.into(),
                    type_id: type_id.into(),
                };
                let inner_ptr: *mut aeron_static_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_static_counter_command_t)
                );
                let inst: aeron_static_counter_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_static_counter_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_static_counter_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn type_id(&self) -> i32 {
        self.type_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_static_counter_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_static_counter_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_static_counter_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStaticCounterCommand {
    type Target = aeron_static_counter_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_static_counter_command_t> for AeronStaticCounterCommand {
    #[inline]
    fn from(value: *mut aeron_static_counter_command_t) -> Self {
        AeronStaticCounterCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStaticCounterCommand> for *mut aeron_static_counter_command_t {
    #[inline]
    fn from(value: AeronStaticCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStaticCounterCommand> for *mut aeron_static_counter_command_t {
    #[inline]
    fn from(value: &AeronStaticCounterCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronStaticCounterCommand> for aeron_static_counter_command_t {
    #[inline]
    fn from(value: AeronStaticCounterCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_static_counter_command_t> for AeronStaticCounterCommand {
    #[inline]
    fn from(value: *const aeron_static_counter_command_t) -> Self {
        AeronStaticCounterCommand {
            inner: CResource::Borrowed(value as *mut aeron_static_counter_command_t),
        }
    }
}
impl From<aeron_static_counter_command_t> for AeronStaticCounterCommand {
    #[inline]
    fn from(value: aeron_static_counter_command_t) -> Self {
        AeronStaticCounterCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStaticCounterCommand {
    fn default() -> Self {
        AeronStaticCounterCommand::new_zeroed_on_heap()
    }
}
impl AeronStaticCounterCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStaticCounterResponse {
    inner: CResource<aeron_static_counter_response_t>,
}
impl core::fmt::Debug for AeronStaticCounterResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStaticCounterResponse))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStaticCounterResponse))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(counter_id), &self.counter_id())
                .finish()
        }
    }
}
impl AeronStaticCounterResponse {
    #[inline]
    pub fn new(correlation_id: i64, counter_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_static_counter_response_t {
                    correlation_id: correlation_id.into(),
                    counter_id: counter_id.into(),
                };
                let inner_ptr: *mut aeron_static_counter_response_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_static_counter_response_t)
                );
                let inst: aeron_static_counter_response_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_static_counter_response_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_static_counter_response_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_static_counter_response_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_static_counter_response_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_static_counter_response_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStaticCounterResponse {
    type Target = aeron_static_counter_response_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_static_counter_response_t> for AeronStaticCounterResponse {
    #[inline]
    fn from(value: *mut aeron_static_counter_response_t) -> Self {
        AeronStaticCounterResponse {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStaticCounterResponse> for *mut aeron_static_counter_response_t {
    #[inline]
    fn from(value: AeronStaticCounterResponse) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStaticCounterResponse> for *mut aeron_static_counter_response_t {
    #[inline]
    fn from(value: &AeronStaticCounterResponse) -> Self {
        value.get_inner()
    }
}
impl From<AeronStaticCounterResponse> for aeron_static_counter_response_t {
    #[inline]
    fn from(value: AeronStaticCounterResponse) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_static_counter_response_t> for AeronStaticCounterResponse {
    #[inline]
    fn from(value: *const aeron_static_counter_response_t) -> Self {
        AeronStaticCounterResponse {
            inner: CResource::Borrowed(value as *mut aeron_static_counter_response_t),
        }
    }
}
impl From<aeron_static_counter_response_t> for AeronStaticCounterResponse {
    #[inline]
    fn from(value: aeron_static_counter_response_t) -> Self {
        AeronStaticCounterResponse {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStaticCounterResponse {
    fn default() -> Self {
        AeronStaticCounterResponse::new_zeroed_on_heap()
    }
}
impl AeronStaticCounterResponse {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStatusMessageHeader {
    inner: CResource<aeron_status_message_header_t>,
}
impl core::fmt::Debug for AeronStatusMessageHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStatusMessageHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStatusMessageHeader))
                .field("inner", &self.inner)
                .field(stringify!(frame_header), &self.frame_header())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(consumption_term_id), &self.consumption_term_id())
                .field(
                    stringify!(consumption_term_offset),
                    &self.consumption_term_offset(),
                )
                .field(stringify!(receiver_window), &self.receiver_window())
                .field(stringify!(receiver_id), &self.receiver_id())
                .finish()
        }
    }
}
impl AeronStatusMessageHeader {
    #[inline]
    pub fn new(
        frame_header: AeronFrameHeader,
        session_id: i32,
        stream_id: i32,
        consumption_term_id: i32,
        consumption_term_offset: i32,
        receiver_window: i32,
        receiver_id: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_status_message_header_t {
                    frame_header: frame_header.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    consumption_term_id: consumption_term_id.into(),
                    consumption_term_offset: consumption_term_offset.into(),
                    receiver_window: receiver_window.into(),
                    receiver_id: receiver_id.into(),
                };
                let inner_ptr: *mut aeron_status_message_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_status_message_header_t)
                );
                let inst: aeron_status_message_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_status_message_header_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_status_message_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn frame_header(&self) -> AeronFrameHeader {
        self.frame_header.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn consumption_term_id(&self) -> i32 {
        self.consumption_term_id.into()
    }
    #[inline]
    pub fn consumption_term_offset(&self) -> i32 {
        self.consumption_term_offset.into()
    }
    #[inline]
    pub fn receiver_window(&self) -> i32 {
        self.receiver_window.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn aeron_udp_protocol_group_tag(&self) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_udp_protocol_group_tag(self.get_inner(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_status_message_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_status_message_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_status_message_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStatusMessageHeader {
    type Target = aeron_status_message_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_status_message_header_t> for AeronStatusMessageHeader {
    #[inline]
    fn from(value: *mut aeron_status_message_header_t) -> Self {
        AeronStatusMessageHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStatusMessageHeader> for *mut aeron_status_message_header_t {
    #[inline]
    fn from(value: AeronStatusMessageHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStatusMessageHeader> for *mut aeron_status_message_header_t {
    #[inline]
    fn from(value: &AeronStatusMessageHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronStatusMessageHeader> for aeron_status_message_header_t {
    #[inline]
    fn from(value: AeronStatusMessageHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_status_message_header_t> for AeronStatusMessageHeader {
    #[inline]
    fn from(value: *const aeron_status_message_header_t) -> Self {
        AeronStatusMessageHeader {
            inner: CResource::Borrowed(value as *mut aeron_status_message_header_t),
        }
    }
}
impl From<aeron_status_message_header_t> for AeronStatusMessageHeader {
    #[inline]
    fn from(value: aeron_status_message_header_t) -> Self {
        AeronStatusMessageHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStatusMessageHeader {
    fn default() -> Self {
        AeronStatusMessageHeader::new_zeroed_on_heap()
    }
}
impl AeronStatusMessageHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStatusMessageOptionalHeader {
    inner: CResource<aeron_status_message_optional_header_t>,
}
impl core::fmt::Debug for AeronStatusMessageOptionalHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStatusMessageOptionalHeader))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStatusMessageOptionalHeader))
                .field("inner", &self.inner)
                .field(stringify!(group_tag), &self.group_tag())
                .finish()
        }
    }
}
impl AeronStatusMessageOptionalHeader {
    #[inline]
    pub fn new(group_tag: i64) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_status_message_optional_header_t {
                    group_tag: group_tag.into(),
                };
                let inner_ptr: *mut aeron_status_message_optional_header_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_status_message_optional_header_t)
                );
                let inst: aeron_status_message_optional_header_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_status_message_optional_header_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_status_message_optional_header_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn group_tag(&self) -> i64 {
        self.group_tag.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_status_message_optional_header_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_status_message_optional_header_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_status_message_optional_header_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStatusMessageOptionalHeader {
    type Target = aeron_status_message_optional_header_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_status_message_optional_header_t> for AeronStatusMessageOptionalHeader {
    #[inline]
    fn from(value: *mut aeron_status_message_optional_header_t) -> Self {
        AeronStatusMessageOptionalHeader {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStatusMessageOptionalHeader> for *mut aeron_status_message_optional_header_t {
    #[inline]
    fn from(value: AeronStatusMessageOptionalHeader) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStatusMessageOptionalHeader> for *mut aeron_status_message_optional_header_t {
    #[inline]
    fn from(value: &AeronStatusMessageOptionalHeader) -> Self {
        value.get_inner()
    }
}
impl From<AeronStatusMessageOptionalHeader> for aeron_status_message_optional_header_t {
    #[inline]
    fn from(value: AeronStatusMessageOptionalHeader) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_status_message_optional_header_t> for AeronStatusMessageOptionalHeader {
    #[inline]
    fn from(value: *const aeron_status_message_optional_header_t) -> Self {
        AeronStatusMessageOptionalHeader {
            inner: CResource::Borrowed(value as *mut aeron_status_message_optional_header_t),
        }
    }
}
impl From<aeron_status_message_optional_header_t> for AeronStatusMessageOptionalHeader {
    #[inline]
    fn from(value: aeron_status_message_optional_header_t) -> Self {
        AeronStatusMessageOptionalHeader {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStatusMessageOptionalHeader {
    fn default() -> Self {
        AeronStatusMessageOptionalHeader::new_zeroed_on_heap()
    }
}
impl AeronStatusMessageOptionalHeader {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStrToPtrHashMapKey {
    inner: CResource<aeron_str_to_ptr_hash_map_key_t>,
}
impl core::fmt::Debug for AeronStrToPtrHashMapKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStrToPtrHashMapKey))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStrToPtrHashMapKey))
                .field("inner", &self.inner)
                .field(stringify!(hash_code), &self.hash_code())
                .field(stringify!(str_length), &self.str_length())
                .finish()
        }
    }
}
impl AeronStrToPtrHashMapKey {
    #[inline]
    pub fn new(
        str_: &std::ffi::CStr,
        hash_code: u64,
        str_length: usize,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_str_to_ptr_hash_map_key_t {
                    str_: str_.as_ptr(),
                    hash_code: hash_code.into(),
                    str_length: str_length.into(),
                };
                let inner_ptr: *mut aeron_str_to_ptr_hash_map_key_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_str_to_ptr_hash_map_key_t)
                );
                let inst: aeron_str_to_ptr_hash_map_key_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_str_to_ptr_hash_map_key_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_str_to_ptr_hash_map_key_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn str_(&self) -> &str {
        if self.str_.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.str_).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn hash_code(&self) -> u64 {
        self.hash_code.into()
    }
    #[inline]
    pub fn str_length(&self) -> usize {
        self.str_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_str_to_ptr_hash_map_key_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_str_to_ptr_hash_map_key_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_str_to_ptr_hash_map_key_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStrToPtrHashMapKey {
    type Target = aeron_str_to_ptr_hash_map_key_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_str_to_ptr_hash_map_key_t> for AeronStrToPtrHashMapKey {
    #[inline]
    fn from(value: *mut aeron_str_to_ptr_hash_map_key_t) -> Self {
        AeronStrToPtrHashMapKey {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStrToPtrHashMapKey> for *mut aeron_str_to_ptr_hash_map_key_t {
    #[inline]
    fn from(value: AeronStrToPtrHashMapKey) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStrToPtrHashMapKey> for *mut aeron_str_to_ptr_hash_map_key_t {
    #[inline]
    fn from(value: &AeronStrToPtrHashMapKey) -> Self {
        value.get_inner()
    }
}
impl From<AeronStrToPtrHashMapKey> for aeron_str_to_ptr_hash_map_key_t {
    #[inline]
    fn from(value: AeronStrToPtrHashMapKey) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_str_to_ptr_hash_map_key_t> for AeronStrToPtrHashMapKey {
    #[inline]
    fn from(value: *const aeron_str_to_ptr_hash_map_key_t) -> Self {
        AeronStrToPtrHashMapKey {
            inner: CResource::Borrowed(value as *mut aeron_str_to_ptr_hash_map_key_t),
        }
    }
}
impl From<aeron_str_to_ptr_hash_map_key_t> for AeronStrToPtrHashMapKey {
    #[inline]
    fn from(value: aeron_str_to_ptr_hash_map_key_t) -> Self {
        AeronStrToPtrHashMapKey {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStrToPtrHashMapKey {
    fn default() -> Self {
        AeronStrToPtrHashMapKey::new_zeroed_on_heap()
    }
}
impl AeronStrToPtrHashMapKey {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStrToPtrHashMap {
    inner: CResource<aeron_str_to_ptr_hash_map_t>,
}
impl core::fmt::Debug for AeronStrToPtrHashMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStrToPtrHashMap))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStrToPtrHashMap))
                .field("inner", &self.inner)
                .field(stringify!(load_factor), &self.load_factor())
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(size), &self.size())
                .field(stringify!(resize_threshold), &self.resize_threshold())
                .finish()
        }
    }
}
impl AeronStrToPtrHashMap {
    #[inline]
    pub fn new(
        keys: &AeronStrToPtrHashMapKey,
        values: *mut *mut ::std::os::raw::c_void,
        load_factor: f32,
        capacity: usize,
        size: usize,
        resize_threshold: usize,
    ) -> Result<Self, AeronCError> {
        let keys_copy = keys.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_str_to_ptr_hash_map_t {
                    keys: keys.into(),
                    values: values.into(),
                    load_factor: load_factor.into(),
                    capacity: capacity.into(),
                    size: size.into(),
                    resize_threshold: resize_threshold.into(),
                };
                let inner_ptr: *mut aeron_str_to_ptr_hash_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_str_to_ptr_hash_map_t)
                );
                let inst: aeron_str_to_ptr_hash_map_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_str_to_ptr_hash_map_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_str_to_ptr_hash_map_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn keys(&self) -> AeronStrToPtrHashMapKey {
        self.keys.into()
    }
    #[inline]
    pub fn values(&self) -> *mut *mut ::std::os::raw::c_void {
        self.values.into()
    }
    #[inline]
    pub fn load_factor(&self) -> f32 {
        self.load_factor.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn size(&self) -> usize {
        self.size.into()
    }
    #[inline]
    pub fn resize_threshold(&self) -> usize {
        self.resize_threshold.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_str_to_ptr_hash_map_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_str_to_ptr_hash_map_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_str_to_ptr_hash_map_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStrToPtrHashMap {
    type Target = aeron_str_to_ptr_hash_map_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_str_to_ptr_hash_map_t> for AeronStrToPtrHashMap {
    #[inline]
    fn from(value: *mut aeron_str_to_ptr_hash_map_t) -> Self {
        AeronStrToPtrHashMap {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStrToPtrHashMap> for *mut aeron_str_to_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronStrToPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStrToPtrHashMap> for *mut aeron_str_to_ptr_hash_map_t {
    #[inline]
    fn from(value: &AeronStrToPtrHashMap) -> Self {
        value.get_inner()
    }
}
impl From<AeronStrToPtrHashMap> for aeron_str_to_ptr_hash_map_t {
    #[inline]
    fn from(value: AeronStrToPtrHashMap) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_str_to_ptr_hash_map_t> for AeronStrToPtrHashMap {
    #[inline]
    fn from(value: *const aeron_str_to_ptr_hash_map_t) -> Self {
        AeronStrToPtrHashMap {
            inner: CResource::Borrowed(value as *mut aeron_str_to_ptr_hash_map_t),
        }
    }
}
impl From<aeron_str_to_ptr_hash_map_t> for AeronStrToPtrHashMap {
    #[inline]
    fn from(value: aeron_str_to_ptr_hash_map_t) -> Self {
        AeronStrToPtrHashMap {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStrToPtrHashMap {
    fn default() -> Self {
        AeronStrToPtrHashMap::new_zeroed_on_heap()
    }
}
impl AeronStrToPtrHashMap {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronStreamPositionCounterKeyLayout {
    inner: CResource<aeron_stream_position_counter_key_layout_t>,
}
impl core::fmt::Debug for AeronStreamPositionCounterKeyLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronStreamPositionCounterKeyLayout))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronStreamPositionCounterKeyLayout))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronStreamPositionCounterKeyLayout {
    #[inline]
    pub fn new(
        registration_id: i64,
        session_id: i32,
        stream_id: i32,
        channel_length: i32,
        channel: [::std::os::raw::c_char; 92usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_stream_position_counter_key_layout_t {
                    registration_id: registration_id.into(),
                    session_id: session_id.into(),
                    stream_id: stream_id.into(),
                    channel_length: channel_length.into(),
                    channel: channel.into(),
                };
                let inner_ptr: *mut aeron_stream_position_counter_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_stream_position_counter_key_layout_t)
                );
                let inst: aeron_stream_position_counter_key_layout_t =
                    unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_stream_position_counter_key_layout_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_stream_position_counter_key_layout_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline]
    pub fn channel(&self) -> [::std::os::raw::c_char; 92usize] {
        self.channel.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_stream_position_counter_key_layout_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_stream_position_counter_key_layout_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_stream_position_counter_key_layout_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronStreamPositionCounterKeyLayout {
    type Target = aeron_stream_position_counter_key_layout_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_stream_position_counter_key_layout_t> for AeronStreamPositionCounterKeyLayout {
    #[inline]
    fn from(value: *mut aeron_stream_position_counter_key_layout_t) -> Self {
        AeronStreamPositionCounterKeyLayout {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronStreamPositionCounterKeyLayout> for *mut aeron_stream_position_counter_key_layout_t {
    #[inline]
    fn from(value: AeronStreamPositionCounterKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<&AeronStreamPositionCounterKeyLayout>
    for *mut aeron_stream_position_counter_key_layout_t
{
    #[inline]
    fn from(value: &AeronStreamPositionCounterKeyLayout) -> Self {
        value.get_inner()
    }
}
impl From<AeronStreamPositionCounterKeyLayout> for aeron_stream_position_counter_key_layout_t {
    #[inline]
    fn from(value: AeronStreamPositionCounterKeyLayout) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_stream_position_counter_key_layout_t>
    for AeronStreamPositionCounterKeyLayout
{
    #[inline]
    fn from(value: *const aeron_stream_position_counter_key_layout_t) -> Self {
        AeronStreamPositionCounterKeyLayout {
            inner: CResource::Borrowed(value as *mut aeron_stream_position_counter_key_layout_t),
        }
    }
}
impl From<aeron_stream_position_counter_key_layout_t> for AeronStreamPositionCounterKeyLayout {
    #[inline]
    fn from(value: aeron_stream_position_counter_key_layout_t) -> Self {
        AeronStreamPositionCounterKeyLayout {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronStreamPositionCounterKeyLayout {
    fn default() -> Self {
        AeronStreamPositionCounterKeyLayout::new_zeroed_on_heap()
    }
}
impl AeronStreamPositionCounterKeyLayout {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscribableListEntry {
    inner: CResource<aeron_subscribable_list_entry_t>,
}
impl core::fmt::Debug for AeronSubscribableListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscribableListEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscribableListEntry))
                .field("inner", &self.inner)
                .field(stringify!(counter_id), &self.counter_id())
                .finish()
        }
    }
}
impl AeronSubscribableListEntry {
    #[inline]
    pub fn new(counter_id: i32, subscribable: &AeronSubscribable) -> Result<Self, AeronCError> {
        let subscribable_copy = subscribable.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscribable_list_entry_t {
                    counter_id: counter_id.into(),
                    subscribable: subscribable.into(),
                };
                let inner_ptr: *mut aeron_subscribable_list_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscribable_list_entry_t)
                );
                let inst: aeron_subscribable_list_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscribable_list_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscribable_list_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline]
    pub fn subscribable(&self) -> AeronSubscribable {
        self.subscribable.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscribable_list_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscribable_list_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscribable_list_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscribableListEntry {
    type Target = aeron_subscribable_list_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscribable_list_entry_t> for AeronSubscribableListEntry {
    #[inline]
    fn from(value: *mut aeron_subscribable_list_entry_t) -> Self {
        AeronSubscribableListEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscribableListEntry> for *mut aeron_subscribable_list_entry_t {
    #[inline]
    fn from(value: AeronSubscribableListEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscribableListEntry> for *mut aeron_subscribable_list_entry_t {
    #[inline]
    fn from(value: &AeronSubscribableListEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscribableListEntry> for aeron_subscribable_list_entry_t {
    #[inline]
    fn from(value: AeronSubscribableListEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscribable_list_entry_t> for AeronSubscribableListEntry {
    #[inline]
    fn from(value: *const aeron_subscribable_list_entry_t) -> Self {
        AeronSubscribableListEntry {
            inner: CResource::Borrowed(value as *mut aeron_subscribable_list_entry_t),
        }
    }
}
impl From<aeron_subscribable_list_entry_t> for AeronSubscribableListEntry {
    #[inline]
    fn from(value: aeron_subscribable_list_entry_t) -> Self {
        AeronSubscribableListEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscribableListEntry {
    fn default() -> Self {
        AeronSubscribableListEntry::new_zeroed_on_heap()
    }
}
impl AeronSubscribableListEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscribable {
    inner: CResource<aeron_subscribable_t>,
}
impl core::fmt::Debug for AeronSubscribable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscribable))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscribable))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(stringify!(length), &self.length())
                .field(stringify!(capacity), &self.capacity())
                .field(stringify!(resting_count), &self.resting_count())
                .finish()
        }
    }
}
impl AeronSubscribable {
    #[inline]
    pub fn new(
        correlation_id: i64,
        length: usize,
        capacity: usize,
        array: &AeronTetherablePosition,
        resting_count: usize,
        add_position_hook_func: ::std::option::Option<
            unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
        >,
        remove_position_hook_func: ::std::option::Option<
            unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
        >,
        clientd: *mut ::std::os::raw::c_void,
    ) -> Result<Self, AeronCError> {
        let array_copy = array.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscribable_t {
                    correlation_id: correlation_id.into(),
                    length: length.into(),
                    capacity: capacity.into(),
                    array: array.into(),
                    resting_count: resting_count.into(),
                    add_position_hook_func: add_position_hook_func.into(),
                    remove_position_hook_func: remove_position_hook_func.into(),
                    clientd: clientd.into(),
                };
                let inner_ptr: *mut aeron_subscribable_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscribable_t)
                );
                let inst: aeron_subscribable_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscribable_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscribable_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline]
    pub fn capacity(&self) -> usize {
        self.capacity.into()
    }
    #[inline]
    pub fn array(&self) -> AeronTetherablePosition {
        self.array.into()
    }
    #[inline]
    pub fn resting_count(&self) -> usize {
        self.resting_count.into()
    }
    #[inline]
    pub fn add_position_hook_func(
        &self,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
    > {
        self.add_position_hook_func.into()
    }
    #[inline]
    pub fn remove_position_hook_func(
        &self,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
    > {
        self.remove_position_hook_func.into()
    }
    #[inline]
    pub fn clientd(&self) -> *mut ::std::os::raw::c_void {
        self.clientd.into()
    }
    #[inline]
    pub fn aeron_driver_subscribable_state(
        &self,
        tetherable_position: &AeronTetherablePosition,
        state: aeron_subscription_tether_state_t,
        now_ns: i64,
    ) -> () {
        unsafe {
            let result = aeron_driver_subscribable_state(
                self.get_inner(),
                tetherable_position.get_inner(),
                state.into(),
                now_ns.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_driver_subscribable_working_position_count(&self) -> usize {
        unsafe {
            let result = aeron_driver_subscribable_working_position_count(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_driver_subscribable_has_working_positions(&self) -> bool {
        unsafe {
            let result = aeron_driver_subscribable_has_working_positions(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_driver_subscribable_remove_position(&self, counter_id: i32) -> () {
        unsafe {
            let result =
                aeron_driver_subscribable_remove_position(self.get_inner(), counter_id.into());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscribable_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscribable_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscribable_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscribable {
    type Target = aeron_subscribable_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscribable_t> for AeronSubscribable {
    #[inline]
    fn from(value: *mut aeron_subscribable_t) -> Self {
        AeronSubscribable {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscribable> for *mut aeron_subscribable_t {
    #[inline]
    fn from(value: AeronSubscribable) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscribable> for *mut aeron_subscribable_t {
    #[inline]
    fn from(value: &AeronSubscribable) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscribable> for aeron_subscribable_t {
    #[inline]
    fn from(value: AeronSubscribable) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscribable_t> for AeronSubscribable {
    #[inline]
    fn from(value: *const aeron_subscribable_t) -> Self {
        AeronSubscribable {
            inner: CResource::Borrowed(value as *mut aeron_subscribable_t),
        }
    }
}
impl From<aeron_subscribable_t> for AeronSubscribable {
    #[inline]
    fn from(value: aeron_subscribable_t) -> Self {
        AeronSubscribable {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscribable {
    fn default() -> Self {
        AeronSubscribable::new_zeroed_on_heap()
    }
}
impl AeronSubscribable {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscriptionCommand {
    inner: CResource<aeron_subscription_command_t>,
}
impl core::fmt::Debug for AeronSubscriptionCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscriptionCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscriptionCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(
                    stringify!(registration_correlation_id),
                    &self.registration_correlation_id(),
                )
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(channel_length), &self.channel_length())
                .finish()
        }
    }
}
impl AeronSubscriptionCommand {
    #[inline]
    pub fn new(
        correlated: AeronCorrelatedCommand,
        registration_correlation_id: i64,
        stream_id: i32,
        channel_length: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscription_command_t {
                    correlated: correlated.into(),
                    registration_correlation_id: registration_correlation_id.into(),
                    stream_id: stream_id.into(),
                    channel_length: channel_length.into(),
                };
                let inner_ptr: *mut aeron_subscription_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscription_command_t)
                );
                let inst: aeron_subscription_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscription_command_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscription_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn registration_correlation_id(&self) -> i64 {
        self.registration_correlation_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscription_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscription_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscription_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscriptionCommand {
    type Target = aeron_subscription_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscription_command_t> for AeronSubscriptionCommand {
    #[inline]
    fn from(value: *mut aeron_subscription_command_t) -> Self {
        AeronSubscriptionCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscriptionCommand> for *mut aeron_subscription_command_t {
    #[inline]
    fn from(value: AeronSubscriptionCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscriptionCommand> for *mut aeron_subscription_command_t {
    #[inline]
    fn from(value: &AeronSubscriptionCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscriptionCommand> for aeron_subscription_command_t {
    #[inline]
    fn from(value: AeronSubscriptionCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscription_command_t> for AeronSubscriptionCommand {
    #[inline]
    fn from(value: *const aeron_subscription_command_t) -> Self {
        AeronSubscriptionCommand {
            inner: CResource::Borrowed(value as *mut aeron_subscription_command_t),
        }
    }
}
impl From<aeron_subscription_command_t> for AeronSubscriptionCommand {
    #[inline]
    fn from(value: aeron_subscription_command_t) -> Self {
        AeronSubscriptionCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscriptionCommand {
    fn default() -> Self {
        AeronSubscriptionCommand::new_zeroed_on_heap()
    }
}
impl AeronSubscriptionCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscriptionConstants {
    inner: CResource<aeron_subscription_constants_t>,
}
impl core::fmt::Debug for AeronSubscriptionConstants {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscriptionConstants))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscriptionConstants))
                .field("inner", &self.inner)
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(stream_id), &self.stream_id())
                .field(
                    stringify!(channel_status_indicator_id),
                    &self.channel_status_indicator_id(),
                )
                .finish()
        }
    }
}
impl AeronSubscriptionConstants {
    #[inline]
    pub fn new(
        channel: &std::ffi::CStr,
        on_available_image: aeron_on_available_image_t,
        on_unavailable_image: aeron_on_unavailable_image_t,
        registration_id: i64,
        stream_id: i32,
        channel_status_indicator_id: i32,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscription_constants_t {
                    channel: channel.as_ptr(),
                    on_available_image: on_available_image.into(),
                    on_unavailable_image: on_unavailable_image.into(),
                    registration_id: registration_id.into(),
                    stream_id: stream_id.into(),
                    channel_status_indicator_id: channel_status_indicator_id.into(),
                };
                let inner_ptr: *mut aeron_subscription_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscription_constants_t)
                );
                let inst: aeron_subscription_constants_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscription_constants_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscription_constants_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel(&self) -> &str {
        if self.channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.channel).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn on_available_image(&self) -> aeron_on_available_image_t {
        self.on_available_image.into()
    }
    #[inline]
    pub fn on_unavailable_image(&self) -> aeron_on_unavailable_image_t {
        self.on_unavailable_image.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn channel_status_indicator_id(&self) -> i32 {
        self.channel_status_indicator_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscription_constants_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscription_constants_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscription_constants_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscriptionConstants {
    type Target = aeron_subscription_constants_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscription_constants_t> for AeronSubscriptionConstants {
    #[inline]
    fn from(value: *mut aeron_subscription_constants_t) -> Self {
        AeronSubscriptionConstants {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscriptionConstants> for *mut aeron_subscription_constants_t {
    #[inline]
    fn from(value: AeronSubscriptionConstants) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscriptionConstants> for *mut aeron_subscription_constants_t {
    #[inline]
    fn from(value: &AeronSubscriptionConstants) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscriptionConstants> for aeron_subscription_constants_t {
    #[inline]
    fn from(value: AeronSubscriptionConstants) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscription_constants_t> for AeronSubscriptionConstants {
    #[inline]
    fn from(value: *const aeron_subscription_constants_t) -> Self {
        AeronSubscriptionConstants {
            inner: CResource::Borrowed(value as *mut aeron_subscription_constants_t),
        }
    }
}
impl From<aeron_subscription_constants_t> for AeronSubscriptionConstants {
    #[inline]
    fn from(value: aeron_subscription_constants_t) -> Self {
        AeronSubscriptionConstants {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscriptionConstants {
    fn default() -> Self {
        AeronSubscriptionConstants::new_zeroed_on_heap()
    }
}
impl AeronSubscriptionConstants {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscriptionLink {
    inner: CResource<aeron_subscription_link_t>,
}
impl core::fmt::Debug for AeronSubscriptionLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscriptionLink))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscriptionLink))
                .field("inner", &self.inner)
                .field(stringify!(is_tether), &self.is_tether())
                .field(stringify!(is_sparse), &self.is_sparse())
                .field(stringify!(is_reliable), &self.is_reliable())
                .field(stringify!(is_rejoin), &self.is_rejoin())
                .field(stringify!(has_session_id), &self.has_session_id())
                .field(stringify!(is_response), &self.is_response())
                .field(stringify!(stream_id), &self.stream_id())
                .field(stringify!(session_id), &self.session_id())
                .field(stringify!(channel_length), &self.channel_length())
                .field(stringify!(registration_id), &self.registration_id())
                .field(stringify!(client_id), &self.client_id())
                .finish()
        }
    }
}
impl AeronSubscriptionLink {
    #[inline]
    pub fn new(
        channel: [::std::os::raw::c_char; 4096usize],
        is_tether: bool,
        is_sparse: bool,
        is_reliable: bool,
        is_rejoin: bool,
        has_session_id: bool,
        is_response: bool,
        group: aeron_inferable_boolean_t,
        stream_id: i32,
        session_id: i32,
        channel_length: i32,
        registration_id: i64,
        client_id: i64,
        endpoint: &AeronReceiveChannelEndpoint,
        spy_channel: &AeronUdpChannel,
        subscribable_list: aeron_subscription_link_stct_subscribable_list_stct,
    ) -> Result<Self, AeronCError> {
        let endpoint_copy = endpoint.clone();
        let spy_channel_copy = spy_channel.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscription_link_t {
                    channel: channel.into(),
                    is_tether: is_tether.into(),
                    is_sparse: is_sparse.into(),
                    is_reliable: is_reliable.into(),
                    is_rejoin: is_rejoin.into(),
                    has_session_id: has_session_id.into(),
                    is_response: is_response.into(),
                    group: group.into(),
                    stream_id: stream_id.into(),
                    session_id: session_id.into(),
                    channel_length: channel_length.into(),
                    registration_id: registration_id.into(),
                    client_id: client_id.into(),
                    endpoint: endpoint.into(),
                    spy_channel: spy_channel.into(),
                    subscribable_list: subscribable_list.into(),
                };
                let inner_ptr: *mut aeron_subscription_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscription_link_t)
                );
                let inst: aeron_subscription_link_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscription_link_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscription_link_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel(&self) -> [::std::os::raw::c_char; 4096usize] {
        self.channel.into()
    }
    #[inline]
    pub fn is_tether(&self) -> bool {
        self.is_tether.into()
    }
    #[inline]
    pub fn is_sparse(&self) -> bool {
        self.is_sparse.into()
    }
    #[inline]
    pub fn is_reliable(&self) -> bool {
        self.is_reliable.into()
    }
    #[inline]
    pub fn is_rejoin(&self) -> bool {
        self.is_rejoin.into()
    }
    #[inline]
    pub fn has_session_id(&self) -> bool {
        self.has_session_id.into()
    }
    #[inline]
    pub fn is_response(&self) -> bool {
        self.is_response.into()
    }
    #[inline]
    pub fn group(&self) -> aeron_inferable_boolean_t {
        self.group.into()
    }
    #[inline]
    pub fn stream_id(&self) -> i32 {
        self.stream_id.into()
    }
    #[inline]
    pub fn session_id(&self) -> i32 {
        self.session_id.into()
    }
    #[inline]
    pub fn channel_length(&self) -> i32 {
        self.channel_length.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn client_id(&self) -> i64 {
        self.client_id.into()
    }
    #[inline]
    pub fn endpoint(&self) -> AeronReceiveChannelEndpoint {
        self.endpoint.into()
    }
    #[inline]
    pub fn spy_channel(&self) -> AeronUdpChannel {
        self.spy_channel.into()
    }
    #[inline]
    pub fn subscribable_list(&self) -> aeron_subscription_link_stct_subscribable_list_stct {
        self.subscribable_list.into()
    }
    #[inline]
    pub fn aeron_driver_conductor_unlink_subscribable(
        &self,
        subscribable: &AeronSubscribable,
    ) -> () {
        unsafe {
            let result = aeron_driver_conductor_unlink_subscribable(
                self.get_inner(),
                subscribable.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscription_link_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscription_link_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscription_link_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscriptionLink {
    type Target = aeron_subscription_link_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscription_link_t> for AeronSubscriptionLink {
    #[inline]
    fn from(value: *mut aeron_subscription_link_t) -> Self {
        AeronSubscriptionLink {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscriptionLink> for *mut aeron_subscription_link_t {
    #[inline]
    fn from(value: AeronSubscriptionLink) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscriptionLink> for *mut aeron_subscription_link_t {
    #[inline]
    fn from(value: &AeronSubscriptionLink) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscriptionLink> for aeron_subscription_link_t {
    #[inline]
    fn from(value: AeronSubscriptionLink) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscription_link_t> for AeronSubscriptionLink {
    #[inline]
    fn from(value: *const aeron_subscription_link_t) -> Self {
        AeronSubscriptionLink {
            inner: CResource::Borrowed(value as *mut aeron_subscription_link_t),
        }
    }
}
impl From<aeron_subscription_link_t> for AeronSubscriptionLink {
    #[inline]
    fn from(value: aeron_subscription_link_t) -> Self {
        AeronSubscriptionLink {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscriptionLink {
    fn default() -> Self {
        AeronSubscriptionLink::new_zeroed_on_heap()
    }
}
impl AeronSubscriptionLink {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscriptionReady {
    inner: CResource<aeron_subscription_ready_t>,
}
impl core::fmt::Debug for AeronSubscriptionReady {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscriptionReady))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscriptionReady))
                .field("inner", &self.inner)
                .field(stringify!(correlation_id), &self.correlation_id())
                .field(
                    stringify!(channel_status_indicator_id),
                    &self.channel_status_indicator_id(),
                )
                .finish()
        }
    }
}
impl AeronSubscriptionReady {
    #[inline]
    pub fn new(correlation_id: i64, channel_status_indicator_id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_subscription_ready_t {
                    correlation_id: correlation_id.into(),
                    channel_status_indicator_id: channel_status_indicator_id.into(),
                };
                let inner_ptr: *mut aeron_subscription_ready_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscription_ready_t)
                );
                let inst: aeron_subscription_ready_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscription_ready_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscription_ready_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlation_id(&self) -> i64 {
        self.correlation_id.into()
    }
    #[inline]
    pub fn channel_status_indicator_id(&self) -> i32 {
        self.channel_status_indicator_id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscription_ready_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscription_ready_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscription_ready_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscriptionReady {
    type Target = aeron_subscription_ready_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscription_ready_t> for AeronSubscriptionReady {
    #[inline]
    fn from(value: *mut aeron_subscription_ready_t) -> Self {
        AeronSubscriptionReady {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscriptionReady> for *mut aeron_subscription_ready_t {
    #[inline]
    fn from(value: AeronSubscriptionReady) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscriptionReady> for *mut aeron_subscription_ready_t {
    #[inline]
    fn from(value: &AeronSubscriptionReady) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscriptionReady> for aeron_subscription_ready_t {
    #[inline]
    fn from(value: AeronSubscriptionReady) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscription_ready_t> for AeronSubscriptionReady {
    #[inline]
    fn from(value: *const aeron_subscription_ready_t) -> Self {
        AeronSubscriptionReady {
            inner: CResource::Borrowed(value as *mut aeron_subscription_ready_t),
        }
    }
}
impl From<aeron_subscription_ready_t> for AeronSubscriptionReady {
    #[inline]
    fn from(value: aeron_subscription_ready_t) -> Self {
        AeronSubscriptionReady {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSubscriptionReady {
    fn default() -> Self {
        AeronSubscriptionReady::new_zeroed_on_heap()
    }
}
impl AeronSubscriptionReady {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSubscription {
    inner: CResource<aeron_subscription_t>,
}
impl core::fmt::Debug for AeronSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSubscription))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSubscription))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronSubscription {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_subscription_t)
                );
                let inst: aeron_subscription_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_subscription_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            Some(|c| unsafe { aeron_subscription_is_closed(c) }),
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_subscription_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    #[doc = "Poll the images under the subscription for available message fragments."]
    #[doc = " \n"]
    #[doc = " Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come"]
    #[doc = " as a series of fragments ordered within a session."]
    #[doc = " \n"]
    #[doc = " To assemble messages that span multiple fragments then use `AeronFragmentAssembler`."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` for handling each message fragment as it is read."]
    #[doc = " \n - `fragment_limit` number of message fragments to limit when polling across multiple images."]
    #[doc = " \n# Return\n the number of fragments received or -1 for error."]
    pub fn poll<AeronFragmentHandlerHandlerImpl: AeronFragmentHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronFragmentHandlerHandlerImpl>>,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_poll(
                self.get_inner(),
                {
                    let callback: aeron_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_fragment_handler_t_callback::<AeronFragmentHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll the images under the subscription for available message fragments."]
    #[doc = " \n"]
    #[doc = " Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come"]
    #[doc = " as a series of fragments ordered within a session."]
    #[doc = " \n"]
    #[doc = " To assemble messages that span multiple fragments then use `AeronFragmentAssembler`."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` for handling each message fragment as it is read."]
    #[doc = " \n - `fragment_limit` number of message fragments to limit when polling across multiple images."]
    #[doc = " \n# Return\n the number of fragments received or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn poll_once<AeronFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> ()>(
        &self,
        mut handler: AeronFragmentHandlerHandlerImpl,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_poll(
                self.get_inner(),
                Some(
                    aeron_fragment_handler_t_callback_for_once_closure::<
                        AeronFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll in a controlled manner the images under the subscription for available message fragments."]
    #[doc = " Control is applied to fragments in the stream. If more fragments can be read on another stream"]
    #[doc = " they will even if BREAK or ABORT is returned from the fragment handler."]
    #[doc = " \n"]
    #[doc = " Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come"]
    #[doc = " as a series of fragments ordered within a session."]
    #[doc = " \n"]
    #[doc = " To assemble messages that span multiple fragments then use `AeronControlledFragmentAssembler`."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` for handling each message fragment as it is read."]
    #[doc = " \n - `fragment_limit` number of message fragments to limit when polling across multiple images."]
    #[doc = " \n# Return\n the number of fragments received or -1 for error."]
    pub fn controlled_poll<
        AeronControlledFragmentHandlerHandlerImpl: AeronControlledFragmentHandlerCallback,
    >(
        &self,
        handler: Option<&Handler<AeronControlledFragmentHandlerHandlerImpl>>,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_controlled_poll(
                self.get_inner(),
                {
                    let callback: aeron_controlled_fragment_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(
                            aeron_controlled_fragment_handler_t_callback::<
                                AeronControlledFragmentHandlerHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll in a controlled manner the images under the subscription for available message fragments."]
    #[doc = " Control is applied to fragments in the stream. If more fragments can be read on another stream"]
    #[doc = " they will even if BREAK or ABORT is returned from the fragment handler."]
    #[doc = " \n"]
    #[doc = " Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come"]
    #[doc = " as a series of fragments ordered within a session."]
    #[doc = " \n"]
    #[doc = " To assemble messages that span multiple fragments then use `AeronControlledFragmentAssembler`."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` for handling each message fragment as it is read."]
    #[doc = " \n - `fragment_limit` number of message fragments to limit when polling across multiple images."]
    #[doc = " \n# Return\n the number of fragments received or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn controlled_poll_once<
        AeronControlledFragmentHandlerHandlerImpl: FnMut(&[u8], AeronHeader) -> aeron_controlled_fragment_handler_action_t,
    >(
        &self,
        mut handler: AeronControlledFragmentHandlerHandlerImpl,
        fragment_limit: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_controlled_poll(
                self.get_inner(),
                Some(
                    aeron_controlled_fragment_handler_t_callback_for_once_closure::<
                        AeronControlledFragmentHandlerHandlerImpl,
                    >,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                fragment_limit.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Poll the images under the subscription for available message fragments in blocks."]
    #[doc = " \n"]
    #[doc = " This method is useful for operations like bulk archiving and messaging indexing."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to receive a block of fragments from each image."]
    #[doc = " \n - `block_length_limit` for each image polled."]
    #[doc = " \n# Return\n the number of bytes consumed or -1 for error."]
    pub fn block_poll<AeronBlockHandlerHandlerImpl: AeronBlockHandlerCallback>(
        &self,
        handler: Option<&Handler<AeronBlockHandlerHandlerImpl>>,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_long {
        unsafe {
            let result = aeron_subscription_block_poll(
                self.get_inner(),
                {
                    let callback: aeron_block_handler_t = if handler.is_none() {
                        None
                    } else {
                        Some(aeron_block_handler_t_callback::<AeronBlockHandlerHandlerImpl>)
                    };
                    callback
                },
                handler
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                block_length_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Poll the images under the subscription for available message fragments in blocks."]
    #[doc = " \n"]
    #[doc = " This method is useful for operations like bulk archiving and messaging indexing."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to receive a block of fragments from each image."]
    #[doc = " \n - `block_length_limit` for each image polled."]
    #[doc = " \n# Return\n the number of bytes consumed or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn block_poll_once<AeronBlockHandlerHandlerImpl: FnMut(&[u8], i32, i32) -> ()>(
        &self,
        mut handler: AeronBlockHandlerHandlerImpl,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_long {
        unsafe {
            let result = aeron_subscription_block_poll(
                self.get_inner(),
                Some(
                    aeron_block_handler_t_callback_for_once_closure::<AeronBlockHandlerHandlerImpl>,
                ),
                &mut handler as *mut _ as *mut std::os::raw::c_void,
                block_length_limit.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = "Is this subscription connected by having at least one open publication image."]
    #[doc = ""]
    #[doc = " \n# Return\n true if this subscription connected by having at least one open publication image."]
    pub fn is_connected(&self) -> bool {
        unsafe {
            let result = aeron_subscription_is_connected(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a subscription."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `subscription` to get the constants for."]
    #[doc = " \n - `constants` structure to fill in with the constants"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn constants(&self, constants: &AeronSubscriptionConstants) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_constants(self.get_inner(), constants.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Fill in a structure with the constants in use by a subscription."]
    #[doc = ""]
    pub fn get_constants(&self) -> Result<AeronSubscriptionConstants, AeronCError> {
        let result = AeronSubscriptionConstants::new_zeroed_on_stack();
        self.constants(&result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Count of images associated to this subscription."]
    #[doc = ""]
    #[doc = " \n# Return\n count of count associated to this subscription or -1 for error."]
    pub fn image_count(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_image_count(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return the image associated with the given session_id under the given subscription."]
    #[doc = ""]
    #[doc = " Note: the returned image is considered retained by the application and thus must be released via"]
    #[doc = " aeron_image_release when finished or if the image becomes unavailable."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `session_id` associated with the image."]
    #[doc = " \n# Return\n image associated with the given session_id or NULL if no image exists."]
    pub fn image_by_session_id(&self, session_id: i32) -> AeronImage {
        unsafe {
            let result =
                aeron_subscription_image_by_session_id(self.get_inner(), session_id.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Return the image at the given index."]
    #[doc = ""]
    #[doc = " Note: the returned image is considered retained by the application and thus must be released via"]
    #[doc = " aeron_image_release when finished or if the image becomes unavailable."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `index` for the image."]
    #[doc = " \n# Return\n image at the given index or NULL if no image exists."]
    pub fn image_at_index(&self, index: usize) -> AeronImage {
        unsafe {
            let result = aeron_subscription_image_at_index(self.get_inner(), index.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Iterate over the images for this subscription calling the given function."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `handler` to be called for each image."]
    #[doc = " \n - `clientd` to be passed to the handler."]
    pub fn for_each_image(
        &self,
        handler: ::std::option::Option<
            unsafe extern "C" fn(image: *mut aeron_image_t, clientd: *mut ::std::os::raw::c_void),
        >,
        clientd: *mut ::std::os::raw::c_void,
    ) -> () {
        unsafe {
            let result =
                aeron_subscription_for_each_image(self.get_inner(), handler.into(), clientd.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Retain the given image for access in the application."]
    #[doc = ""]
    #[doc = " Note: A retain call must have a corresponding release call."]
    #[doc = " Note: Subscriptions are not threadsafe and should not be shared between subscribers."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `subscription` that image is part of."]
    #[doc = " \n - `image` to retain"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn image_retain(&self, image: &AeronImage) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_image_retain(self.get_inner(), image.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Release the given image and relinquish desire to use the image directly."]
    #[doc = ""]
    #[doc = " Note: Subscriptions are not threadsafe and should not be shared between subscribers."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `subscription` that image is part of."]
    #[doc = " \n - `image` to release"]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn image_release(&self, image: &AeronImage) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_image_release(self.get_inner(), image.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Is the subscription closed."]
    #[doc = ""]
    #[doc = " \n# Return\n true if it has been closed otherwise false."]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_subscription_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Get the status of the media channel for this subscription."]
    #[doc = " \n"]
    #[doc = " The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well."]
    #[doc = ""]
    #[doc = " \n# Return\n 1 for ACTIVE, -1 for ERRORED"]
    pub fn channel_status(&self) -> i64 {
        unsafe {
            let result = aeron_subscription_channel_status(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Asynchronously close the subscription. Will callback on the on_complete notification when the subscription is"]
    #[doc = " closed. The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the subscription has been closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    pub fn close<AeronNotificationHandlerImpl: AeronNotificationCallback>(
        &self,
        on_close_complete: Option<&Handler<AeronNotificationHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_subscription_close(
                self.get_inner(),
                {
                    let callback: aeron_notification_t = if on_close_complete.is_none() {
                        None
                    } else {
                        Some(aeron_notification_t_callback::<AeronNotificationHandlerImpl>)
                    };
                    callback
                },
                on_close_complete
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Asynchronously close the subscription. Will callback on the on_complete notification when the subscription is"]
    #[doc = " closed. The callback is optional, use NULL for the on_complete callback if not required."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `on_close_complete` optional callback to execute once the subscription has been closed and freed. This may"]
    #[doc = " happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime."]
    #[doc = " \n - `on_close_complete_clientd` parameter to pass to the on_complete callback."]
    #[doc = " \n# Return\n 0 for success or -1 for error."]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn close_once<AeronNotificationHandlerImpl: FnMut() -> ()>(
        &self,
        mut on_close_complete: AeronNotificationHandlerImpl,
    ) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_subscription_close(
                self.get_inner(),
                Some(
                    aeron_notification_t_callback_for_once_closure::<AeronNotificationHandlerImpl>,
                ),
                &mut on_close_complete as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Get all of the local socket addresses for this subscription. Multiple addresses can occur if this is a"]
    #[doc = " multi-destination subscription. Addresses will a string representation in numeric form. IPv6 addresses will be"]
    #[doc = " surrounded by '[' and ']' so that the ':' that separate the parts are distinguishable from the port delimiter."]
    #[doc = " E.g. [fe80::7552:c06e:6bf4:4160]:12345. As of writing the maximum length for a formatted address is 54 bytes"]
    #[doc = " including the NULL terminator. AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN is defined to provide enough space to fit the"]
    #[doc = " returned string. Returned strings will be NULL terminated. If the buffer to hold the address can not hold enough"]
    #[doc = " of the message it will be truncated and the last character will be null."]
    #[doc = ""]
    #[doc = " If the address_vec_len is less the total number of addresses available then the first addresses found up to that"]
    #[doc = " length will be placed into the address_vec. However the function will return the total number of addresses available"]
    #[doc = " so if if that is larger than the input array then the client code may wish to re-query with a larger array to get"]
    #[doc = " them all."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `address_vec` to hold the received addresses"]
    #[doc = " \n - `address_vec_len` available length of the vector to hold the addresses"]
    #[doc = " \n# Return\n number of addresses found or -1 if there is an error."]
    pub fn local_sockaddrs(
        &self,
        address_vec: &AeronIovec,
        address_vec_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_local_sockaddrs(
                self.get_inner(),
                address_vec.get_inner(),
                address_vec_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Retrieves the first local socket address for this subscription. If this is not MDS then it will be the one"]
    #[doc = " representing endpoint for this subscription."]
    #[doc = ""]
    #[doc = " @see aeron_subscription_local_`Sockaddr`s"]
    #[doc = "# Parameters\n \n - `address` for the received address"]
    #[doc = " \n - `address_len` available length for the copied address."]
    #[doc = " \n# Return\n -1 on error, 0 if address not found, 1 if address is found."]
    pub fn resolved_endpoint(
        &self,
        address: &std::ffi::CStr,
        address_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_resolved_endpoint(
                self.get_inner(),
                address.as_ptr(),
                address_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or"]
    #[doc = " does not have a wildcard port (<code>0</code>), then it will return the original URI."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `uri` buffer to hold the resolved uri"]
    #[doc = " \n - `uri_len` length of the buffer"]
    #[doc = " \n# Return\n -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done"]
    #[doc = " on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up"]
    #[doc = " to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been"]
    #[doc = " truncated."]
    pub fn try_resolve_channel_endpoint_port(
        &self,
        uri: *mut ::std::os::raw::c_char,
        uri_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_subscription_try_resolve_channel_endpoint_port(
                self.get_inner(),
                uri.into(),
                uri_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or"]
    #[doc = " does not have a wildcard port (<code>0</code>), then it will return the original URI."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `uri` buffer to hold the resolved uri"]
    #[doc = " \n - `uri_len` length of the buffer"]
    #[doc = " \n# Return\n -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done"]
    #[doc = " on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up"]
    #[doc = " to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been"]
    #[doc = " truncated."]
    pub fn try_resolve_channel_endpoint_port_as_string(
        &self,
        max_length: usize,
    ) -> Result<String, AeronCError> {
        let mut result = String::with_capacity(max_length);
        self.try_resolve_channel_endpoint_port_into(&mut result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or"]
    #[doc = " does not have a wildcard port (<code>0</code>), then it will return the original URI."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `uri` buffer to hold the resolved uri"]
    #[doc = " \n - `uri_len` length of the buffer"]
    #[doc = " \n# Return\n -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done"]
    #[doc = " on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up"]
    #[doc = " to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been"]
    #[doc = " truncated."]
    #[doc = "NOTE: allocation friendly method, the string capacity must be set as it will truncate string to capacity it will never grow the string. So if you pass String::new() it will write 0 chars"]
    pub fn try_resolve_channel_endpoint_port_into(
        &self,
        dst_truncate_to_capacity: &mut String,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let capacity = dst_truncate_to_capacity.capacity();
            let vec = dst_truncate_to_capacity.as_mut_vec();
            vec.set_len(capacity);
            let result =
                self.try_resolve_channel_endpoint_port(vec.as_mut_ptr() as *mut _, capacity)?;
            let mut len = 0;
            loop {
                if len == capacity {
                    break;
                }
                let val = vec[len];
                if val == 0 {
                    break;
                }
                len += 1;
            }
            vec.set_len(len);
            Ok(result)
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_subscription_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_subscription_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_subscription_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSubscription {
    type Target = aeron_subscription_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_subscription_t> for AeronSubscription {
    #[inline]
    fn from(value: *mut aeron_subscription_t) -> Self {
        AeronSubscription {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSubscription> for *mut aeron_subscription_t {
    #[inline]
    fn from(value: AeronSubscription) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSubscription> for *mut aeron_subscription_t {
    #[inline]
    fn from(value: &AeronSubscription) -> Self {
        value.get_inner()
    }
}
impl From<AeronSubscription> for aeron_subscription_t {
    #[inline]
    fn from(value: AeronSubscription) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_subscription_t> for AeronSubscription {
    #[inline]
    fn from(value: *const aeron_subscription_t) -> Self {
        AeronSubscription {
            inner: CResource::Borrowed(value as *mut aeron_subscription_t),
        }
    }
}
impl From<aeron_subscription_t> for AeronSubscription {
    #[inline]
    fn from(value: aeron_subscription_t) -> Self {
        AeronSubscription {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronSubscription {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronSubscription));
                    let result = self.close_with_no_args();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronSubscription));
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct AeronSystemCounter {
    inner: CResource<aeron_system_counter_t>,
}
impl core::fmt::Debug for AeronSystemCounter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSystemCounter))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSystemCounter))
                .field("inner", &self.inner)
                .field(stringify!(id), &self.id())
                .finish()
        }
    }
}
impl AeronSystemCounter {
    #[inline]
    pub fn new(label: &std::ffi::CStr, id: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_system_counter_t {
                    label: label.as_ptr(),
                    id: id.into(),
                };
                let inner_ptr: *mut aeron_system_counter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_system_counter_t)
                );
                let inst: aeron_system_counter_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_system_counter_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_system_counter_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn label(&self) -> &str {
        if self.label.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.label).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn id(&self) -> i32 {
        self.id.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_system_counter_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_system_counter_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_system_counter_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSystemCounter {
    type Target = aeron_system_counter_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_system_counter_t> for AeronSystemCounter {
    #[inline]
    fn from(value: *mut aeron_system_counter_t) -> Self {
        AeronSystemCounter {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSystemCounter> for *mut aeron_system_counter_t {
    #[inline]
    fn from(value: AeronSystemCounter) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSystemCounter> for *mut aeron_system_counter_t {
    #[inline]
    fn from(value: &AeronSystemCounter) -> Self {
        value.get_inner()
    }
}
impl From<AeronSystemCounter> for aeron_system_counter_t {
    #[inline]
    fn from(value: AeronSystemCounter) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_system_counter_t> for AeronSystemCounter {
    #[inline]
    fn from(value: *const aeron_system_counter_t) -> Self {
        AeronSystemCounter {
            inner: CResource::Borrowed(value as *mut aeron_system_counter_t),
        }
    }
}
impl From<aeron_system_counter_t> for AeronSystemCounter {
    #[inline]
    fn from(value: aeron_system_counter_t) -> Self {
        AeronSystemCounter {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSystemCounter {
    fn default() -> Self {
        AeronSystemCounter::new_zeroed_on_heap()
    }
}
impl AeronSystemCounter {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronSystemCounters {
    inner: CResource<aeron_system_counters_t>,
}
impl core::fmt::Debug for AeronSystemCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronSystemCounters))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronSystemCounters))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronSystemCounters {
    #[inline]
    pub fn new(counter_ids: &mut i32, manager: &AeronCountersManager) -> Result<Self, AeronCError> {
        let manager_copy = manager.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_system_counters_t {
                    counter_ids: counter_ids as *mut _,
                    manager: manager.into(),
                };
                let inner_ptr: *mut aeron_system_counters_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_system_counters_t)
                );
                let inst: aeron_system_counters_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_system_counters_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_system_counters_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn counter_ids(&self) -> &mut i32 {
        unsafe { &mut *self.counter_ids }
    }
    #[inline]
    pub fn manager(&self) -> AeronCountersManager {
        self.manager.into()
    }
    #[inline]
    pub fn init(&self, manager: &AeronCountersManager) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_system_counters_init(self.get_inner(), manager.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_system_counters_close(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_system_counters_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_system_counters_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_system_counters_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronSystemCounters {
    type Target = aeron_system_counters_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_system_counters_t> for AeronSystemCounters {
    #[inline]
    fn from(value: *mut aeron_system_counters_t) -> Self {
        AeronSystemCounters {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronSystemCounters> for *mut aeron_system_counters_t {
    #[inline]
    fn from(value: AeronSystemCounters) -> Self {
        value.get_inner()
    }
}
impl From<&AeronSystemCounters> for *mut aeron_system_counters_t {
    #[inline]
    fn from(value: &AeronSystemCounters) -> Self {
        value.get_inner()
    }
}
impl From<AeronSystemCounters> for aeron_system_counters_t {
    #[inline]
    fn from(value: AeronSystemCounters) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_system_counters_t> for AeronSystemCounters {
    #[inline]
    fn from(value: *const aeron_system_counters_t) -> Self {
        AeronSystemCounters {
            inner: CResource::Borrowed(value as *mut aeron_system_counters_t),
        }
    }
}
impl From<aeron_system_counters_t> for AeronSystemCounters {
    #[inline]
    fn from(value: aeron_system_counters_t) -> Self {
        AeronSystemCounters {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronSystemCounters {
    fn default() -> Self {
        AeronSystemCounters::new_zeroed_on_heap()
    }
}
impl AeronSystemCounters {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct Aeron {
    inner: CResource<aeron_t>,
    _context: Option<AeronContext>,
}
impl core::fmt::Debug for Aeron {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Aeron))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Aeron))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Aeron {
    #[doc = "Create a `Aeron` client struct and initialize from the `AeronContext` struct."]
    #[doc = ""]
    #[doc = " The given `AeronContext` struct will be used exclusively by the client. Do not reuse between clients."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `context` to use for initialization."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn new(context: &AeronContext) -> Result<Self, AeronCError> {
        let context_copy = context.clone();
        let context: *mut aeron_context_t = context.into();
        let resource_constructor = ManagedCResource::new(
            move |ctx_field| unsafe { aeron_init(ctx_field, context) },
            Some(Box::new(move |ctx_field| unsafe {
                aeron_close(*ctx_field)
            })),
            false,
            Some(|c| unsafe { aeron_is_closed(c) }),
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource_constructor)),
            _context: Some(context_copy),
        })
    }
    #[inline]
    #[doc = "Start an `Aeron`. This may spawn a thread for the Client Conductor."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn start(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_start(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Call the Conductor main do_work duty cycle once."]
    #[doc = ""]
    #[doc = " Client must have been created with use conductor invoker set to true."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn main_do_work(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_main_do_work(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Call the Conductor Idle Strategy."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `work_count` to pass to idle strategy."]
    pub fn main_idle_strategy(&self, work_count: ::std::os::raw::c_int) -> () {
        unsafe {
            let result = aeron_main_idle_strategy(self.get_inner(), work_count.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Close and delete `Aeron` struct."]
    #[doc = ""]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Determines if the client has been closed, e.g. via a driver timeout. Don't call this method after calling"]
    #[doc = " aeron_close as that will have already freed the associated memory."]
    #[doc = ""]
    #[doc = " \n# Return\n true if it has been closed, false otherwise."]
    pub fn is_closed(&self) -> bool {
        unsafe {
            let result = aeron_is_closed(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Call stream_out to print the counter labels and values."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `stream_out` to call for each label and value."]
    pub fn print_counters(
        &self,
        stream_out: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
        >,
    ) -> () {
        unsafe {
            let result = aeron_print_counters(self.get_inner(), stream_out.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Return the `AeronContext` that is in use by the given client."]
    #[doc = ""]
    #[doc = " \n# Return\n the `AeronContext` for the given client or NULL for an error."]
    pub fn context(&self) -> AeronContext {
        unsafe {
            let result = aeron_context(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Return the client id in use by the client."]
    #[doc = ""]
    #[doc = " \n# Return\n id value or -1 for an error."]
    pub fn client_id(&self) -> i64 {
        unsafe {
            let result = aeron_client_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Return a unique correlation id from the driver."]
    #[doc = ""]
    #[doc = " \n# Return\n unique correlation id or -1 for an error."]
    pub fn next_correlation_id(&self) -> i64 {
        unsafe {
            let result = aeron_next_correlation_id(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Return a reference to the counters reader of the given client."]
    #[doc = ""]
    #[doc = " The `AeronCountersReader` is maintained by the client. And should not be freed."]
    #[doc = ""]
    #[doc = " \n# Return\n `AeronCountersReader` or NULL for error."]
    pub fn counters_reader(&self) -> AeronCountersReader {
        unsafe {
            let result = aeron_counters_reader(self.get_inner());
            result.into()
        }
    }
    #[inline]
    #[doc = "Add a handler to be called when a new counter becomes available."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is added by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn add_available_counter_handler(
        &self,
        pair: &AeronAvailableCounterPair,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_add_available_counter_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Remove a previously added handler to be called when a new counter becomes available."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is removed by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn remove_available_counter_handler(
        &self,
        pair: &AeronAvailableCounterPair,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_remove_available_counter_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Add a handler to be called when a new counter becomes unavailable or goes away."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is added by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn add_unavailable_counter_handler(
        &self,
        pair: &AeronUnavailableCounterPair,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_add_unavailable_counter_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Remove a previously added handler to be called when a new counter becomes unavailable or goes away."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is removed by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn remove_unavailable_counter_handler(
        &self,
        pair: &AeronUnavailableCounterPair,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_remove_unavailable_counter_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Add a handler to be called when client is closed."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is added by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn add_close_handler(&self, pair: &AeronCloseClientPair) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_add_close_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Remove a previously added handler to be called when client is closed."]
    #[doc = ""]
    #[doc = " NOTE: This function blocks until the handler is removed by the client conductor thread."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `pair` holding the handler to call and a clientd to pass when called."]
    #[doc = " \n# Return\n 0 for success and -1 for error"]
    pub fn remove_close_handler(&self, pair: &AeronCloseClientPair) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_remove_close_handler(self.get_inner(), pair.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return full version and build string."]
    #[doc = ""]
    #[doc = " \n# Return\n full version and build string."]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn version_full() -> &'static str {
        unsafe {
            let result = aeron_version_full();
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Return version text."]
    #[doc = ""]
    #[doc = " \n# Return\n version text."]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn version_text() -> &'static str {
        unsafe {
            let result = aeron_version_text();
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Return major version number."]
    #[doc = ""]
    #[doc = " \n# Return\n major version number."]
    pub fn version_major() -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_version_major();
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return minor version number."]
    #[doc = ""]
    #[doc = " \n# Return\n minor version number."]
    pub fn version_minor() -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_version_minor();
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return patch version number."]
    #[doc = ""]
    #[doc = " \n# Return\n patch version number."]
    pub fn version_patch() -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_version_patch();
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return the git sha for the current build."]
    #[doc = ""]
    #[doc = " \n# Return\n git version"]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn version_gitsha() -> &'static str {
        unsafe {
            let result = aeron_version_gitsha();
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Return time in nanoseconds for machine. Is not wall clock time."]
    #[doc = ""]
    #[doc = " \n# Return\n nanoseconds since epoch for machine."]
    pub fn nano_clock() -> i64 {
        unsafe {
            let result = aeron_nano_clock();
            result.into()
        }
    }
    #[inline]
    #[doc = "Return time in milliseconds since epoch. Is wall clock time."]
    #[doc = ""]
    #[doc = " \n# Return\n milliseconds since epoch."]
    pub fn epoch_clock() -> i64 {
        unsafe {
            let result = aeron_epoch_clock();
            result.into()
        }
    }
    #[inline]
    #[doc = "Determine if an aeron driver is using a given aeron directory."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `dirname`  for aeron directory"]
    #[doc = " \n - `timeout_ms`  to use to determine activity for aeron directory"]
    #[doc = " \n - `log_func` to call during activity check to log diagnostic information."]
    #[doc = " \n# Return\n true for active driver or false for no active driver."]
    pub fn is_driver_active(
        dirname: &std::ffi::CStr,
        timeout_ms: i64,
        log_func: aeron_log_func_t,
    ) -> bool {
        unsafe {
            let result =
                aeron_is_driver_active(dirname.as_ptr(), timeout_ms.into(), log_func.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Load properties from a string containing name=value pairs and set appropriate environment variables for the"]
    #[doc = " process so that subsequent calls to aeron_driver_context_init will use those values."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `buffer` containing properties and values."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn properties_buffer_load(buffer: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_properties_buffer_load(buffer.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Load properties file and set appropriate environment variables for the process so that subsequent"]
    #[doc = " calls to aeron_driver_context_init will use those values."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `filename` to load."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn properties_file_load(filename: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_properties_file_load(filename.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Load properties from HTTP URL and set environment variables for the process so that subsequent"]
    #[doc = " calls to aeron_driver_context_init will use those values."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `url` to attempt to retrieve and load."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn properties_http_load(url: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_properties_http_load(url.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Load properties based on URL or filename. If string contains file or http URL, it will attempt"]
    #[doc = " to load properties from a file or http as indicated. If not a URL, then it will try to load the string"]
    #[doc = " as a filename."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `url_or_filename` to load properties from."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn properties_load(url_or_filename: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_properties_load(url_or_filename.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return current aeron error code (errno) for calling thread."]
    #[doc = ""]
    #[doc = " \n# Return\n aeron error code for calling thread."]
    pub fn errcode() -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_errcode();
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Return the current aeron error message for calling thread."]
    #[doc = ""]
    #[doc = " \n# Return\n aeron error message for calling thread."]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn errmsg() -> &'static str {
        unsafe {
            let result = aeron_errmsg();
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    #[doc = "Get the default path used by the Aeron media driver."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `path` buffer to store the path."]
    #[doc = " \n - `path_length` space available in the buffer"]
    #[doc = " \n# Return\n -1 if there is an issue or the number of bytes written to path excluding the terminator <code>\\0</code>. If this"]
    #[doc = " is equal to or greater than the path_length then the path has been truncated."]
    pub fn default_path(
        path: *mut ::std::os::raw::c_char,
        path_length: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_default_path(path.into(), path_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn randomised_int32() -> i32 {
        unsafe {
            let result = aeron_randomised_int32();
            result.into()
        }
    }
    #[inline]
    pub fn thread_set_name(role_name: &std::ffi::CStr) -> () {
        unsafe {
            let result = aeron_thread_set_name(role_name.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn nano_sleep(nanoseconds: u64) -> () {
        unsafe {
            let result = aeron_nano_sleep(nanoseconds.into());
            result.into()
        }
    }
    #[inline]
    pub fn micro_sleep(microseconds: ::std::os::raw::c_uint) -> () {
        unsafe {
            let result = aeron_micro_sleep(microseconds.into());
            result.into()
        }
    }
    #[inline]
    pub fn thread_set_affinity(
        role_name: &std::ffi::CStr,
        cpu_affinity_no: u8,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_thread_set_affinity(role_name.as_ptr(), cpu_affinity_no.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn error_log_exists(buffer: *const u8, buffer_size: usize) -> bool {
        unsafe {
            let result = aeron_error_log_exists(buffer.into(), buffer_size.into());
            result.into()
        }
    }
    #[inline]
    pub fn error_log_read<AeronErrorLogReaderFuncHandlerImpl: AeronErrorLogReaderFuncCallback>(
        buffer: *const u8,
        buffer_size: usize,
        reader: Option<&Handler<AeronErrorLogReaderFuncHandlerImpl>>,
        since_timestamp: i64,
    ) -> usize {
        unsafe {
            let result = aeron_error_log_read(
                buffer.into(),
                buffer_size.into(),
                {
                    let callback: aeron_error_log_reader_func_t = if reader.is_none() {
                        None
                    } else {
                        Some(
                            aeron_error_log_reader_func_t_callback::<
                                AeronErrorLogReaderFuncHandlerImpl,
                            >,
                        )
                    };
                    callback
                },
                reader
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                since_timestamp.into(),
            );
            result.into()
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn error_log_read_once<
        AeronErrorLogReaderFuncHandlerImpl: FnMut(i32, i64, i64, &str) -> (),
    >(
        buffer: *const u8,
        buffer_size: usize,
        mut reader: AeronErrorLogReaderFuncHandlerImpl,
        since_timestamp: i64,
    ) -> usize {
        unsafe {
            let result = aeron_error_log_read(
                buffer.into(),
                buffer_size.into(),
                Some(
                    aeron_error_log_reader_func_t_callback_for_once_closure::<
                        AeronErrorLogReaderFuncHandlerImpl,
                    >,
                ),
                &mut reader as *mut _ as *mut std::os::raw::c_void,
                since_timestamp.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn semantic_version_compose(major: u8, minor: u8, patch: u8) -> i32 {
        unsafe {
            let result = aeron_semantic_version_compose(major.into(), minor.into(), patch.into());
            result.into()
        }
    }
    #[inline]
    pub fn semantic_version_major(version: i32) -> u8 {
        unsafe {
            let result = aeron_semantic_version_major(version.into());
            result.into()
        }
    }
    #[inline]
    pub fn semantic_version_minor(version: i32) -> u8 {
        unsafe {
            let result = aeron_semantic_version_minor(version.into());
            result.into()
        }
    }
    #[inline]
    pub fn semantic_version_patch(version: i32) -> u8 {
        unsafe {
            let result = aeron_semantic_version_patch(version.into());
            result.into()
        }
    }
    #[inline]
    #[doc = "Delete the given aeron directory."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `dirname` to delete."]
    #[doc = " \n# Return\n 0 for success and -1 for error."]
    pub fn delete_directory(dirname: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_delete_directory(dirname.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = "Affinity setting function that complies with the aeron_agent_on_start_func_t structure that can"]
    #[doc = " be used as an agent start function.  The state should be the `AeronDriverContext`* and the function"]
    #[doc = " will match the values \"conductor\", \"sender\", \"receiver\" and use the respective configuration options from"]
    #[doc = " the `AeronDriverContext`."]
    #[doc = ""]
    #[doc = "# Parameters\n \n - `state` client information passed to function, should be the `AeronDriverContext`*."]
    #[doc = " \n - `role_name` name of the role specified on the agent."]
    pub fn set_thread_affinity_on_start(
        state: *mut ::std::os::raw::c_void,
        role_name: &std::ffi::CStr,
    ) -> () {
        unsafe {
            let result = aeron_set_thread_affinity_on_start(state.into(), role_name.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn set_socket_non_blocking(fd: aeron_socket_t) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_set_socket_non_blocking(fd.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn socket(
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> aeron_socket_t {
        unsafe {
            let result = aeron_socket(domain.into(), type_.into(), protocol.into());
            result.into()
        }
    }
    #[inline]
    pub fn close_socket(socket: aeron_socket_t) -> () {
        unsafe {
            let result = aeron_close_socket(socket.into());
            result.into()
        }
    }
    #[inline]
    pub fn connect(
        fd: aeron_socket_t,
        address: &Sockaddr,
        address_length: socklen_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_connect(fd.into(), address.get_inner(), address_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn bind(
        fd: aeron_socket_t,
        address: &Sockaddr,
        address_length: socklen_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_bind(fd.into(), address.get_inner(), address_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn net_init() -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_net_init();
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn getsockopt(
        fd: aeron_socket_t,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: *mut socklen_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_getsockopt(
                fd.into(),
                level.into(),
                optname.into(),
                optval.into(),
                optlen.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn setsockopt(
        fd: aeron_socket_t,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *const ::std::os::raw::c_void,
        optlen: socklen_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_setsockopt(
                fd.into(),
                level.into(),
                optname.into(),
                optval.into(),
                optlen.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn sendmsg(fd: aeron_socket_t, msghdr: &Msghdr, flags: ::std::os::raw::c_int) -> isize {
        unsafe {
            let result = aeron_sendmsg(fd.into(), msghdr.get_inner(), flags.into());
            result.into()
        }
    }
    #[inline]
    pub fn send(
        fd: aeron_socket_t,
        buf: *const ::std::os::raw::c_void,
        len: usize,
        flags: ::std::os::raw::c_int,
    ) -> isize {
        unsafe {
            let result = aeron_send(fd.into(), buf.into(), len.into(), flags.into());
            result.into()
        }
    }
    #[inline]
    pub fn recvmsg(fd: aeron_socket_t, msghdr: &Msghdr, flags: ::std::os::raw::c_int) -> isize {
        unsafe {
            let result = aeron_recvmsg(fd.into(), msghdr.get_inner(), flags.into());
            result.into()
        }
    }
    #[inline]
    pub fn res_header_entry_length(
        res: *mut ::std::os::raw::c_void,
        remaining: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_res_header_entry_length(res.into(), remaining.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn logbuffer_check_term_length(term_length: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_logbuffer_check_term_length(term_length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn logbuffer_check_page_size(page_size: u64) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_logbuffer_check_page_size(page_size.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn is_directory(path: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_is_directory(path.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn mkdir_recursive(
        pathname: &std::ffi::CStr,
        permission: ::std::os::raw::c_int,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_mkdir_recursive(pathname.as_ptr(), permission.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn msync(addr: *mut ::std::os::raw::c_void, length: usize) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_msync(addr.into(), length.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn delete_file(path: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_delete_file(path.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn file_length(path: &std::ffi::CStr) -> i64 {
        unsafe {
            let result = aeron_file_length(path.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn usable_fs_space(path: &std::ffi::CStr) -> u64 {
        unsafe {
            let result = aeron_usable_fs_space(path.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn usable_fs_space_disabled(path: &std::ffi::CStr) -> u64 {
        unsafe {
            let result = aeron_usable_fs_space_disabled(path.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn ipc_publication_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: &std::ffi::CStr,
        correlation_id: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_ipc_publication_location(
                dst.into(),
                length.into(),
                aeron_dir.as_ptr(),
                correlation_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn temp_filename(filename: *mut ::std::os::raw::c_char, length: usize) -> usize {
        unsafe {
            let result = aeron_temp_filename(filename.into(), length.into());
            result.into()
        }
    }
    #[inline]
    pub fn file_resolve(
        parent: &std::ffi::CStr,
        child: &std::ffi::CStr,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_file_resolve(
                parent.as_ptr(),
                child.as_ptr(),
                buffer.into(),
                buffer_len.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn flow_control_parse_tagged_options(
        options_length: usize,
        options: &std::ffi::CStr,
        flow_control_options: &AeronFlowControlTaggedOptions,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_flow_control_parse_tagged_options(
                options_length.into(),
                options.as_ptr(),
                flow_control_options.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn flow_control_calculate_retransmission_length(
        resend_length: usize,
        term_buffer_length: usize,
        term_offset: usize,
        retransmit_receiver_window_multiple: usize,
    ) -> usize {
        unsafe {
            let result = aeron_flow_control_calculate_retransmission_length(
                resend_length.into(),
                term_buffer_length.into(),
                term_offset.into(),
                retransmit_receiver_window_multiple.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn agent_on_start_load(name: &std::ffi::CStr) -> aeron_agent_on_start_func_t {
        unsafe {
            let result = aeron_agent_on_start_load(name.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn set_errno(errcode: ::std::os::raw::c_int) -> () {
        unsafe {
            let result = aeron_set_errno(errcode.into());
            result.into()
        }
    }
    #[inline]
    pub fn err_set(
        errcode: ::std::os::raw::c_int,
        function: &std::ffi::CStr,
        filename: &std::ffi::CStr,
        line_number: ::std::os::raw::c_int,
        format: &std::ffi::CStr,
    ) -> () {
        unsafe {
            let result = aeron_err_set(
                errcode.into(),
                function.as_ptr(),
                filename.as_ptr(),
                line_number.into(),
                format.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn err_append(
        function: &std::ffi::CStr,
        filename: &std::ffi::CStr,
        line_number: ::std::os::raw::c_int,
        format: &std::ffi::CStr,
    ) -> () {
        unsafe {
            let result = aeron_err_append(
                function.as_ptr(),
                filename.as_ptr(),
                line_number.into(),
                format.as_ptr(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn err_clear() -> () {
        unsafe {
            let result = aeron_err_clear();
            result.into()
        }
    }
    #[inline]
    pub fn parse_port_range(
        range_str: &std::ffi::CStr,
        low_port: &mut u16,
        high_port: &mut u16,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_parse_port_range(range_str.as_ptr(), low_port as *mut _, high_port as *mut _);
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn config_parse_inferable_boolean(
        inferable_boolean: &std::ffi::CStr,
        def: aeron_inferable_boolean_t,
    ) -> aeron_inferable_boolean_t {
        unsafe {
            let result =
                aeron_config_parse_inferable_boolean(inferable_boolean.as_ptr(), def.into());
            result.into()
        }
    }
    #[inline]
    pub fn format_date(str_: *mut ::std::os::raw::c_char, count: usize, timestamp: i64) -> () {
        unsafe {
            let result = aeron_format_date(str_.into(), count.into(), timestamp.into());
            result.into()
        }
    }
    #[inline]
    pub fn format_number_to_locale(
        value: ::std::os::raw::c_longlong,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> *mut ::std::os::raw::c_char {
        unsafe {
            let result =
                aeron_format_number_to_locale(value.into(), buffer.into(), buffer_len.into());
            result.into()
        }
    }
    #[inline]
    pub fn format_to_hex(
        str_: *mut ::std::os::raw::c_char,
        str_length: usize,
        data: *const u8,
        data_len: usize,
    ) -> () {
        unsafe {
            let result =
                aeron_format_to_hex(str_.into(), str_length.into(), data.into(), data_len.into());
            result.into()
        }
    }
    #[inline]
    pub fn ip_addr_resolver(
        host: &std::ffi::CStr,
        sockaddr: &SockaddrStorage,
        family_hint: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_ip_addr_resolver(
                host.as_ptr(),
                sockaddr.get_inner(),
                family_hint.into(),
                protocol.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn udp_port_resolver(
        port_str: &std::ffi::CStr,
        optional: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_port_resolver(port_str.as_ptr(), optional.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn try_parse_ipv4(host: &std::ffi::CStr, sockaddr: &SockaddrStorage) -> bool {
        unsafe {
            let result = aeron_try_parse_ipv4(host.as_ptr(), sockaddr.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn ipv4_addr_resolver(
        host: &std::ffi::CStr,
        protocol: ::std::os::raw::c_int,
        sockaddr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_ipv4_addr_resolver(host.as_ptr(), protocol.into(), sockaddr.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn try_parse_ipv6(host: &std::ffi::CStr, sockaddr: &SockaddrStorage) -> bool {
        unsafe {
            let result = aeron_try_parse_ipv6(host.as_ptr(), sockaddr.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn ipv6_addr_resolver(
        host: &std::ffi::CStr,
        protocol: ::std::os::raw::c_int,
        sockaddr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_ipv6_addr_resolver(host.as_ptr(), protocol.into(), sockaddr.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn lookup_interfaces<AeronIfaddrFuncHandlerImpl: AeronIfaddrFuncCallback>(
        func: Option<&Handler<AeronIfaddrFuncHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_lookup_interfaces(
                {
                    let callback: aeron_ifaddr_func_t = if func.is_none() {
                        None
                    } else {
                        Some(aeron_ifaddr_func_t_callback::<AeronIfaddrFuncHandlerImpl>)
                    };
                    callback
                },
                func.map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn lookup_interfaces_once<
        AeronIfaddrFuncHandlerImpl: FnMut(&str, Sockaddr, Sockaddr, ::std::os::raw::c_uint) -> ::std::os::raw::c_int,
    >(
        mut func: AeronIfaddrFuncHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_lookup_interfaces(
                Some(aeron_ifaddr_func_t_callback_for_once_closure::<AeronIfaddrFuncHandlerImpl>),
                &mut func as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn lookup_interfaces_from_ifaddrs<AeronIfaddrFuncHandlerImpl: AeronIfaddrFuncCallback>(
        func: Option<&Handler<AeronIfaddrFuncHandlerImpl>>,
        ifaddrs: &Ifaddrs,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_lookup_interfaces_from_ifaddrs(
                {
                    let callback: aeron_ifaddr_func_t = if func.is_none() {
                        None
                    } else {
                        Some(aeron_ifaddr_func_t_callback::<AeronIfaddrFuncHandlerImpl>)
                    };
                    callback
                },
                func.map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
                ifaddrs.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn lookup_interfaces_from_ifaddrs_once<
        AeronIfaddrFuncHandlerImpl: FnMut(&str, Sockaddr, Sockaddr, ::std::os::raw::c_uint) -> ::std::os::raw::c_int,
    >(
        mut func: AeronIfaddrFuncHandlerImpl,
        ifaddrs: &Ifaddrs,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_lookup_interfaces_from_ifaddrs(
                Some(aeron_ifaddr_func_t_callback_for_once_closure::<AeronIfaddrFuncHandlerImpl>),
                &mut func as *mut _ as *mut std::os::raw::c_void,
                ifaddrs.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_getifaddrs(
        get_func: aeron_getifaddrs_func_t,
        free_func: aeron_freeifaddrs_func_t,
    ) -> () {
        unsafe {
            let result = aeron_set_getifaddrs(get_func.into(), free_func.into());
            result.into()
        }
    }
    #[inline]
    pub fn interface_parse_and_resolve(
        interface_str: &std::ffi::CStr,
        sockaddr: &SockaddrStorage,
    ) -> Result<usize, AeronCError> {
        unsafe {
            let mut mut_result: usize = Default::default();
            let err_code = aeron_interface_parse_and_resolve(
                interface_str.as_ptr(),
                sockaddr.get_inner(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn ipv4_netmask_from_prefixlen(prefixlen: usize) -> u32 {
        unsafe {
            let result = aeron_ipv4_netmask_from_prefixlen(prefixlen.into());
            result.into()
        }
    }
    #[inline]
    pub fn find_interface(
        interface_str: &std::ffi::CStr,
        if_addr: &SockaddrStorage,
        if_index: *mut ::std::os::raw::c_uint,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_find_interface(interface_str.as_ptr(), if_addr.get_inner(), if_index.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn find_unicast_interface(
        family: ::std::os::raw::c_int,
        interface_str: &std::ffi::CStr,
        interface_addr: &SockaddrStorage,
        interface_index: *mut ::std::os::raw::c_uint,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_find_unicast_interface(
                family.into(),
                interface_str.as_ptr(),
                interface_addr.get_inner(),
                interface_index.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn format_source_identity(
        buffer: *mut ::std::os::raw::c_char,
        length: usize,
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_format_source_identity(buffer.into(), length.into(), addr.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn netutil_get_so_buf_lengths(
        default_so_rcvbuf: &mut usize,
        default_so_sndbuf: &mut usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_netutil_get_so_buf_lengths(
                default_so_rcvbuf as *mut _,
                default_so_sndbuf as *mut _,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn parse_size64(str_: &std::ffi::CStr) -> Result<u64, AeronCError> {
        unsafe {
            let mut mut_result: u64 = Default::default();
            let err_code = aeron_parse_size64(str_.as_ptr(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn parse_duration_ns(str_: &std::ffi::CStr) -> Result<u64, AeronCError> {
        unsafe {
            let mut mut_result: u64 = Default::default();
            let err_code = aeron_parse_duration_ns(str_.as_ptr(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn parse_bool(str_: &std::ffi::CStr, def: bool) -> bool {
        unsafe {
            let result = aeron_parse_bool(str_.as_ptr(), def.into());
            result.into()
        }
    }
    #[inline]
    pub fn address_split(
        address_str: &std::ffi::CStr,
        parsed_address: &AeronParsedAddress,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_address_split(address_str.as_ptr(), parsed_address.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn interface_split(
        interface_str: &std::ffi::CStr,
        parsed_interface: &AeronParsedInterface,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_interface_split(interface_str.as_ptr(), parsed_interface.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn parse_get_line(
        line: *mut ::std::os::raw::c_char,
        max_length: usize,
        buffer: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_parse_get_line(line.into(), max_length.into(), buffer.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn config_prop_warning(name: &std::ffi::CStr, str_: &std::ffi::CStr) -> () {
        unsafe {
            let result = aeron_config_prop_warning(name.as_ptr(), str_.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_uint64(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: u64,
        min: u64,
        max: u64,
    ) -> u64 {
        unsafe {
            let result = aeron_config_parse_uint64(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_int32(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: i32,
        min: i32,
        max: i32,
    ) -> i32 {
        unsafe {
            let result = aeron_config_parse_int32(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_int64(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: i64,
        min: i64,
        max: i64,
    ) -> i64 {
        unsafe {
            let result = aeron_config_parse_int64(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_uint32(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: u32,
        min: u32,
        max: u32,
    ) -> u32 {
        unsafe {
            let result = aeron_config_parse_uint32(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_size64(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: u64,
        min: u64,
        max: u64,
    ) -> u64 {
        unsafe {
            let result = aeron_config_parse_size64(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn config_parse_duration_ns(
        name: &std::ffi::CStr,
        str_: &std::ffi::CStr,
        def: u64,
        min: u64,
        max: u64,
    ) -> u64 {
        unsafe {
            let result = aeron_config_parse_duration_ns(
                name.as_ptr(),
                str_.as_ptr(),
                def.into(),
                min.into(),
                max.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Aeron {
    type Target = aeron_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_t> for Aeron {
    #[inline]
    fn from(value: *mut aeron_t) -> Self {
        Aeron {
            inner: CResource::Borrowed(value),
            _context: None,
        }
    }
}
impl From<Aeron> for *mut aeron_t {
    #[inline]
    fn from(value: Aeron) -> Self {
        value.get_inner()
    }
}
impl From<&Aeron> for *mut aeron_t {
    #[inline]
    fn from(value: &Aeron) -> Self {
        value.get_inner()
    }
}
impl From<Aeron> for aeron_t {
    #[inline]
    fn from(value: Aeron) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_t> for Aeron {
    #[inline]
    fn from(value: *const aeron_t) -> Self {
        Aeron {
            inner: CResource::Borrowed(value as *mut aeron_t),
            _context: None,
        }
    }
}
impl From<aeron_t> for Aeron {
    #[inline]
    fn from(value: aeron_t) -> Self {
        Aeron {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
            _context: None,
        }
    }
}
#[derive(Clone)]
pub struct AeronTerminateDriverCommand {
    inner: CResource<aeron_terminate_driver_command_t>,
}
impl core::fmt::Debug for AeronTerminateDriverCommand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronTerminateDriverCommand))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronTerminateDriverCommand))
                .field("inner", &self.inner)
                .field(stringify!(correlated), &self.correlated())
                .field(stringify!(token_length), &self.token_length())
                .finish()
        }
    }
}
impl AeronTerminateDriverCommand {
    #[inline]
    pub fn new(correlated: AeronCorrelatedCommand, token_length: i32) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_terminate_driver_command_t {
                    correlated: correlated.into(),
                    token_length: token_length.into(),
                };
                let inner_ptr: *mut aeron_terminate_driver_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_terminate_driver_command_t)
                );
                let inst: aeron_terminate_driver_command_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_terminate_driver_command_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_terminate_driver_command_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn correlated(&self) -> AeronCorrelatedCommand {
        self.correlated.into()
    }
    #[inline]
    pub fn token_length(&self) -> i32 {
        self.token_length.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_terminate_driver_command_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_terminate_driver_command_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_terminate_driver_command_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronTerminateDriverCommand {
    type Target = aeron_terminate_driver_command_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_terminate_driver_command_t> for AeronTerminateDriverCommand {
    #[inline]
    fn from(value: *mut aeron_terminate_driver_command_t) -> Self {
        AeronTerminateDriverCommand {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronTerminateDriverCommand> for *mut aeron_terminate_driver_command_t {
    #[inline]
    fn from(value: AeronTerminateDriverCommand) -> Self {
        value.get_inner()
    }
}
impl From<&AeronTerminateDriverCommand> for *mut aeron_terminate_driver_command_t {
    #[inline]
    fn from(value: &AeronTerminateDriverCommand) -> Self {
        value.get_inner()
    }
}
impl From<AeronTerminateDriverCommand> for aeron_terminate_driver_command_t {
    #[inline]
    fn from(value: AeronTerminateDriverCommand) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_terminate_driver_command_t> for AeronTerminateDriverCommand {
    #[inline]
    fn from(value: *const aeron_terminate_driver_command_t) -> Self {
        AeronTerminateDriverCommand {
            inner: CResource::Borrowed(value as *mut aeron_terminate_driver_command_t),
        }
    }
}
impl From<aeron_terminate_driver_command_t> for AeronTerminateDriverCommand {
    #[inline]
    fn from(value: aeron_terminate_driver_command_t) -> Self {
        AeronTerminateDriverCommand {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronTerminateDriverCommand {
    fn default() -> Self {
        AeronTerminateDriverCommand::new_zeroed_on_heap()
    }
}
impl AeronTerminateDriverCommand {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronTetherablePosition {
    inner: CResource<aeron_tetherable_position_t>,
}
impl core::fmt::Debug for AeronTetherablePosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronTetherablePosition))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronTetherablePosition))
                .field("inner", &self.inner)
                .field(stringify!(is_tether), &self.is_tether())
                .field(stringify!(counter_id), &self.counter_id())
                .field(
                    stringify!(subscription_registration_id),
                    &self.subscription_registration_id(),
                )
                .field(
                    stringify!(time_of_last_update_ns),
                    &self.time_of_last_update_ns(),
                )
                .finish()
        }
    }
}
impl AeronTetherablePosition {
    #[inline]
    pub fn new(
        is_tether: bool,
        state: aeron_subscription_tether_state_t,
        counter_id: i32,
        value_addr: &mut i64,
        subscription_registration_id: i64,
        time_of_last_update_ns: i64,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_tetherable_position_t {
                    is_tether: is_tether.into(),
                    state: state.into(),
                    counter_id: counter_id.into(),
                    value_addr: value_addr as *mut _,
                    subscription_registration_id: subscription_registration_id.into(),
                    time_of_last_update_ns: time_of_last_update_ns.into(),
                };
                let inner_ptr: *mut aeron_tetherable_position_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_tetherable_position_t)
                );
                let inst: aeron_tetherable_position_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_tetherable_position_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_tetherable_position_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn is_tether(&self) -> bool {
        self.is_tether.into()
    }
    #[inline]
    pub fn state(&self) -> aeron_subscription_tether_state_t {
        self.state.into()
    }
    #[inline]
    pub fn counter_id(&self) -> i32 {
        self.counter_id.into()
    }
    #[inline]
    pub fn value_addr(&self) -> &mut i64 {
        unsafe { &mut *self.value_addr }
    }
    #[inline]
    pub fn subscription_registration_id(&self) -> i64 {
        self.subscription_registration_id.into()
    }
    #[inline]
    pub fn time_of_last_update_ns(&self) -> i64 {
        self.time_of_last_update_ns.into()
    }
    #[inline]
    pub fn aeron_untethered_subscription_state_change(
        &self,
        now_ns: i64,
        new_state: aeron_subscription_tether_state_t,
        stream_id: i32,
        session_id: i32,
    ) -> () {
        unsafe {
            let result = aeron_untethered_subscription_state_change(
                self.get_inner(),
                now_ns.into(),
                new_state.into(),
                stream_id.into(),
                session_id.into(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_tetherable_position_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_tetherable_position_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_tetherable_position_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronTetherablePosition {
    type Target = aeron_tetherable_position_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_tetherable_position_t> for AeronTetherablePosition {
    #[inline]
    fn from(value: *mut aeron_tetherable_position_t) -> Self {
        AeronTetherablePosition {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronTetherablePosition> for *mut aeron_tetherable_position_t {
    #[inline]
    fn from(value: AeronTetherablePosition) -> Self {
        value.get_inner()
    }
}
impl From<&AeronTetherablePosition> for *mut aeron_tetherable_position_t {
    #[inline]
    fn from(value: &AeronTetherablePosition) -> Self {
        value.get_inner()
    }
}
impl From<AeronTetherablePosition> for aeron_tetherable_position_t {
    #[inline]
    fn from(value: AeronTetherablePosition) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_tetherable_position_t> for AeronTetherablePosition {
    #[inline]
    fn from(value: *const aeron_tetherable_position_t) -> Self {
        AeronTetherablePosition {
            inner: CResource::Borrowed(value as *mut aeron_tetherable_position_t),
        }
    }
}
impl From<aeron_tetherable_position_t> for AeronTetherablePosition {
    #[inline]
    fn from(value: aeron_tetherable_position_t) -> Self {
        AeronTetherablePosition {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronTetherablePosition {
    fn default() -> Self {
        AeronTetherablePosition::new_zeroed_on_heap()
    }
}
impl AeronTetherablePosition {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelAsyncParse {
    inner: CResource<aeron_udp_channel_async_parse_t>,
}
impl core::fmt::Debug for AeronUdpChannelAsyncParse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelAsyncParse))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelAsyncParse))
                .field("inner", &self.inner)
                .field(stringify!(is_destination), &self.is_destination())
                .finish()
        }
    }
}
impl AeronUdpChannelAsyncParse {
    #[inline]
    pub fn new(channel: &AeronUdpChannel, is_destination: bool) -> Result<Self, AeronCError> {
        let channel_copy = channel.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_async_parse_t {
                    channel: channel.into(),
                    is_destination: is_destination.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_async_parse_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_async_parse_t)
                );
                let inst: aeron_udp_channel_async_parse_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_async_parse_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_async_parse_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn channel(&self) -> AeronUdpChannel {
        self.channel.into()
    }
    #[inline]
    pub fn is_destination(&self) -> bool {
        self.is_destination.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_async_parse_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_async_parse_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_async_parse_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelAsyncParse {
    type Target = aeron_udp_channel_async_parse_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_async_parse_t> for AeronUdpChannelAsyncParse {
    #[inline]
    fn from(value: *mut aeron_udp_channel_async_parse_t) -> Self {
        AeronUdpChannelAsyncParse {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelAsyncParse> for *mut aeron_udp_channel_async_parse_t {
    #[inline]
    fn from(value: AeronUdpChannelAsyncParse) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelAsyncParse> for *mut aeron_udp_channel_async_parse_t {
    #[inline]
    fn from(value: &AeronUdpChannelAsyncParse) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelAsyncParse> for aeron_udp_channel_async_parse_t {
    #[inline]
    fn from(value: AeronUdpChannelAsyncParse) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_async_parse_t> for AeronUdpChannelAsyncParse {
    #[inline]
    fn from(value: *const aeron_udp_channel_async_parse_t) -> Self {
        AeronUdpChannelAsyncParse {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_async_parse_t),
        }
    }
}
impl From<aeron_udp_channel_async_parse_t> for AeronUdpChannelAsyncParse {
    #[inline]
    fn from(value: aeron_udp_channel_async_parse_t) -> Self {
        AeronUdpChannelAsyncParse {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelAsyncParse {
    fn default() -> Self {
        AeronUdpChannelAsyncParse::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelAsyncParse {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelDataPaths {
    inner: CResource<aeron_udp_channel_data_paths_t>,
}
impl core::fmt::Debug for AeronUdpChannelDataPaths {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelDataPaths))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelDataPaths))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUdpChannelDataPaths {
    #[inline]
    pub fn new(
        outgoing_interceptors: &AeronUdpChannelOutgoingInterceptor,
        incoming_interceptors: &AeronUdpChannelIncomingInterceptor,
        send_func: aeron_udp_channel_transport_send_func_t,
        recv_func: aeron_udp_transport_recv_func_t,
    ) -> Result<Self, AeronCError> {
        let outgoing_interceptors_copy = outgoing_interceptors.clone();
        let incoming_interceptors_copy = incoming_interceptors.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_data_paths_t {
                    outgoing_interceptors: outgoing_interceptors.into(),
                    incoming_interceptors: incoming_interceptors.into(),
                    send_func: send_func.into(),
                    recv_func: recv_func.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_data_paths_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_data_paths_t)
                );
                let inst: aeron_udp_channel_data_paths_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_data_paths_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_data_paths_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn outgoing_interceptors(&self) -> AeronUdpChannelOutgoingInterceptor {
        self.outgoing_interceptors.into()
    }
    #[inline]
    pub fn incoming_interceptors(&self) -> AeronUdpChannelIncomingInterceptor {
        self.incoming_interceptors.into()
    }
    #[inline]
    pub fn send_func(&self) -> aeron_udp_channel_transport_send_func_t {
        self.send_func.into()
    }
    #[inline]
    pub fn recv_func(&self) -> aeron_udp_transport_recv_func_t {
        self.recv_func.into()
    }
    #[inline]
    pub fn aeron_udp_channel_incoming_interceptor_recv_func(
        &self,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
        media_timestamp: &Timespec,
    ) -> () {
        unsafe {
            let result = aeron_udp_channel_incoming_interceptor_recv_func(
                self.get_inner(),
                transport.into(),
                receiver_clientd.into(),
                endpoint_clientd.into(),
                destination_clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
                media_timestamp.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn init(
        &self,
        outgoing_interceptor_bindings: &AeronUdpChannelInterceptorBindings,
        incoming_interceptor_bindings: &AeronUdpChannelInterceptorBindings,
        media_bindings: *mut aeron_udp_channel_transport_bindings_t,
        recv_func: aeron_udp_transport_recv_func_t,
        context: &AeronDriverContext,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_channel_data_paths_init(
                self.get_inner(),
                outgoing_interceptor_bindings.get_inner(),
                incoming_interceptor_bindings.get_inner(),
                media_bindings.into(),
                recv_func.into(),
                context.get_inner(),
                affinity.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn delete(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_channel_data_paths_delete(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_udp_channel_transport_send(
        &self,
        transport: *mut aeron_udp_channel_transport_t,
        address: &SockaddrStorage,
        iov: &Iovec,
        iov_length: usize,
    ) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_udp_channel_transport_send(
                self.get_inner(),
                transport.into(),
                address.get_inner(),
                iov.get_inner(),
                iov_length.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_send_channel_endpoint_dispatch(
        &self,
        transport: *mut aeron_udp_channel_transport_t,
        sender_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
        media_timestamp: &Timespec,
    ) -> () {
        unsafe {
            let result = aeron_send_channel_endpoint_dispatch(
                self.get_inner(),
                transport.into(),
                sender_clientd.into(),
                endpoint_clientd.into(),
                destination_clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
                media_timestamp.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn aeron_receive_channel_endpoint_dispatch(
        &self,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: &mut [u8],
        addr: &SockaddrStorage,
        media_receive_timestamp: &Timespec,
    ) -> () {
        unsafe {
            let result = aeron_receive_channel_endpoint_dispatch(
                self.get_inner(),
                transport.into(),
                receiver_clientd.into(),
                endpoint_clientd.into(),
                destination_clientd.into(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
                media_receive_timestamp.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_data_paths_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_data_paths_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_data_paths_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelDataPaths {
    type Target = aeron_udp_channel_data_paths_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_data_paths_t> for AeronUdpChannelDataPaths {
    #[inline]
    fn from(value: *mut aeron_udp_channel_data_paths_t) -> Self {
        AeronUdpChannelDataPaths {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelDataPaths> for *mut aeron_udp_channel_data_paths_t {
    #[inline]
    fn from(value: AeronUdpChannelDataPaths) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelDataPaths> for *mut aeron_udp_channel_data_paths_t {
    #[inline]
    fn from(value: &AeronUdpChannelDataPaths) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelDataPaths> for aeron_udp_channel_data_paths_t {
    #[inline]
    fn from(value: AeronUdpChannelDataPaths) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_data_paths_t> for AeronUdpChannelDataPaths {
    #[inline]
    fn from(value: *const aeron_udp_channel_data_paths_t) -> Self {
        AeronUdpChannelDataPaths {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_data_paths_t),
        }
    }
}
impl From<aeron_udp_channel_data_paths_t> for AeronUdpChannelDataPaths {
    #[inline]
    fn from(value: aeron_udp_channel_data_paths_t) -> Self {
        AeronUdpChannelDataPaths {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelDataPaths {
    fn default() -> Self {
        AeronUdpChannelDataPaths::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelDataPaths {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelIncomingInterceptor {
    inner: CResource<aeron_udp_channel_incoming_interceptor_t>,
}
impl core::fmt::Debug for AeronUdpChannelIncomingInterceptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelIncomingInterceptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelIncomingInterceptor))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUdpChannelIncomingInterceptor {
    #[inline]
    pub fn new(
        interceptor_state: *mut ::std::os::raw::c_void,
        incoming_func: aeron_udp_channel_interceptor_incoming_func_t,
        close_func: aeron_udp_channel_interceptor_close_func_t,
        incoming_transport_notification_func : aeron_udp_channel_interceptor_transport_notification_func_t,
        incoming_publication_notification_func : aeron_udp_channel_interceptor_publication_notification_func_t,
        incoming_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
        next_interceptor: &AeronUdpChannelIncomingInterceptor,
    ) -> Result<Self, AeronCError> {
        let next_interceptor_copy = next_interceptor.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_incoming_interceptor_t {
                    interceptor_state: interceptor_state.into(),
                    incoming_func: incoming_func.into(),
                    close_func: close_func.into(),
                    incoming_transport_notification_func: incoming_transport_notification_func
                        .into(),
                    incoming_publication_notification_func: incoming_publication_notification_func
                        .into(),
                    incoming_image_notification_func: incoming_image_notification_func.into(),
                    next_interceptor: next_interceptor.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_incoming_interceptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_incoming_interceptor_t)
                );
                let inst: aeron_udp_channel_incoming_interceptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_incoming_interceptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_incoming_interceptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn interceptor_state(&self) -> *mut ::std::os::raw::c_void {
        self.interceptor_state.into()
    }
    #[inline]
    pub fn incoming_func(&self) -> aeron_udp_channel_interceptor_incoming_func_t {
        self.incoming_func.into()
    }
    #[inline]
    pub fn close_func(&self) -> aeron_udp_channel_interceptor_close_func_t {
        self.close_func.into()
    }
    #[inline]
    pub fn incoming_transport_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_transport_notification_func_t {
        self.incoming_transport_notification_func.into()
    }
    #[inline]
    pub fn incoming_publication_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_publication_notification_func_t {
        self.incoming_publication_notification_func.into()
    }
    #[inline]
    pub fn incoming_image_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_image_notification_func_t {
        self.incoming_image_notification_func.into()
    }
    #[inline]
    pub fn next_interceptor(&self) -> AeronUdpChannelIncomingInterceptor {
        self.next_interceptor.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_incoming_interceptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_incoming_interceptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_incoming_interceptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelIncomingInterceptor {
    type Target = aeron_udp_channel_incoming_interceptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_incoming_interceptor_t> for AeronUdpChannelIncomingInterceptor {
    #[inline]
    fn from(value: *mut aeron_udp_channel_incoming_interceptor_t) -> Self {
        AeronUdpChannelIncomingInterceptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelIncomingInterceptor> for *mut aeron_udp_channel_incoming_interceptor_t {
    #[inline]
    fn from(value: AeronUdpChannelIncomingInterceptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelIncomingInterceptor> for *mut aeron_udp_channel_incoming_interceptor_t {
    #[inline]
    fn from(value: &AeronUdpChannelIncomingInterceptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelIncomingInterceptor> for aeron_udp_channel_incoming_interceptor_t {
    #[inline]
    fn from(value: AeronUdpChannelIncomingInterceptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_incoming_interceptor_t> for AeronUdpChannelIncomingInterceptor {
    #[inline]
    fn from(value: *const aeron_udp_channel_incoming_interceptor_t) -> Self {
        AeronUdpChannelIncomingInterceptor {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_incoming_interceptor_t),
        }
    }
}
impl From<aeron_udp_channel_incoming_interceptor_t> for AeronUdpChannelIncomingInterceptor {
    #[inline]
    fn from(value: aeron_udp_channel_incoming_interceptor_t) -> Self {
        AeronUdpChannelIncomingInterceptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelIncomingInterceptor {
    fn default() -> Self {
        AeronUdpChannelIncomingInterceptor::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelIncomingInterceptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelInterceptorBindings {
    inner: CResource<aeron_udp_channel_interceptor_bindings_t>,
}
impl core::fmt::Debug for AeronUdpChannelInterceptorBindings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelInterceptorBindings))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelInterceptorBindings))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUdpChannelInterceptorBindings {
    #[inline]
    pub fn new(
        outgoing_init_func: aeron_udp_channel_interceptor_init_func_t,
        incoming_init_func: aeron_udp_channel_interceptor_init_func_t,
        outgoing_send_func: aeron_udp_channel_interceptor_outgoing_send_func_t,
        incoming_func: aeron_udp_channel_interceptor_incoming_func_t,
        outgoing_close_func: aeron_udp_channel_interceptor_close_func_t,
        incoming_close_func: aeron_udp_channel_interceptor_close_func_t,
        outgoing_transport_notification_func : aeron_udp_channel_interceptor_transport_notification_func_t,
        incoming_transport_notification_func : aeron_udp_channel_interceptor_transport_notification_func_t,
        outgoing_publication_notification_func : aeron_udp_channel_interceptor_publication_notification_func_t,
        incoming_publication_notification_func : aeron_udp_channel_interceptor_publication_notification_func_t,
        outgoing_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
        incoming_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
        meta_info: aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_interceptor_bindings_t {
                    outgoing_init_func: outgoing_init_func.into(),
                    incoming_init_func: incoming_init_func.into(),
                    outgoing_send_func: outgoing_send_func.into(),
                    incoming_func: incoming_func.into(),
                    outgoing_close_func: outgoing_close_func.into(),
                    incoming_close_func: incoming_close_func.into(),
                    outgoing_transport_notification_func: outgoing_transport_notification_func
                        .into(),
                    incoming_transport_notification_func: incoming_transport_notification_func
                        .into(),
                    outgoing_publication_notification_func: outgoing_publication_notification_func
                        .into(),
                    incoming_publication_notification_func: incoming_publication_notification_func
                        .into(),
                    outgoing_image_notification_func: outgoing_image_notification_func.into(),
                    incoming_image_notification_func: incoming_image_notification_func.into(),
                    meta_info: meta_info.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_interceptor_bindings_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_interceptor_bindings_t)
                );
                let inst: aeron_udp_channel_interceptor_bindings_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_interceptor_bindings_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_interceptor_bindings_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn outgoing_init_func(&self) -> aeron_udp_channel_interceptor_init_func_t {
        self.outgoing_init_func.into()
    }
    #[inline]
    pub fn incoming_init_func(&self) -> aeron_udp_channel_interceptor_init_func_t {
        self.incoming_init_func.into()
    }
    #[inline]
    pub fn outgoing_send_func(&self) -> aeron_udp_channel_interceptor_outgoing_send_func_t {
        self.outgoing_send_func.into()
    }
    #[inline]
    pub fn incoming_func(&self) -> aeron_udp_channel_interceptor_incoming_func_t {
        self.incoming_func.into()
    }
    #[inline]
    pub fn outgoing_close_func(&self) -> aeron_udp_channel_interceptor_close_func_t {
        self.outgoing_close_func.into()
    }
    #[inline]
    pub fn incoming_close_func(&self) -> aeron_udp_channel_interceptor_close_func_t {
        self.incoming_close_func.into()
    }
    #[inline]
    pub fn outgoing_transport_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_transport_notification_func_t {
        self.outgoing_transport_notification_func.into()
    }
    #[inline]
    pub fn incoming_transport_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_transport_notification_func_t {
        self.incoming_transport_notification_func.into()
    }
    #[inline]
    pub fn outgoing_publication_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_publication_notification_func_t {
        self.outgoing_publication_notification_func.into()
    }
    #[inline]
    pub fn incoming_publication_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_publication_notification_func_t {
        self.incoming_publication_notification_func.into()
    }
    #[inline]
    pub fn outgoing_image_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_image_notification_func_t {
        self.outgoing_image_notification_func.into()
    }
    #[inline]
    pub fn incoming_image_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_image_notification_func_t {
        self.incoming_image_notification_func.into()
    }
    #[inline]
    pub fn meta_info(
        &self,
    ) -> aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields {
        self.meta_info.into()
    }
    #[inline]
    pub fn load(&self, interceptors: &std::ffi::CStr) -> AeronUdpChannelInterceptorBindings {
        unsafe {
            let result = aeron_udp_channel_interceptor_bindings_load(
                self.get_inner(),
                interceptors.as_ptr(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_interceptor_bindings_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_interceptor_bindings_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_interceptor_bindings_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelInterceptorBindings {
    type Target = aeron_udp_channel_interceptor_bindings_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_interceptor_bindings_t> for AeronUdpChannelInterceptorBindings {
    #[inline]
    fn from(value: *mut aeron_udp_channel_interceptor_bindings_t) -> Self {
        AeronUdpChannelInterceptorBindings {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelInterceptorBindings> for *mut aeron_udp_channel_interceptor_bindings_t {
    #[inline]
    fn from(value: AeronUdpChannelInterceptorBindings) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelInterceptorBindings> for *mut aeron_udp_channel_interceptor_bindings_t {
    #[inline]
    fn from(value: &AeronUdpChannelInterceptorBindings) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelInterceptorBindings> for aeron_udp_channel_interceptor_bindings_t {
    #[inline]
    fn from(value: AeronUdpChannelInterceptorBindings) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_interceptor_bindings_t> for AeronUdpChannelInterceptorBindings {
    #[inline]
    fn from(value: *const aeron_udp_channel_interceptor_bindings_t) -> Self {
        AeronUdpChannelInterceptorBindings {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_interceptor_bindings_t),
        }
    }
}
impl From<aeron_udp_channel_interceptor_bindings_t> for AeronUdpChannelInterceptorBindings {
    #[inline]
    fn from(value: aeron_udp_channel_interceptor_bindings_t) -> Self {
        AeronUdpChannelInterceptorBindings {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelInterceptorBindings {
    fn default() -> Self {
        AeronUdpChannelInterceptorBindings::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelInterceptorBindings {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelOutgoingInterceptor {
    inner: CResource<aeron_udp_channel_outgoing_interceptor_t>,
}
impl core::fmt::Debug for AeronUdpChannelOutgoingInterceptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelOutgoingInterceptor))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelOutgoingInterceptor))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUdpChannelOutgoingInterceptor {
    #[inline]
    pub fn new(
        interceptor_state: *mut ::std::os::raw::c_void,
        outgoing_send_func: aeron_udp_channel_interceptor_outgoing_send_func_t,
        close_func: aeron_udp_channel_interceptor_close_func_t,
        outgoing_transport_notification_func : aeron_udp_channel_interceptor_transport_notification_func_t,
        outgoing_publication_notification_func : aeron_udp_channel_interceptor_publication_notification_func_t,
        outgoing_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
        next_interceptor: &AeronUdpChannelOutgoingInterceptor,
    ) -> Result<Self, AeronCError> {
        let next_interceptor_copy = next_interceptor.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_outgoing_interceptor_t {
                    interceptor_state: interceptor_state.into(),
                    outgoing_send_func: outgoing_send_func.into(),
                    close_func: close_func.into(),
                    outgoing_transport_notification_func: outgoing_transport_notification_func
                        .into(),
                    outgoing_publication_notification_func: outgoing_publication_notification_func
                        .into(),
                    outgoing_image_notification_func: outgoing_image_notification_func.into(),
                    next_interceptor: next_interceptor.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_outgoing_interceptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_outgoing_interceptor_t)
                );
                let inst: aeron_udp_channel_outgoing_interceptor_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_outgoing_interceptor_t =
                    Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_outgoing_interceptor_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn interceptor_state(&self) -> *mut ::std::os::raw::c_void {
        self.interceptor_state.into()
    }
    #[inline]
    pub fn outgoing_send_func(&self) -> aeron_udp_channel_interceptor_outgoing_send_func_t {
        self.outgoing_send_func.into()
    }
    #[inline]
    pub fn close_func(&self) -> aeron_udp_channel_interceptor_close_func_t {
        self.close_func.into()
    }
    #[inline]
    pub fn outgoing_transport_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_transport_notification_func_t {
        self.outgoing_transport_notification_func.into()
    }
    #[inline]
    pub fn outgoing_publication_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_publication_notification_func_t {
        self.outgoing_publication_notification_func.into()
    }
    #[inline]
    pub fn outgoing_image_notification_func(
        &self,
    ) -> aeron_udp_channel_interceptor_image_notification_func_t {
        self.outgoing_image_notification_func.into()
    }
    #[inline]
    pub fn next_interceptor(&self) -> AeronUdpChannelOutgoingInterceptor {
        self.next_interceptor.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_outgoing_interceptor_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_outgoing_interceptor_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_outgoing_interceptor_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelOutgoingInterceptor {
    type Target = aeron_udp_channel_outgoing_interceptor_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_outgoing_interceptor_t> for AeronUdpChannelOutgoingInterceptor {
    #[inline]
    fn from(value: *mut aeron_udp_channel_outgoing_interceptor_t) -> Self {
        AeronUdpChannelOutgoingInterceptor {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelOutgoingInterceptor> for *mut aeron_udp_channel_outgoing_interceptor_t {
    #[inline]
    fn from(value: AeronUdpChannelOutgoingInterceptor) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelOutgoingInterceptor> for *mut aeron_udp_channel_outgoing_interceptor_t {
    #[inline]
    fn from(value: &AeronUdpChannelOutgoingInterceptor) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelOutgoingInterceptor> for aeron_udp_channel_outgoing_interceptor_t {
    #[inline]
    fn from(value: AeronUdpChannelOutgoingInterceptor) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_outgoing_interceptor_t> for AeronUdpChannelOutgoingInterceptor {
    #[inline]
    fn from(value: *const aeron_udp_channel_outgoing_interceptor_t) -> Self {
        AeronUdpChannelOutgoingInterceptor {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_outgoing_interceptor_t),
        }
    }
}
impl From<aeron_udp_channel_outgoing_interceptor_t> for AeronUdpChannelOutgoingInterceptor {
    #[inline]
    fn from(value: aeron_udp_channel_outgoing_interceptor_t) -> Self {
        AeronUdpChannelOutgoingInterceptor {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelOutgoingInterceptor {
    fn default() -> Self {
        AeronUdpChannelOutgoingInterceptor::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelOutgoingInterceptor {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannelParams {
    inner: CResource<aeron_udp_channel_params_t>,
}
impl core::fmt::Debug for AeronUdpChannelParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannelParams))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannelParams))
                .field("inner", &self.inner)
                .field(stringify!(additional_params), &self.additional_params())
                .finish()
        }
    }
}
impl AeronUdpChannelParams {
    #[inline]
    pub fn new(
        endpoint: &std::ffi::CStr,
        bind_interface: &std::ffi::CStr,
        control: &std::ffi::CStr,
        control_mode: &std::ffi::CStr,
        channel_tag: &std::ffi::CStr,
        entity_tag: &std::ffi::CStr,
        ttl: &std::ffi::CStr,
        additional_params: AeronUriParams,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_channel_params_t {
                    endpoint: endpoint.as_ptr(),
                    bind_interface: bind_interface.as_ptr(),
                    control: control.as_ptr(),
                    control_mode: control_mode.as_ptr(),
                    channel_tag: channel_tag.as_ptr(),
                    entity_tag: entity_tag.as_ptr(),
                    ttl: ttl.as_ptr(),
                    additional_params: additional_params.into(),
                };
                let inner_ptr: *mut aeron_udp_channel_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_params_t)
                );
                let inst: aeron_udp_channel_params_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_params_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn endpoint(&self) -> &str {
        if self.endpoint.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.endpoint).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn bind_interface(&self) -> &str {
        if self.bind_interface.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.bind_interface)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn control(&self) -> &str {
        if self.control.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.control).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn control_mode(&self) -> &str {
        if self.control_mode.is_null() {
            ""
        } else {
            unsafe {
                std::ffi::CStr::from_ptr(self.control_mode)
                    .to_str()
                    .unwrap()
            }
        }
    }
    #[inline]
    pub fn channel_tag(&self) -> &str {
        if self.channel_tag.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.channel_tag).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn entity_tag(&self) -> &str {
        if self.entity_tag.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.entity_tag).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn ttl(&self) -> &str {
        if self.ttl.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.ttl).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn additional_params(&self) -> AeronUriParams {
        self.additional_params.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_params_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_params_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_params_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannelParams {
    type Target = aeron_udp_channel_params_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_params_t> for AeronUdpChannelParams {
    #[inline]
    fn from(value: *mut aeron_udp_channel_params_t) -> Self {
        AeronUdpChannelParams {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannelParams> for *mut aeron_udp_channel_params_t {
    #[inline]
    fn from(value: AeronUdpChannelParams) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannelParams> for *mut aeron_udp_channel_params_t {
    #[inline]
    fn from(value: &AeronUdpChannelParams) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannelParams> for aeron_udp_channel_params_t {
    #[inline]
    fn from(value: AeronUdpChannelParams) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_params_t> for AeronUdpChannelParams {
    #[inline]
    fn from(value: *const aeron_udp_channel_params_t) -> Self {
        AeronUdpChannelParams {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_params_t),
        }
    }
}
impl From<aeron_udp_channel_params_t> for AeronUdpChannelParams {
    #[inline]
    fn from(value: aeron_udp_channel_params_t) -> Self {
        AeronUdpChannelParams {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpChannelParams {
    fn default() -> Self {
        AeronUdpChannelParams::new_zeroed_on_heap()
    }
}
impl AeronUdpChannelParams {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpChannel {
    inner: CResource<aeron_udp_channel_t>,
}
impl core::fmt::Debug for AeronUdpChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpChannel))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpChannel))
                .field("inner", &self.inner)
                .field(stringify!(uri), &self.uri())
                .field(stringify!(remote_data), &self.remote_data())
                .field(stringify!(local_data), &self.local_data())
                .field(stringify!(remote_control), &self.remote_control())
                .field(stringify!(local_control), &self.local_control())
                .field(stringify!(tag_id), &self.tag_id())
                .field(stringify!(uri_length), &self.uri_length())
                .field(stringify!(canonical_length), &self.canonical_length())
                .field(
                    stringify!(has_explicit_endpoint),
                    &self.has_explicit_endpoint(),
                )
                .field(
                    stringify!(has_explicit_control),
                    &self.has_explicit_control(),
                )
                .field(stringify!(is_multicast), &self.is_multicast())
                .field(
                    stringify!(socket_sndbuf_length),
                    &self.socket_sndbuf_length(),
                )
                .field(
                    stringify!(socket_rcvbuf_length),
                    &self.socket_rcvbuf_length(),
                )
                .field(
                    stringify!(receiver_window_length),
                    &self.receiver_window_length(),
                )
                .field(
                    stringify!(media_rcv_timestamp_offset),
                    &self.media_rcv_timestamp_offset(),
                )
                .field(
                    stringify!(channel_rcv_timestamp_offset),
                    &self.channel_rcv_timestamp_offset(),
                )
                .field(
                    stringify!(channel_snd_timestamp_offset),
                    &self.channel_snd_timestamp_offset(),
                )
                .finish()
        }
    }
}
impl AeronUdpChannel {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_channel_t)
                );
                let inst: aeron_udp_channel_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_channel_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_channel_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn original_uri(&self) -> [::std::os::raw::c_char; 4096usize] {
        self.original_uri.into()
    }
    #[inline]
    pub fn canonical_form(&self) -> [::std::os::raw::c_char; 4096usize] {
        self.canonical_form.into()
    }
    #[inline]
    pub fn uri(&self) -> AeronUri {
        self.uri.into()
    }
    #[inline]
    pub fn remote_data(&self) -> SockaddrStorage {
        self.remote_data.into()
    }
    #[inline]
    pub fn local_data(&self) -> SockaddrStorage {
        self.local_data.into()
    }
    #[inline]
    pub fn remote_control(&self) -> SockaddrStorage {
        self.remote_control.into()
    }
    #[inline]
    pub fn local_control(&self) -> SockaddrStorage {
        self.local_control.into()
    }
    #[inline]
    pub fn tag_id(&self) -> i64 {
        self.tag_id.into()
    }
    #[inline]
    pub fn interface_index(&self) -> ::std::os::raw::c_uint {
        self.interface_index.into()
    }
    #[inline]
    pub fn uri_length(&self) -> usize {
        self.uri_length.into()
    }
    #[inline]
    pub fn canonical_length(&self) -> usize {
        self.canonical_length.into()
    }
    #[inline]
    pub fn multicast_ttl(&self) -> u8 {
        self.multicast_ttl.into()
    }
    #[inline]
    pub fn has_explicit_endpoint(&self) -> bool {
        self.has_explicit_endpoint.into()
    }
    #[inline]
    pub fn has_explicit_control(&self) -> bool {
        self.has_explicit_control.into()
    }
    #[inline]
    pub fn control_mode(&self) -> aeron_udp_channel_control_mode {
        self.control_mode.into()
    }
    #[inline]
    pub fn is_multicast(&self) -> bool {
        self.is_multicast.into()
    }
    #[inline]
    pub fn ats_status(&self) -> aeron_uri_ats_status_t {
        self.ats_status.into()
    }
    #[inline]
    pub fn socket_sndbuf_length(&self) -> usize {
        self.socket_sndbuf_length.into()
    }
    #[inline]
    pub fn socket_rcvbuf_length(&self) -> usize {
        self.socket_rcvbuf_length.into()
    }
    #[inline]
    pub fn receiver_window_length(&self) -> usize {
        self.receiver_window_length.into()
    }
    #[inline]
    pub fn media_rcv_timestamp_offset(&self) -> i32 {
        self.media_rcv_timestamp_offset.into()
    }
    #[inline]
    pub fn channel_rcv_timestamp_offset(&self) -> i32 {
        self.channel_rcv_timestamp_offset.into()
    }
    #[inline]
    pub fn channel_snd_timestamp_offset(&self) -> i32 {
        self.channel_snd_timestamp_offset.into()
    }
    #[inline]
    pub fn do_initial_parse(
        uri_length: usize,
        uri: &std::ffi::CStr,
        async_parse: &AeronUdpChannelAsyncParse,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_channel_do_initial_parse(
                uri_length.into(),
                uri.as_ptr(),
                async_parse.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn matches_tag(
        &self,
        local_address: &SockaddrStorage,
        remote_address: &SockaddrStorage,
    ) -> Result<bool, AeronCError> {
        unsafe {
            let mut mut_result: bool = Default::default();
            let err_code = aeron_udp_channel_matches_tag(
                self.get_inner(),
                self.get_inner(),
                local_address.get_inner(),
                remote_address.get_inner(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn delete(&self) -> () {
        unsafe {
            let result = aeron_udp_channel_delete(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_channel_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_channel_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_channel_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpChannel {
    type Target = aeron_udp_channel_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_channel_t> for AeronUdpChannel {
    #[inline]
    fn from(value: *mut aeron_udp_channel_t) -> Self {
        AeronUdpChannel {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpChannel> for *mut aeron_udp_channel_t {
    #[inline]
    fn from(value: AeronUdpChannel) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpChannel> for *mut aeron_udp_channel_t {
    #[inline]
    fn from(value: &AeronUdpChannel) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpChannel> for aeron_udp_channel_t {
    #[inline]
    fn from(value: AeronUdpChannel) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_channel_t> for AeronUdpChannel {
    #[inline]
    fn from(value: *const aeron_udp_channel_t) -> Self {
        AeronUdpChannel {
            inner: CResource::Borrowed(value as *mut aeron_udp_channel_t),
        }
    }
}
impl From<aeron_udp_channel_t> for AeronUdpChannel {
    #[inline]
    fn from(value: aeron_udp_channel_t) -> Self {
        AeronUdpChannel {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronUdpDestinationEntry {
    inner: CResource<aeron_udp_destination_entry_t>,
}
impl core::fmt::Debug for AeronUdpDestinationEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpDestinationEntry))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpDestinationEntry))
                .field("inner", &self.inner)
                .field(
                    stringify!(time_of_last_activity_ns),
                    &self.time_of_last_activity_ns(),
                )
                .field(
                    stringify!(destination_timeout_ns),
                    &self.destination_timeout_ns(),
                )
                .field(stringify!(receiver_id), &self.receiver_id())
                .field(stringify!(registration_id), &self.registration_id())
                .field(
                    stringify!(is_receiver_id_valid),
                    &self.is_receiver_id_valid(),
                )
                .field(stringify!(addr), &self.addr())
                .finish()
        }
    }
}
impl AeronUdpDestinationEntry {
    #[inline]
    pub fn new(
        padding_before: [u8; 64usize],
        time_of_last_activity_ns: i64,
        destination_timeout_ns: i64,
        receiver_id: i64,
        registration_id: i64,
        is_receiver_id_valid: bool,
        uri: &AeronUri,
        addr: SockaddrStorage,
        padding_after: [u8; 64usize],
    ) -> Result<Self, AeronCError> {
        let uri_copy = uri.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_udp_destination_entry_t {
                    padding_before: padding_before.into(),
                    time_of_last_activity_ns: time_of_last_activity_ns.into(),
                    destination_timeout_ns: destination_timeout_ns.into(),
                    receiver_id: receiver_id.into(),
                    registration_id: registration_id.into(),
                    is_receiver_id_valid: is_receiver_id_valid.into(),
                    uri: uri.into(),
                    addr: addr.into(),
                    padding_after: padding_after.into(),
                };
                let inner_ptr: *mut aeron_udp_destination_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_destination_entry_t)
                );
                let inst: aeron_udp_destination_entry_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_destination_entry_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_destination_entry_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding_before(&self) -> [u8; 64usize] {
        self.padding_before.into()
    }
    #[inline]
    pub fn time_of_last_activity_ns(&self) -> i64 {
        self.time_of_last_activity_ns.into()
    }
    #[inline]
    pub fn destination_timeout_ns(&self) -> i64 {
        self.destination_timeout_ns.into()
    }
    #[inline]
    pub fn receiver_id(&self) -> i64 {
        self.receiver_id.into()
    }
    #[inline]
    pub fn registration_id(&self) -> i64 {
        self.registration_id.into()
    }
    #[inline]
    pub fn is_receiver_id_valid(&self) -> bool {
        self.is_receiver_id_valid.into()
    }
    #[inline]
    pub fn uri(&self) -> AeronUri {
        self.uri.into()
    }
    #[inline]
    pub fn addr(&self) -> SockaddrStorage {
        self.addr.into()
    }
    #[inline]
    pub fn padding_after(&self) -> [u8; 64usize] {
        self.padding_after.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_destination_entry_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_destination_entry_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_destination_entry_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpDestinationEntry {
    type Target = aeron_udp_destination_entry_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_destination_entry_t> for AeronUdpDestinationEntry {
    #[inline]
    fn from(value: *mut aeron_udp_destination_entry_t) -> Self {
        AeronUdpDestinationEntry {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpDestinationEntry> for *mut aeron_udp_destination_entry_t {
    #[inline]
    fn from(value: AeronUdpDestinationEntry) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpDestinationEntry> for *mut aeron_udp_destination_entry_t {
    #[inline]
    fn from(value: &AeronUdpDestinationEntry) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpDestinationEntry> for aeron_udp_destination_entry_t {
    #[inline]
    fn from(value: AeronUdpDestinationEntry) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_destination_entry_t> for AeronUdpDestinationEntry {
    #[inline]
    fn from(value: *const aeron_udp_destination_entry_t) -> Self {
        AeronUdpDestinationEntry {
            inner: CResource::Borrowed(value as *mut aeron_udp_destination_entry_t),
        }
    }
}
impl From<aeron_udp_destination_entry_t> for AeronUdpDestinationEntry {
    #[inline]
    fn from(value: aeron_udp_destination_entry_t) -> Self {
        AeronUdpDestinationEntry {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUdpDestinationEntry {
    fn default() -> Self {
        AeronUdpDestinationEntry::new_zeroed_on_heap()
    }
}
impl AeronUdpDestinationEntry {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUdpDestinationTracker {
    inner: CResource<aeron_udp_destination_tracker_t>,
}
impl core::fmt::Debug for AeronUdpDestinationTracker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUdpDestinationTracker))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUdpDestinationTracker))
                .field("inner", &self.inner)
                .field(
                    stringify!(is_manual_control_mode),
                    &self.is_manual_control_mode(),
                )
                .field(
                    stringify!(destination_timeout_ns),
                    &self.destination_timeout_ns(),
                )
                .finish()
        }
    }
}
impl AeronUdpDestinationTracker {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_udp_destination_tracker_t)
                );
                let inst: aeron_udp_destination_tracker_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_udp_destination_tracker_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_udp_destination_tracker_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn padding_before(&self) -> [u8; 64usize] {
        self.padding_before.into()
    }
    #[inline]
    pub fn destinations(
        &self,
    ) -> aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct {
        self.destinations.into()
    }
    #[inline]
    pub fn is_manual_control_mode(&self) -> bool {
        self.is_manual_control_mode.into()
    }
    #[inline]
    pub fn cached_clock(&self) -> AeronClockCache {
        self.cached_clock.into()
    }
    #[inline]
    pub fn destination_timeout_ns(&self) -> i64 {
        self.destination_timeout_ns.into()
    }
    #[inline]
    pub fn data_paths(&self) -> AeronUdpChannelDataPaths {
        self.data_paths.into()
    }
    #[inline]
    pub fn num_destinations_addr(&self) -> &mut i64 {
        unsafe { &mut *self.num_destinations_addr }
    }
    #[inline]
    pub fn round_robin_index(&self) -> ::std::os::raw::c_int {
        self.round_robin_index.into()
    }
    #[inline]
    pub fn padding_after(&self) -> [u8; 64usize] {
        self.padding_after.into()
    }
    #[inline]
    pub fn init(
        &self,
        data_paths: &AeronUdpChannelDataPaths,
        cached_clock: &AeronClockCache,
        is_manual_control_model: bool,
        timeout_ns: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_destination_tracker_init(
                self.get_inner(),
                data_paths.get_inner(),
                cached_clock.get_inner(),
                is_manual_control_model.into(),
                timeout_ns.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_udp_destination_tracker_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn send(
        &self,
        transport: *mut aeron_udp_channel_transport_t,
        iov: &Iovec,
        iov_length: usize,
    ) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_udp_destination_tracker_send(
                self.get_inner(),
                transport.into(),
                iov.get_inner(),
                iov_length.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn on_status_message(
        &self,
        buffer: &[u8],
        addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_destination_tracker_on_status_message(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn manual_add_destination(
        &self,
        now_ns: i64,
        uri: &AeronUri,
        addr: &SockaddrStorage,
        destination_registration_id: i64,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_udp_destination_tracker_manual_add_destination(
                self.get_inner(),
                now_ns.into(),
                uri.get_inner(),
                addr.get_inner(),
                destination_registration_id.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn find_registration_id(&self, buffer: &[u8], addr: &SockaddrStorage) -> i64 {
        unsafe {
            let result = aeron_udp_destination_tracker_find_registration_id(
                self.get_inner(),
                buffer.as_ptr() as *mut _,
                buffer.len(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn check_for_re_resolution(
        &self,
        endpoint: &AeronSendChannelEndpoint,
        now_ns: i64,
        conductor_proxy: &AeronDriverConductorProxy,
    ) -> () {
        unsafe {
            let result = aeron_udp_destination_tracker_check_for_re_resolution(
                self.get_inner(),
                endpoint.get_inner(),
                now_ns.into(),
                conductor_proxy.get_inner(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn resolution_change(&self, endpoint_name: &std::ffi::CStr, addr: &SockaddrStorage) -> () {
        unsafe {
            let result = aeron_udp_destination_tracker_resolution_change(
                self.get_inner(),
                endpoint_name.as_ptr(),
                addr.get_inner(),
            );
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_udp_destination_tracker_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_udp_destination_tracker_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_udp_destination_tracker_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUdpDestinationTracker {
    type Target = aeron_udp_destination_tracker_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_udp_destination_tracker_t> for AeronUdpDestinationTracker {
    #[inline]
    fn from(value: *mut aeron_udp_destination_tracker_t) -> Self {
        AeronUdpDestinationTracker {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUdpDestinationTracker> for *mut aeron_udp_destination_tracker_t {
    #[inline]
    fn from(value: AeronUdpDestinationTracker) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUdpDestinationTracker> for *mut aeron_udp_destination_tracker_t {
    #[inline]
    fn from(value: &AeronUdpDestinationTracker) -> Self {
        value.get_inner()
    }
}
impl From<AeronUdpDestinationTracker> for aeron_udp_destination_tracker_t {
    #[inline]
    fn from(value: AeronUdpDestinationTracker) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_udp_destination_tracker_t> for AeronUdpDestinationTracker {
    #[inline]
    fn from(value: *const aeron_udp_destination_tracker_t) -> Self {
        AeronUdpDestinationTracker {
            inner: CResource::Borrowed(value as *mut aeron_udp_destination_tracker_t),
        }
    }
}
impl From<aeron_udp_destination_tracker_t> for AeronUdpDestinationTracker {
    #[inline]
    fn from(value: aeron_udp_destination_tracker_t) -> Self {
        AeronUdpDestinationTracker {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronUriParam {
    inner: CResource<aeron_uri_param_t>,
}
impl core::fmt::Debug for AeronUriParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUriParam))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUriParam))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUriParam {
    #[inline]
    pub fn new(key: &std::ffi::CStr, value: &std::ffi::CStr) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_uri_param_t {
                    key: key.as_ptr(),
                    value: value.as_ptr(),
                };
                let inner_ptr: *mut aeron_uri_param_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_uri_param_t)
                );
                let inst: aeron_uri_param_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_uri_param_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_uri_param_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn key(&self) -> &str {
        if self.key.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.key).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn value(&self) -> &str {
        if self.value.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.value).to_str().unwrap() }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_uri_param_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_uri_param_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_uri_param_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUriParam {
    type Target = aeron_uri_param_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_uri_param_t> for AeronUriParam {
    #[inline]
    fn from(value: *mut aeron_uri_param_t) -> Self {
        AeronUriParam {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUriParam> for *mut aeron_uri_param_t {
    #[inline]
    fn from(value: AeronUriParam) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUriParam> for *mut aeron_uri_param_t {
    #[inline]
    fn from(value: &AeronUriParam) -> Self {
        value.get_inner()
    }
}
impl From<AeronUriParam> for aeron_uri_param_t {
    #[inline]
    fn from(value: AeronUriParam) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_uri_param_t> for AeronUriParam {
    #[inline]
    fn from(value: *const aeron_uri_param_t) -> Self {
        AeronUriParam {
            inner: CResource::Borrowed(value as *mut aeron_uri_param_t),
        }
    }
}
impl From<aeron_uri_param_t> for AeronUriParam {
    #[inline]
    fn from(value: aeron_uri_param_t) -> Self {
        AeronUriParam {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUriParam {
    fn default() -> Self {
        AeronUriParam::new_zeroed_on_heap()
    }
}
impl AeronUriParam {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUriParams {
    inner: CResource<aeron_uri_params_t>,
}
impl core::fmt::Debug for AeronUriParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUriParams))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUriParams))
                .field("inner", &self.inner)
                .field(stringify!(length), &self.length())
                .finish()
        }
    }
}
impl AeronUriParams {
    #[inline]
    pub fn new(length: usize, array: &AeronUriParam) -> Result<Self, AeronCError> {
        let array_copy = array.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_uri_params_t {
                    length: length.into(),
                    array: array.into(),
                };
                let inner_ptr: *mut aeron_uri_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_uri_params_t)
                );
                let inst: aeron_uri_params_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_uri_params_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_uri_params_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn length(&self) -> usize {
        self.length.into()
    }
    #[inline]
    pub fn array(&self) -> AeronUriParam {
        self.array.into()
    }
    #[inline]
    #[doc = "SAFETY: this is static for performance reasons, so you should not store this without copying it!!"]
    pub fn aeron_uri_find_param_value(
        uri_params: *const aeron_uri_params_t,
        key: &std::ffi::CStr,
    ) -> &'static str {
        unsafe {
            let result = aeron_uri_find_param_value(uri_params.into(), key.as_ptr());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_int32(&self, key: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let mut mut_result: i32 = Default::default();
            let err_code = aeron_uri_get_int32(self.get_inner(), key.as_ptr(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_int64(
        &self,
        key: &std::ffi::CStr,
        default_val: i64,
    ) -> Result<i64, AeronCError> {
        unsafe {
            let mut mut_result: i64 = Default::default();
            let err_code = aeron_uri_get_int64(
                self.get_inner(),
                key.as_ptr(),
                default_val.into(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_bool(&self, key: &std::ffi::CStr) -> Result<bool, AeronCError> {
        unsafe {
            let mut mut_result: bool = Default::default();
            let err_code = aeron_uri_get_bool(self.get_inner(), key.as_ptr(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_ats(
        &self,
        uri_ats_status: *mut aeron_uri_ats_status_t,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_get_ats(self.get_inner(), uri_ats_status.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_timeout(&self, param_name: &std::ffi::CStr) -> Result<u64, AeronCError> {
        unsafe {
            let mut mut_result: u64 = Default::default();
            let err_code =
                aeron_uri_get_timeout(self.get_inner(), param_name.as_ptr(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_socket_buf_lengths(
        &self,
        socket_sndbuf_length: &mut usize,
        socket_rcvbuf_length: &mut usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_get_socket_buf_lengths(
                self.get_inner(),
                socket_sndbuf_length as *mut _,
                socket_rcvbuf_length as *mut _,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_uri_get_receiver_window_length(&self) -> Result<usize, AeronCError> {
        unsafe {
            let mut mut_result: usize = Default::default();
            let err_code = aeron_uri_get_receiver_window_length(self.get_inner(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_uri_params_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_uri_params_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_uri_params_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUriParams {
    type Target = aeron_uri_params_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_uri_params_t> for AeronUriParams {
    #[inline]
    fn from(value: *mut aeron_uri_params_t) -> Self {
        AeronUriParams {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUriParams> for *mut aeron_uri_params_t {
    #[inline]
    fn from(value: AeronUriParams) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUriParams> for *mut aeron_uri_params_t {
    #[inline]
    fn from(value: &AeronUriParams) -> Self {
        value.get_inner()
    }
}
impl From<AeronUriParams> for aeron_uri_params_t {
    #[inline]
    fn from(value: AeronUriParams) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_uri_params_t> for AeronUriParams {
    #[inline]
    fn from(value: *const aeron_uri_params_t) -> Self {
        AeronUriParams {
            inner: CResource::Borrowed(value as *mut aeron_uri_params_t),
        }
    }
}
impl From<aeron_uri_params_t> for AeronUriParams {
    #[inline]
    fn from(value: aeron_uri_params_t) -> Self {
        AeronUriParams {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUriParams {
    fn default() -> Self {
        AeronUriParams::new_zeroed_on_heap()
    }
}
impl AeronUriParams {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronUriStringBuilder {
    inner: CResource<aeron_uri_string_builder_t>,
}
impl core::fmt::Debug for AeronUriStringBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUriStringBuilder))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUriStringBuilder))
                .field("inner", &self.inner)
                .field(stringify!(params), &self.params())
                .field(stringify!(closed), &self.closed())
                .finish()
        }
    }
}
impl AeronUriStringBuilder {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_uri_string_builder_t)
                );
                let inst: aeron_uri_string_builder_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_uri_string_builder_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_uri_string_builder_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn params(&self) -> AeronStrToPtrHashMap {
        self.params.into()
    }
    #[inline]
    pub fn closed(&self) -> bool {
        self.closed.into()
    }
    #[inline]
    pub fn init_new(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_string_builder_init_new(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn init_on_string(&self, uri: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_string_builder_init_on_string(self.get_inner(), uri.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> Result<i32, AeronCError> {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_uri_string_builder_close(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn put(&self, key: &std::ffi::CStr, value: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_uri_string_builder_put(self.get_inner(), key.as_ptr(), value.as_ptr());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn put_int32(&self, key: &std::ffi::CStr, value: i32) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_uri_string_builder_put_int32(self.get_inner(), key.as_ptr(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn put_int64(&self, key: &std::ffi::CStr, value: i64) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_uri_string_builder_put_int64(self.get_inner(), key.as_ptr(), value.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn get(&self, key: &std::ffi::CStr) -> &str {
        unsafe {
            let result = aeron_uri_string_builder_get(self.get_inner(), key.as_ptr());
            if result.is_null() {
                ""
            } else {
                unsafe { std::ffi::CStr::from_ptr(result).to_str().unwrap() }
            }
        }
    }
    #[inline]
    pub fn sprint(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result =
                aeron_uri_string_builder_sprint(self.get_inner(), buffer.into(), buffer_len.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn sprint_as_string(&self, max_length: usize) -> Result<String, AeronCError> {
        let mut result = String::with_capacity(max_length);
        self.sprint_into(&mut result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "NOTE: allocation friendly method, the string capacity must be set as it will truncate string to capacity it will never grow the string. So if you pass String::new() it will write 0 chars"]
    pub fn sprint_into(&self, dst_truncate_to_capacity: &mut String) -> Result<i32, AeronCError> {
        unsafe {
            let capacity = dst_truncate_to_capacity.capacity();
            let vec = dst_truncate_to_capacity.as_mut_vec();
            vec.set_len(capacity);
            let result = self.sprint(vec.as_mut_ptr() as *mut _, capacity)?;
            let mut len = 0;
            loop {
                if len == capacity {
                    break;
                }
                let val = vec[len];
                if val == 0 {
                    break;
                }
                len += 1;
            }
            vec.set_len(len);
            Ok(result)
        }
    }
    #[inline]
    pub fn set_initial_position(
        &self,
        position: i64,
        initial_term_id: i32,
        term_length: i32,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_string_builder_set_initial_position(
                self.get_inner(),
                position.into(),
                initial_term_id.into(),
                term_length.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_uri_string_builder_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_uri_string_builder_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_uri_string_builder_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUriStringBuilder {
    type Target = aeron_uri_string_builder_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_uri_string_builder_t> for AeronUriStringBuilder {
    #[inline]
    fn from(value: *mut aeron_uri_string_builder_t) -> Self {
        AeronUriStringBuilder {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUriStringBuilder> for *mut aeron_uri_string_builder_t {
    #[inline]
    fn from(value: AeronUriStringBuilder) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUriStringBuilder> for *mut aeron_uri_string_builder_t {
    #[inline]
    fn from(value: &AeronUriStringBuilder) -> Self {
        value.get_inner()
    }
}
impl From<AeronUriStringBuilder> for aeron_uri_string_builder_t {
    #[inline]
    fn from(value: AeronUriStringBuilder) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_uri_string_builder_t> for AeronUriStringBuilder {
    #[inline]
    fn from(value: *const aeron_uri_string_builder_t) -> Self {
        AeronUriStringBuilder {
            inner: CResource::Borrowed(value as *mut aeron_uri_string_builder_t),
        }
    }
}
impl From<aeron_uri_string_builder_t> for AeronUriStringBuilder {
    #[inline]
    fn from(value: aeron_uri_string_builder_t) -> Self {
        AeronUriStringBuilder {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct AeronUri {
    inner: CResource<aeron_uri_t>,
}
impl core::fmt::Debug for AeronUri {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronUri))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronUri))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl AeronUri {
    #[inline]
    pub fn new(
        mutable_uri: [::std::os::raw::c_char; 4096usize],
        type_: aeron_uri_type_t,
        params: aeron_uri_stct__bindgen_ty_1,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_uri_t {
                    mutable_uri: mutable_uri.into(),
                    type_: type_.into(),
                    params: params.into(),
                };
                let inner_ptr: *mut aeron_uri_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_uri_t)
                );
                let inst: aeron_uri_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_uri_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_uri_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn mutable_uri(&self) -> [::std::os::raw::c_char; 4096usize] {
        self.mutable_uri.into()
    }
    #[inline]
    pub fn type_(&self) -> aeron_uri_type_t {
        self.type_.into()
    }
    #[inline]
    pub fn params(&self) -> aeron_uri_stct__bindgen_ty_1 {
        self.params.into()
    }
    #[inline]
    pub fn parse_params<AeronUriParseCallbackHandlerImpl: AeronUriParseCallbackCallback>(
        uri: *mut ::std::os::raw::c_char,
        param_func: Option<&Handler<AeronUriParseCallbackHandlerImpl>>,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_parse_params(
                uri.into(),
                {
                    let callback: aeron_uri_parse_callback_t = if param_func.is_none() {
                        None
                    } else {
                        Some(
                            aeron_uri_parse_callback_t_callback::<AeronUriParseCallbackHandlerImpl>,
                        )
                    };
                    callback
                },
                param_func
                    .map(|m| m.as_raw())
                    .unwrap_or_else(|| std::ptr::null_mut()),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    #[doc = r""]
    #[doc = r""]
    #[doc = r" _NOTE: aeron must not store this closure and instead use it immediately. If not you will get undefined behaviour,"]
    #[doc = r"  use with care_"]
    pub fn parse_params_once<
        AeronUriParseCallbackHandlerImpl: FnMut(&str, &str) -> ::std::os::raw::c_int,
    >(
        uri: *mut ::std::os::raw::c_char,
        mut param_func: AeronUriParseCallbackHandlerImpl,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_parse_params(
                uri.into(),
                Some(
                    aeron_uri_parse_callback_t_callback_for_once_closure::<
                        AeronUriParseCallbackHandlerImpl,
                    >,
                ),
                &mut param_func as *mut _ as *mut std::os::raw::c_void,
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn parse(&self, uri_length: usize, uri: &std::ffi::CStr) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_parse(uri_length.into(), uri.as_ptr(), self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn close(&self) -> () {
        if let Some(inner) = self.inner.as_owned() {
            inner.close_already_called.set(true);
        }
        unsafe {
            let result = aeron_uri_close(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn multicast_ttl(&self) -> u8 {
        unsafe {
            let result = aeron_uri_multicast_ttl(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn sprint(
        &self,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_uri_sprint(self.get_inner(), buffer.into(), buffer_len.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn sprint_as_string(&self, max_length: usize) -> Result<String, AeronCError> {
        let mut result = String::with_capacity(max_length);
        self.sprint_into(&mut result)?;
        Ok(result)
    }
    #[inline]
    #[doc = "NOTE: allocation friendly method, the string capacity must be set as it will truncate string to capacity it will never grow the string. So if you pass String::new() it will write 0 chars"]
    pub fn sprint_into(&self, dst_truncate_to_capacity: &mut String) -> Result<i32, AeronCError> {
        unsafe {
            let capacity = dst_truncate_to_capacity.capacity();
            let vec = dst_truncate_to_capacity.as_mut_vec();
            vec.set_len(capacity);
            let result = self.sprint(vec.as_mut_ptr() as *mut _, capacity)?;
            let mut len = 0;
            loop {
                if len == capacity {
                    break;
                }
                let val = vec[len];
                if val == 0 {
                    break;
                }
                len += 1;
            }
            vec.set_len(len);
            Ok(result)
        }
    }
    #[inline]
    pub fn parse_tag(tag_str: &std::ffi::CStr) -> i64 {
        unsafe {
            let result = aeron_uri_parse_tag(tag_str.as_ptr());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_diver_uri_publication_params(
        &self,
        params: &AeronDriverUriPublicationParams,
        conductor: &AeronDriverConductor,
        is_exclusive: bool,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_diver_uri_publication_params(
                self.get_inner(),
                params.get_inner(),
                conductor.get_inner(),
                is_exclusive.into(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_driver_uri_subscription_params(
        &self,
        params: &AeronDriverUriSubscriptionParams,
        conductor: &AeronDriverConductor,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_driver_uri_subscription_params(
                self.get_inner(),
                params.get_inner(),
                conductor.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn aeron_driver_uri_get_timestamp_offset(
        &self,
        key: &std::ffi::CStr,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let mut mut_result: i32 = Default::default();
            let err_code = aeron_driver_uri_get_timestamp_offset(
                self.get_inner(),
                key.as_ptr(),
                &mut mut_result,
            );
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_uri_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_uri_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_uri_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronUri {
    type Target = aeron_uri_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_uri_t> for AeronUri {
    #[inline]
    fn from(value: *mut aeron_uri_t) -> Self {
        AeronUri {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronUri> for *mut aeron_uri_t {
    #[inline]
    fn from(value: AeronUri) -> Self {
        value.get_inner()
    }
}
impl From<&AeronUri> for *mut aeron_uri_t {
    #[inline]
    fn from(value: &AeronUri) -> Self {
        value.get_inner()
    }
}
impl From<AeronUri> for aeron_uri_t {
    #[inline]
    fn from(value: AeronUri) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_uri_t> for AeronUri {
    #[inline]
    fn from(value: *const aeron_uri_t) -> Self {
        AeronUri {
            inner: CResource::Borrowed(value as *mut aeron_uri_t),
        }
    }
}
impl From<aeron_uri_t> for AeronUri {
    #[inline]
    fn from(value: aeron_uri_t) -> Self {
        AeronUri {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
impl Drop for AeronUri {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.as_owned() {
            if (inner.cleanup.is_none())
                && std::rc::Rc::strong_count(inner) == 1
                && !inner.is_closed_already_called()
            {
                if inner.auto_close.get() {
                    log::info!("auto closing {}", stringify!(AeronUri));
                    let result = self.close();
                    log::debug!("result {:?}", result);
                } else {
                    #[cfg(feature = "extra-logging")]
                    log::warn!("{} not closed", stringify!(AeronUri));
                }
            }
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronUri {
    fn default() -> Self {
        AeronUri::new_zeroed_on_heap()
    }
}
impl AeronUri {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct AeronWildcardPortManager {
    inner: CResource<aeron_wildcard_port_manager_t>,
}
impl core::fmt::Debug for AeronWildcardPortManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(AeronWildcardPortManager))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(AeronWildcardPortManager))
                .field("inner", &self.inner)
                .field(stringify!(port_manager), &self.port_manager())
                .field(stringify!(port_table), &self.port_table())
                .field(stringify!(low_port), &self.low_port())
                .field(stringify!(high_port), &self.high_port())
                .field(stringify!(next_port), &self.next_port())
                .field(stringify!(is_sender), &self.is_sender())
                .field(stringify!(is_os_wildcard), &self.is_os_wildcard())
                .finish()
        }
    }
}
impl AeronWildcardPortManager {
    #[inline]
    pub fn new(
        port_manager: AeronPortManager,
        port_table: AeronInt64CounterMap,
        low_port: u16,
        high_port: u16,
        next_port: u16,
        is_sender: bool,
        is_os_wildcard: bool,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = aeron_wildcard_port_manager_t {
                    port_manager: port_manager.into(),
                    port_table: port_table.into(),
                    low_port: low_port.into(),
                    high_port: high_port.into(),
                    next_port: next_port.into(),
                    is_sender: is_sender.into(),
                    is_os_wildcard: is_os_wildcard.into(),
                };
                let inner_ptr: *mut aeron_wildcard_port_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(aeron_wildcard_port_manager_t)
                );
                let inst: aeron_wildcard_port_manager_t = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut aeron_wildcard_port_manager_t = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(aeron_wildcard_port_manager_t)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn port_manager(&self) -> AeronPortManager {
        self.port_manager.into()
    }
    #[inline]
    pub fn port_table(&self) -> AeronInt64CounterMap {
        self.port_table.into()
    }
    #[inline]
    pub fn low_port(&self) -> u16 {
        self.low_port.into()
    }
    #[inline]
    pub fn high_port(&self) -> u16 {
        self.high_port.into()
    }
    #[inline]
    pub fn next_port(&self) -> u16 {
        self.next_port.into()
    }
    #[inline]
    pub fn is_sender(&self) -> bool {
        self.is_sender.into()
    }
    #[inline]
    pub fn is_os_wildcard(&self) -> bool {
        self.is_os_wildcard.into()
    }
    #[inline]
    pub fn get_managed_port(
        state: *mut ::std::os::raw::c_void,
        bind_addr_out: &SockaddrStorage,
        udp_channel: &AeronUdpChannel,
        bind_addr: &SockaddrStorage,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_wildcard_port_manager_get_managed_port(
                state.into(),
                bind_addr_out.get_inner(),
                udp_channel.get_inner(),
                bind_addr.get_inner(),
            );
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn free_managed_port(
        state: *mut ::std::os::raw::c_void,
        bind_addr: &SockaddrStorage,
    ) -> () {
        unsafe {
            let result =
                aeron_wildcard_port_manager_free_managed_port(state.into(), bind_addr.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn init(&self, is_sender: bool) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_wildcard_port_manager_init(self.get_inner(), is_sender.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline]
    pub fn set_range(&self, low_port: u16, high_port: u16) -> () {
        unsafe {
            let result = aeron_wildcard_port_manager_set_range(
                self.get_inner(),
                low_port.into(),
                high_port.into(),
            );
            result.into()
        }
    }
    #[inline]
    pub fn delete(&self) -> () {
        unsafe {
            let result = aeron_wildcard_port_manager_delete(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut aeron_wildcard_port_manager_t {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut aeron_wildcard_port_manager_t {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &aeron_wildcard_port_manager_t {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for AeronWildcardPortManager {
    type Target = aeron_wildcard_port_manager_t;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut aeron_wildcard_port_manager_t> for AeronWildcardPortManager {
    #[inline]
    fn from(value: *mut aeron_wildcard_port_manager_t) -> Self {
        AeronWildcardPortManager {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<AeronWildcardPortManager> for *mut aeron_wildcard_port_manager_t {
    #[inline]
    fn from(value: AeronWildcardPortManager) -> Self {
        value.get_inner()
    }
}
impl From<&AeronWildcardPortManager> for *mut aeron_wildcard_port_manager_t {
    #[inline]
    fn from(value: &AeronWildcardPortManager) -> Self {
        value.get_inner()
    }
}
impl From<AeronWildcardPortManager> for aeron_wildcard_port_manager_t {
    #[inline]
    fn from(value: AeronWildcardPortManager) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const aeron_wildcard_port_manager_t> for AeronWildcardPortManager {
    #[inline]
    fn from(value: *const aeron_wildcard_port_manager_t) -> Self {
        AeronWildcardPortManager {
            inner: CResource::Borrowed(value as *mut aeron_wildcard_port_manager_t),
        }
    }
}
impl From<aeron_wildcard_port_manager_t> for AeronWildcardPortManager {
    #[inline]
    fn from(value: aeron_wildcard_port_manager_t) -> Self {
        AeronWildcardPortManager {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for AeronWildcardPortManager {
    fn default() -> Self {
        AeronWildcardPortManager::new_zeroed_on_heap()
    }
}
impl AeronWildcardPortManager {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct Ifaddrs {
    inner: CResource<ifaddrs>,
}
impl core::fmt::Debug for Ifaddrs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Ifaddrs))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Ifaddrs))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Ifaddrs {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(ifaddrs)
                );
                let inst: ifaddrs = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut ifaddrs = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(ifaddrs)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn ifa_next(&self) -> Ifaddrs {
        self.ifa_next.into()
    }
    #[inline]
    pub fn ifa_name(&self) -> &str {
        if self.ifa_name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(self.ifa_name).to_str().unwrap() }
        }
    }
    #[inline]
    pub fn ifa_flags(&self) -> ::std::os::raw::c_uint {
        self.ifa_flags.into()
    }
    #[inline]
    pub fn ifa_addr(&self) -> Sockaddr {
        self.ifa_addr.into()
    }
    #[inline]
    pub fn ifa_netmask(&self) -> Sockaddr {
        self.ifa_netmask.into()
    }
    #[inline]
    pub fn ifa_dstaddr(&self) -> Sockaddr {
        self.ifa_dstaddr.into()
    }
    #[inline]
    pub fn ifa_data(&self) -> *mut ::std::os::raw::c_void {
        self.ifa_data.into()
    }
    #[inline]
    pub fn aeron_frees(&self) -> () {
        unsafe {
            let result = aeron_freeifaddrs(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut ifaddrs {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut ifaddrs {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &ifaddrs {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Ifaddrs {
    type Target = ifaddrs;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut ifaddrs> for Ifaddrs {
    #[inline]
    fn from(value: *mut ifaddrs) -> Self {
        Ifaddrs {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Ifaddrs> for *mut ifaddrs {
    #[inline]
    fn from(value: Ifaddrs) -> Self {
        value.get_inner()
    }
}
impl From<&Ifaddrs> for *mut ifaddrs {
    #[inline]
    fn from(value: &Ifaddrs) -> Self {
        value.get_inner()
    }
}
impl From<Ifaddrs> for ifaddrs {
    #[inline]
    fn from(value: Ifaddrs) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const ifaddrs> for Ifaddrs {
    #[inline]
    fn from(value: *const ifaddrs) -> Self {
        Ifaddrs {
            inner: CResource::Borrowed(value as *mut ifaddrs),
        }
    }
}
impl From<ifaddrs> for Ifaddrs {
    #[inline]
    fn from(value: ifaddrs) -> Self {
        Ifaddrs {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct In6Addr {
    inner: CResource<in6_addr>,
}
impl core::fmt::Debug for In6Addr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(In6Addr))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(In6Addr))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl In6Addr {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(in6_addr)
                );
                let inst: in6_addr = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut in6_addr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(in6_addr)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn aeron_ipv6_does_prefix_match(&self, prefixlen: usize) -> bool {
        unsafe {
            let result =
                aeron_ipv6_does_prefix_match(self.get_inner(), self.get_inner(), prefixlen.into());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_ipv6_netmask_to_prefixlen(&self) -> usize {
        unsafe {
            let result = aeron_ipv6_netmask_to_prefixlen(self.get_inner());
            result.into()
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut in6_addr {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut in6_addr {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &in6_addr {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for In6Addr {
    type Target = in6_addr;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut in6_addr> for In6Addr {
    #[inline]
    fn from(value: *mut in6_addr) -> Self {
        In6Addr {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<In6Addr> for *mut in6_addr {
    #[inline]
    fn from(value: In6Addr) -> Self {
        value.get_inner()
    }
}
impl From<&In6Addr> for *mut in6_addr {
    #[inline]
    fn from(value: &In6Addr) -> Self {
        value.get_inner()
    }
}
impl From<In6Addr> for in6_addr {
    #[inline]
    fn from(value: In6Addr) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const in6_addr> for In6Addr {
    #[inline]
    fn from(value: *const in6_addr) -> Self {
        In6Addr {
            inner: CResource::Borrowed(value as *mut in6_addr),
        }
    }
}
impl From<in6_addr> for In6Addr {
    #[inline]
    fn from(value: in6_addr) -> Self {
        In6Addr {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct Iovec {
    inner: CResource<iovec>,
}
impl core::fmt::Debug for Iovec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Iovec))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Iovec))
                .field("inner", &self.inner)
                .field(stringify!(iov_len), &self.iov_len())
                .finish()
        }
    }
}
impl Iovec {
    #[inline]
    pub fn new(iov_base: *mut ::std::os::raw::c_void, iov_len: usize) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = iovec {
                    iov_base: iov_base.into(),
                    iov_len: iov_len.into(),
                };
                let inner_ptr: *mut iovec = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(iovec)
                );
                let inst: iovec = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut iovec = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(iovec)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn iov_base(&self) -> *mut ::std::os::raw::c_void {
        self.iov_base.into()
    }
    #[inline]
    pub fn iov_len(&self) -> usize {
        self.iov_len.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut iovec {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut iovec {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &iovec {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Iovec {
    type Target = iovec;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut iovec> for Iovec {
    #[inline]
    fn from(value: *mut iovec) -> Self {
        Iovec {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Iovec> for *mut iovec {
    #[inline]
    fn from(value: Iovec) -> Self {
        value.get_inner()
    }
}
impl From<&Iovec> for *mut iovec {
    #[inline]
    fn from(value: &Iovec) -> Self {
        value.get_inner()
    }
}
impl From<Iovec> for iovec {
    #[inline]
    fn from(value: Iovec) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const iovec> for Iovec {
    #[inline]
    fn from(value: *const iovec) -> Self {
        Iovec {
            inner: CResource::Borrowed(value as *mut iovec),
        }
    }
}
impl From<iovec> for Iovec {
    #[inline]
    fn from(value: iovec) -> Self {
        Iovec {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Iovec {
    fn default() -> Self {
        Iovec::new_zeroed_on_heap()
    }
}
impl Iovec {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct Mmsghdr {
    inner: CResource<mmsghdr>,
}
impl core::fmt::Debug for Mmsghdr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Mmsghdr))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Mmsghdr))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Mmsghdr {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(mmsghdr)
                );
                let inst: mmsghdr = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut mmsghdr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(mmsghdr)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut mmsghdr {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut mmsghdr {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &mmsghdr {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Mmsghdr {
    type Target = mmsghdr;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut mmsghdr> for Mmsghdr {
    #[inline]
    fn from(value: *mut mmsghdr) -> Self {
        Mmsghdr {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Mmsghdr> for *mut mmsghdr {
    #[inline]
    fn from(value: Mmsghdr) -> Self {
        value.get_inner()
    }
}
impl From<&Mmsghdr> for *mut mmsghdr {
    #[inline]
    fn from(value: &Mmsghdr) -> Self {
        value.get_inner()
    }
}
impl From<Mmsghdr> for mmsghdr {
    #[inline]
    fn from(value: Mmsghdr) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const mmsghdr> for Mmsghdr {
    #[inline]
    fn from(value: *const mmsghdr) -> Self {
        Mmsghdr {
            inner: CResource::Borrowed(value as *mut mmsghdr),
        }
    }
}
impl From<mmsghdr> for Mmsghdr {
    #[inline]
    fn from(value: mmsghdr) -> Self {
        Mmsghdr {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct Msghdr {
    inner: CResource<msghdr>,
}
impl core::fmt::Debug for Msghdr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Msghdr))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Msghdr))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Msghdr {
    #[inline]
    pub fn new(
        msg_name: *mut ::std::os::raw::c_void,
        msg_namelen: socklen_t,
        msg_iov: &Iovec,
        msg_iovlen: ::std::os::raw::c_int,
        msg_control: *mut ::std::os::raw::c_void,
        msg_controllen: socklen_t,
        msg_flags: ::std::os::raw::c_int,
    ) -> Result<Self, AeronCError> {
        let msg_iov_copy = msg_iov.clone();
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = msghdr {
                    msg_name: msg_name.into(),
                    msg_namelen: msg_namelen.into(),
                    msg_iov: msg_iov.into(),
                    msg_iovlen: msg_iovlen.into(),
                    msg_control: msg_control.into(),
                    msg_controllen: msg_controllen.into(),
                    msg_flags: msg_flags.into(),
                };
                let inner_ptr: *mut msghdr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(msghdr)
                );
                let inst: msghdr = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut msghdr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(msghdr)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn msg_name(&self) -> *mut ::std::os::raw::c_void {
        self.msg_name.into()
    }
    #[inline]
    pub fn msg_namelen(&self) -> socklen_t {
        self.msg_namelen.into()
    }
    #[inline]
    pub fn msg_iov(&self) -> Iovec {
        self.msg_iov.into()
    }
    #[inline]
    pub fn msg_iovlen(&self) -> ::std::os::raw::c_int {
        self.msg_iovlen.into()
    }
    #[inline]
    pub fn msg_control(&self) -> *mut ::std::os::raw::c_void {
        self.msg_control.into()
    }
    #[inline]
    pub fn msg_controllen(&self) -> socklen_t {
        self.msg_controllen.into()
    }
    #[inline]
    pub fn msg_flags(&self) -> ::std::os::raw::c_int {
        self.msg_flags.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut msghdr {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut msghdr {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &msghdr {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Msghdr {
    type Target = msghdr;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut msghdr> for Msghdr {
    #[inline]
    fn from(value: *mut msghdr) -> Self {
        Msghdr {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Msghdr> for *mut msghdr {
    #[inline]
    fn from(value: Msghdr) -> Self {
        value.get_inner()
    }
}
impl From<&Msghdr> for *mut msghdr {
    #[inline]
    fn from(value: &Msghdr) -> Self {
        value.get_inner()
    }
}
impl From<Msghdr> for msghdr {
    #[inline]
    fn from(value: Msghdr) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const msghdr> for Msghdr {
    #[inline]
    fn from(value: *const msghdr) -> Self {
        Msghdr {
            inner: CResource::Borrowed(value as *mut msghdr),
        }
    }
}
impl From<msghdr> for Msghdr {
    #[inline]
    fn from(value: msghdr) -> Self {
        Msghdr {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Msghdr {
    fn default() -> Self {
        Msghdr::new_zeroed_on_heap()
    }
}
impl Msghdr {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct Pollfd {
    inner: CResource<pollfd>,
}
impl core::fmt::Debug for Pollfd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Pollfd))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Pollfd))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Pollfd {
    #[inline]
    pub fn new(
        fd: ::std::os::raw::c_int,
        events: ::std::os::raw::c_short,
        revents: ::std::os::raw::c_short,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = pollfd {
                    fd: fd.into(),
                    events: events.into(),
                    revents: revents.into(),
                };
                let inner_ptr: *mut pollfd = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(pollfd)
                );
                let inst: pollfd = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut pollfd = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(pollfd)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn fd(&self) -> ::std::os::raw::c_int {
        self.fd.into()
    }
    #[inline]
    pub fn events(&self) -> ::std::os::raw::c_short {
        self.events.into()
    }
    #[inline]
    pub fn revents(&self) -> ::std::os::raw::c_short {
        self.revents.into()
    }
    #[inline]
    pub fn aeron_poll(
        &self,
        nfds: ::std::os::raw::c_ulong,
        timeout: ::std::os::raw::c_int,
    ) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_poll(self.get_inner(), nfds.into(), timeout.into());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut pollfd {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut pollfd {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &pollfd {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Pollfd {
    type Target = pollfd;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut pollfd> for Pollfd {
    #[inline]
    fn from(value: *mut pollfd) -> Self {
        Pollfd {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Pollfd> for *mut pollfd {
    #[inline]
    fn from(value: Pollfd) -> Self {
        value.get_inner()
    }
}
impl From<&Pollfd> for *mut pollfd {
    #[inline]
    fn from(value: &Pollfd) -> Self {
        value.get_inner()
    }
}
impl From<Pollfd> for pollfd {
    #[inline]
    fn from(value: Pollfd) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const pollfd> for Pollfd {
    #[inline]
    fn from(value: *const pollfd) -> Self {
        Pollfd {
            inner: CResource::Borrowed(value as *mut pollfd),
        }
    }
}
impl From<pollfd> for Pollfd {
    #[inline]
    fn from(value: pollfd) -> Self {
        Pollfd {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Pollfd {
    fn default() -> Self {
        Pollfd::new_zeroed_on_heap()
    }
}
impl Pollfd {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct Sockaddr {
    inner: CResource<sockaddr>,
}
impl core::fmt::Debug for Sockaddr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Sockaddr))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Sockaddr))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Sockaddr {
    #[inline]
    pub fn new(
        sa_len: __uint8_t,
        sa_family: sa_family_t,
        sa_data: [::std::os::raw::c_char; 14usize],
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = sockaddr {
                    sa_len: sa_len.into(),
                    sa_family: sa_family.into(),
                    sa_data: sa_data.into(),
                };
                let inner_ptr: *mut sockaddr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(sockaddr)
                );
                let inst: sockaddr = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut sockaddr = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(sockaddr)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn sa_len(&self) -> __uint8_t {
        self.sa_len.into()
    }
    #[inline]
    pub fn sa_family(&self) -> sa_family_t {
        self.sa_family.into()
    }
    #[inline]
    pub fn sa_data(&self) -> [::std::os::raw::c_char; 14usize] {
        self.sa_data.into()
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut sockaddr {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut sockaddr {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &sockaddr {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Sockaddr {
    type Target = sockaddr;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut sockaddr> for Sockaddr {
    #[inline]
    fn from(value: *mut sockaddr) -> Self {
        Sockaddr {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Sockaddr> for *mut sockaddr {
    #[inline]
    fn from(value: Sockaddr) -> Self {
        value.get_inner()
    }
}
impl From<&Sockaddr> for *mut sockaddr {
    #[inline]
    fn from(value: &Sockaddr) -> Self {
        value.get_inner()
    }
}
impl From<Sockaddr> for sockaddr {
    #[inline]
    fn from(value: Sockaddr) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const sockaddr> for Sockaddr {
    #[inline]
    fn from(value: *const sockaddr) -> Self {
        Sockaddr {
            inner: CResource::Borrowed(value as *mut sockaddr),
        }
    }
}
impl From<sockaddr> for Sockaddr {
    #[inline]
    fn from(value: sockaddr) -> Self {
        Sockaddr {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Sockaddr {
    fn default() -> Self {
        Sockaddr::new_zeroed_on_heap()
    }
}
impl Sockaddr {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[derive(Clone)]
pub struct SockaddrStorage {
    inner: CResource<sockaddr_storage>,
}
impl core::fmt::Debug for SockaddrStorage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(SockaddrStorage))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(SockaddrStorage))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl SockaddrStorage {
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(sockaddr_storage)
                );
                let inst: sockaddr_storage = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut sockaddr_storage = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(sockaddr_storage)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn ss_len(&self) -> __uint8_t {
        self.ss_len.into()
    }
    #[inline]
    pub fn ss_family(&self) -> sa_family_t {
        self.ss_family.into()
    }
    #[inline]
    pub fn aeron_set_ipv4_wildcard_host_and_port(&self) -> () {
        unsafe {
            let result = aeron_set_ipv4_wildcard_host_and_port(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_set_ipv6_wildcard_host_and_port(&self) -> () {
        unsafe {
            let result = aeron_set_ipv6_wildcard_host_and_port(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_is_addr_multicast(&self) -> bool {
        unsafe {
            let result = aeron_is_addr_multicast(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_is_wildcard_addr(&self) -> bool {
        unsafe {
            let result = aeron_is_wildcard_addr(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_is_wildcard_port(&self) -> bool {
        unsafe {
            let result = aeron_is_wildcard_port(self.get_inner());
            result.into()
        }
    }
    #[inline]
    pub fn aeron_e_cmp(&self) -> Result<bool, AeronCError> {
        unsafe {
            let mut mut_result: bool = Default::default();
            let err_code =
                aeron_sockaddr_storage_cmp(self.get_inner(), self.get_inner(), &mut mut_result);
            if err_code < 0 {
                return Err(AeronCError::from_code(err_code));
            } else {
                return Ok(mut_result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut sockaddr_storage {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut sockaddr_storage {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &sockaddr_storage {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for SockaddrStorage {
    type Target = sockaddr_storage;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut sockaddr_storage> for SockaddrStorage {
    #[inline]
    fn from(value: *mut sockaddr_storage) -> Self {
        SockaddrStorage {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<SockaddrStorage> for *mut sockaddr_storage {
    #[inline]
    fn from(value: SockaddrStorage) -> Self {
        value.get_inner()
    }
}
impl From<&SockaddrStorage> for *mut sockaddr_storage {
    #[inline]
    fn from(value: &SockaddrStorage) -> Self {
        value.get_inner()
    }
}
impl From<SockaddrStorage> for sockaddr_storage {
    #[inline]
    fn from(value: SockaddrStorage) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const sockaddr_storage> for SockaddrStorage {
    #[inline]
    fn from(value: *const sockaddr_storage) -> Self {
        SockaddrStorage {
            inner: CResource::Borrowed(value as *mut sockaddr_storage),
        }
    }
}
impl From<sockaddr_storage> for SockaddrStorage {
    #[inline]
    fn from(value: sockaddr_storage) -> Self {
        SockaddrStorage {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[derive(Clone)]
pub struct Timespec {
    inner: CResource<timespec>,
}
impl core::fmt::Debug for Timespec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner.get().is_null() {
            f.debug_struct(stringify!(Timespec))
                .field("inner", &"null")
                .finish()
        } else {
            f.debug_struct(stringify!(Timespec))
                .field("inner", &self.inner)
                .finish()
        }
    }
}
impl Timespec {
    #[inline]
    pub fn new(
        tv_sec: __darwin_time_t,
        tv_nsec: ::std::os::raw::c_long,
    ) -> Result<Self, AeronCError> {
        let r_constructor = ManagedCResource::new(
            move |ctx_field| {
                let inst = timespec {
                    tv_sec: tv_sec.into(),
                    tv_nsec: tv_nsec.into(),
                };
                let inner_ptr: *mut timespec = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )?;
        Ok(Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(r_constructor)),
        })
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the heap"]
    pub fn new_zeroed_on_heap() -> Self {
        let resource = ManagedCResource::new(
            move |ctx_field| {
                #[cfg(feature = "extra-logging")]
                log::info!(
                    "creating zeroed empty resource on heap {}",
                    stringify!(timespec)
                );
                let inst: timespec = unsafe { std::mem::zeroed() };
                let inner_ptr: *mut timespec = Box::into_raw(Box::new(inst));
                unsafe { *ctx_field = inner_ptr };
                0
            },
            None,
            true,
            None,
        )
        .unwrap();
        Self {
            inner: CResource::OwnedOnHeap(std::rc::Rc::new(resource)),
        }
    }
    #[inline]
    #[doc = r" creates zeroed struct where the underlying c struct is on the stack"]
    #[doc = r" _(Use with care)_"]
    pub fn new_zeroed_on_stack() -> Self {
        #[cfg(feature = "extra-logging")]
        log::debug!(
            "creating zeroed empty resource on stack {}",
            stringify!(timespec)
        );
        Self {
            inner: CResource::OwnedOnStack(std::mem::MaybeUninit::zeroed()),
        }
    }
    #[inline]
    pub fn tv_sec(&self) -> __darwin_time_t {
        self.tv_sec.into()
    }
    #[inline]
    pub fn tv_nsec(&self) -> ::std::os::raw::c_long {
        self.tv_nsec.into()
    }
    #[inline]
    #[doc = "Get the realtime from the system in `Timespec` format"]
    #[doc = ""]
    #[doc = " \n# Return\n 0 on success, -1 on failure."]
    pub fn aeron_clock_gettime_realtime(&self) -> Result<i32, AeronCError> {
        unsafe {
            let result = aeron_clock_gettime_realtime(self.get_inner());
            if result < 0 {
                return Err(AeronCError::from_code(result));
            } else {
                return Ok(result);
            }
        }
    }
    #[inline(always)]
    pub fn get_inner(&self) -> *mut timespec {
        self.inner.get()
    }
    #[inline(always)]
    pub fn get_inner_mut(&self) -> &mut timespec {
        unsafe { &mut *self.inner.get() }
    }
    #[inline(always)]
    pub fn get_inner_ref(&self) -> &timespec {
        unsafe { &*self.inner.get() }
    }
}
impl std::ops::Deref for Timespec {
    type Target = timespec;
    fn deref(&self) -> &Self::Target {
        self.get_inner_ref()
    }
}
impl From<*mut timespec> for Timespec {
    #[inline]
    fn from(value: *mut timespec) -> Self {
        Timespec {
            inner: CResource::Borrowed(value),
        }
    }
}
impl From<Timespec> for *mut timespec {
    #[inline]
    fn from(value: Timespec) -> Self {
        value.get_inner()
    }
}
impl From<&Timespec> for *mut timespec {
    #[inline]
    fn from(value: &Timespec) -> Self {
        value.get_inner()
    }
}
impl From<Timespec> for timespec {
    #[inline]
    fn from(value: Timespec) -> Self {
        unsafe { *value.get_inner().clone() }
    }
}
impl From<*const timespec> for Timespec {
    #[inline]
    fn from(value: *const timespec) -> Self {
        Timespec {
            inner: CResource::Borrowed(value as *mut timespec),
        }
    }
}
impl From<timespec> for Timespec {
    #[inline]
    fn from(value: timespec) -> Self {
        Timespec {
            inner: CResource::OwnedOnStack(MaybeUninit::new(value)),
        }
    }
}
#[doc = r" This will create an instance where the struct is zeroed, use with care"]
impl Default for Timespec {
    fn default() -> Self {
        Timespec::new_zeroed_on_heap()
    }
}
impl Timespec {
    #[doc = r" Regular clone just increases the reference count of underlying count."]
    #[doc = r" `clone_struct` shallow copies the content of the underlying struct on heap."]
    #[doc = r""]
    #[doc = r" NOTE: if the struct has references to other structs these will not be copied"]
    #[doc = r""]
    #[doc = r" Must be only used on structs which has no init/clean up methods."]
    #[doc = r" So its danagerous to use with Aeron/AeronContext/AeronPublication/AeronSubscription"]
    #[doc = r" More intended for AeronArchiveRecordingDescriptor"]
    pub fn clone_struct(&self) -> Self {
        let copy = Self::default();
        copy.get_inner_mut().clone_from(self.deref());
        copy
    }
}
#[doc = "The error handler to be called when an error occurs."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronErrorHandlerCallback {
    fn handle_aeron_error_handler(&mut self, errcode: ::std::os::raw::c_int, message: &str) -> ();
}
pub struct AeronErrorHandlerLogger;
impl AeronErrorHandlerCallback for AeronErrorHandlerLogger {
    fn handle_aeron_error_handler(&mut self, errcode: ::std::os::raw::c_int, message: &str) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_error_handler),
            [
                format!("{} : {:?}", stringify!(errcode), errcode),
                format!("{} : {:?}", stringify!(message), message)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronErrorHandlerLogger {}
unsafe impl Sync for AeronErrorHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_error_handler_handler() -> Option<&'static Handler<AeronErrorHandlerLogger>> {
        None::<&Handler<AeronErrorHandlerLogger>>
    }
}
#[allow(dead_code)]
#[doc = "The error handler to be called when an error occurs."]
unsafe extern "C" fn aeron_error_handler_t_callback<F: AeronErrorHandlerCallback>(
    clientd: *mut ::std::os::raw::c_void,
    errcode: ::std::os::raw::c_int,
    message: *const ::std::os::raw::c_char,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_error_handler));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_error_handler(
        errcode.into(),
        if message.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(message).to_str().unwrap() }
        },
    )
}
#[allow(dead_code)]
#[doc = "The error handler to be called when an error occurs."]
unsafe extern "C" fn aeron_error_handler_t_callback_for_once_closure<
    F: FnMut(::std::os::raw::c_int, &str) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    errcode: ::std::os::raw::c_int,
    message: *const ::std::os::raw::c_char,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_error_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        errcode.into(),
        if message.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(message).to_str().unwrap() }
        },
    )
}
#[doc = "The error frame handler to be called when the driver notifies the client about an error frame being received."]
#[doc = " The data passed to this callback will only be valid for the lifetime of the callback. The user should use"]
#[doc = " <code>aeron_publication_error_values_copy</code> if they require the data to live longer than that."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronPublicationErrorFrameHandlerCallback {
    fn handle_aeron_publication_error_frame_handler(
        &mut self,
        error_frame: AeronPublicationErrorValues,
    ) -> ();
}
pub struct AeronPublicationErrorFrameHandlerLogger;
impl AeronPublicationErrorFrameHandlerCallback for AeronPublicationErrorFrameHandlerLogger {
    fn handle_aeron_publication_error_frame_handler(
        &mut self,
        error_frame: AeronPublicationErrorValues,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_publication_error_frame_handler),
            [format!("{} : {:?}", stringify!(error_frame), error_frame)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronPublicationErrorFrameHandlerLogger {}
unsafe impl Sync for AeronPublicationErrorFrameHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_publication_error_frame_handler_handler(
    ) -> Option<&'static Handler<AeronPublicationErrorFrameHandlerLogger>> {
        None::<&Handler<AeronPublicationErrorFrameHandlerLogger>>
    }
}
#[allow(dead_code)]
#[doc = "The error frame handler to be called when the driver notifies the client about an error frame being received."]
#[doc = " The data passed to this callback will only be valid for the lifetime of the callback. The user should use"]
#[doc = " <code>aeron_publication_error_values_copy</code> if they require the data to live longer than that."]
unsafe extern "C" fn aeron_publication_error_frame_handler_t_callback<
    F: AeronPublicationErrorFrameHandlerCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    error_frame: *mut aeron_publication_error_values_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_publication_error_frame_handler)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_publication_error_frame_handler(error_frame.into())
}
#[allow(dead_code)]
#[doc = "The error frame handler to be called when the driver notifies the client about an error frame being received."]
#[doc = " The data passed to this callback will only be valid for the lifetime of the callback. The user should use"]
#[doc = " <code>aeron_publication_error_values_copy</code> if they require the data to live longer than that."]
unsafe extern "C" fn aeron_publication_error_frame_handler_t_callback_for_once_closure<
    F: FnMut(AeronPublicationErrorValues) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    error_frame: *mut aeron_publication_error_values_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_publication_error_frame_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(error_frame.into())
}
#[doc = "Generalised notification callback."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronNotificationCallback {
    fn handle_aeron_notification(&mut self) -> ();
}
pub struct AeronNotificationLogger;
impl AeronNotificationCallback for AeronNotificationLogger {
    fn handle_aeron_notification(&mut self) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_notification),
            [""].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronNotificationLogger {}
unsafe impl Sync for AeronNotificationLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_notification_handler() -> Option<&'static Handler<AeronNotificationLogger>> {
        None::<&Handler<AeronNotificationLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Generalised notification callback."]
unsafe extern "C" fn aeron_notification_t_callback<F: AeronNotificationCallback>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_notification));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_notification()
}
#[allow(dead_code)]
#[doc = "Generalised notification callback."]
unsafe extern "C" fn aeron_notification_t_callback_for_once_closure<F: FnMut() -> ()>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_notification_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure()
}
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t"]
#[doc = " or aeron_exclusive_publication_t successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for passing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original add publication call"]
#[doc = " @param channel of the publication"]
#[doc = " @param stream_id within the channel of the publication"]
#[doc = " @param session_id of the publication"]
#[doc = " @param correlation_id used by the publication"]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronNewPublicationCallback {
    fn handle_aeron_on_new_publication(
        &mut self,
        async_: AeronAsyncAddPublication,
        channel: &str,
        stream_id: i32,
        session_id: i32,
        correlation_id: i64,
    ) -> ();
}
pub struct AeronNewPublicationLogger;
impl AeronNewPublicationCallback for AeronNewPublicationLogger {
    fn handle_aeron_on_new_publication(
        &mut self,
        async_: AeronAsyncAddPublication,
        channel: &str,
        stream_id: i32,
        session_id: i32,
        correlation_id: i64,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_new_publication),
            [
                format!("{} : {:?}", stringify!(async_), async_),
                format!("{} : {:?}", stringify!(channel), channel),
                format!("{} : {:?}", stringify!(stream_id), stream_id),
                format!("{} : {:?}", stringify!(session_id), session_id),
                format!("{} : {:?}", stringify!(correlation_id), correlation_id)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronNewPublicationLogger {}
unsafe impl Sync for AeronNewPublicationLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_new_publication_handler() -> Option<&'static Handler<AeronNewPublicationLogger>> {
        None::<&Handler<AeronNewPublicationLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t"]
#[doc = " or aeron_exclusive_publication_t successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for passing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original add publication call"]
#[doc = " @param channel of the publication"]
#[doc = " @param stream_id within the channel of the publication"]
#[doc = " @param session_id of the publication"]
#[doc = " @param correlation_id used by the publication"]
unsafe extern "C" fn aeron_on_new_publication_t_callback<F: AeronNewPublicationCallback>(
    clientd: *mut ::std::os::raw::c_void,
    async_: *mut aeron_async_add_publication_t,
    channel: *const ::std::os::raw::c_char,
    stream_id: i32,
    session_id: i32,
    correlation_id: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_new_publication));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_new_publication(
        async_.into(),
        if channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(channel).to_str().unwrap() }
        },
        stream_id.into(),
        session_id.into(),
        correlation_id.into(),
    )
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t"]
#[doc = " or aeron_exclusive_publication_t successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for passing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original add publication call"]
#[doc = " @param channel of the publication"]
#[doc = " @param stream_id within the channel of the publication"]
#[doc = " @param session_id of the publication"]
#[doc = " @param correlation_id used by the publication"]
unsafe extern "C" fn aeron_on_new_publication_t_callback_for_once_closure<
    F: FnMut(AeronAsyncAddPublication, &str, i32, i32, i64) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    async_: *mut aeron_async_add_publication_t,
    channel: *const ::std::os::raw::c_char,
    stream_id: i32,
    session_id: i32,
    correlation_id: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_new_publication_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        async_.into(),
        if channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(channel).to_str().unwrap() }
        },
        stream_id.into(),
        session_id.into(),
        correlation_id.into(),
    )
}
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t"]
#[doc = " successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for handing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original aeron_add_async_subscription call"]
#[doc = " @param channel of the subscription"]
#[doc = " @param stream_id within the channel of the subscription"]
#[doc = " @param session_id of the subscription"]
#[doc = " @param correlation_id used by the subscription"]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronNewSubscriptionCallback {
    fn handle_aeron_on_new_subscription(
        &mut self,
        async_: AeronAsyncAddSubscription,
        channel: &str,
        stream_id: i32,
        correlation_id: i64,
    ) -> ();
}
pub struct AeronNewSubscriptionLogger;
impl AeronNewSubscriptionCallback for AeronNewSubscriptionLogger {
    fn handle_aeron_on_new_subscription(
        &mut self,
        async_: AeronAsyncAddSubscription,
        channel: &str,
        stream_id: i32,
        correlation_id: i64,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_new_subscription),
            [
                format!("{} : {:?}", stringify!(async_), async_),
                format!("{} : {:?}", stringify!(channel), channel),
                format!("{} : {:?}", stringify!(stream_id), stream_id),
                format!("{} : {:?}", stringify!(correlation_id), correlation_id)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronNewSubscriptionLogger {}
unsafe impl Sync for AeronNewSubscriptionLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_new_subscription_handler() -> Option<&'static Handler<AeronNewSubscriptionLogger>> {
        None::<&Handler<AeronNewSubscriptionLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t"]
#[doc = " successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for handing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original aeron_add_async_subscription call"]
#[doc = " @param channel of the subscription"]
#[doc = " @param stream_id within the channel of the subscription"]
#[doc = " @param session_id of the subscription"]
#[doc = " @param correlation_id used by the subscription"]
unsafe extern "C" fn aeron_on_new_subscription_t_callback<F: AeronNewSubscriptionCallback>(
    clientd: *mut ::std::os::raw::c_void,
    async_: *mut aeron_async_add_subscription_t,
    channel: *const ::std::os::raw::c_char,
    stream_id: i32,
    correlation_id: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_new_subscription));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_new_subscription(
        async_.into(),
        if channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(channel).to_str().unwrap() }
        },
        stream_id.into(),
        correlation_id.into(),
    )
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t"]
#[doc = " successfully."]
#[doc = ""]
#[doc = " Implementations should do the minimum work for handing off state to another thread for later processing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call"]
#[doc = " @param async associated with the original aeron_add_async_subscription call"]
#[doc = " @param channel of the subscription"]
#[doc = " @param stream_id within the channel of the subscription"]
#[doc = " @param session_id of the subscription"]
#[doc = " @param correlation_id used by the subscription"]
unsafe extern "C" fn aeron_on_new_subscription_t_callback_for_once_closure<
    F: FnMut(AeronAsyncAddSubscription, &str, i32, i64) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    async_: *mut aeron_async_add_subscription_t,
    channel: *const ::std::os::raw::c_char,
    stream_id: i32,
    correlation_id: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_new_subscription_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        async_.into(),
        if channel.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(channel).to_str().unwrap() }
        },
        stream_id.into(),
        correlation_id.into(),
    )
}
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t was added."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become available."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronAvailableImageCallback {
    fn handle_aeron_on_available_image(
        &mut self,
        subscription: AeronSubscription,
        image: AeronImage,
    ) -> ();
}
pub struct AeronAvailableImageLogger;
impl AeronAvailableImageCallback for AeronAvailableImageLogger {
    fn handle_aeron_on_available_image(
        &mut self,
        subscription: AeronSubscription,
        image: AeronImage,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_available_image),
            [
                format!("{} : {:?}", stringify!(subscription), subscription),
                format!("{} : {:?}", stringify!(image), image)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronAvailableImageLogger {}
unsafe impl Sync for AeronAvailableImageLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_available_image_handler() -> Option<&'static Handler<AeronAvailableImageLogger>> {
        None::<&Handler<AeronAvailableImageLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t was added."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become available."]
unsafe extern "C" fn aeron_on_available_image_t_callback<F: AeronAvailableImageCallback>(
    clientd: *mut ::std::os::raw::c_void,
    subscription: *mut aeron_subscription_t,
    image: *mut aeron_image_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_available_image));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_available_image(subscription.into(), image.into())
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t was added."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become available."]
unsafe extern "C" fn aeron_on_available_image_t_callback_for_once_closure<
    F: FnMut(AeronSubscription, AeronImage) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    subscription: *mut aeron_subscription_t,
    image: *mut aeron_image_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_available_image_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(subscription.into(), image.into())
}
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and"]
#[doc = " should not be used any longer."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become unavailable."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronUnavailableImageCallback {
    fn handle_aeron_on_unavailable_image(
        &mut self,
        subscription: AeronSubscription,
        image: AeronImage,
    ) -> ();
}
pub struct AeronUnavailableImageLogger;
impl AeronUnavailableImageCallback for AeronUnavailableImageLogger {
    fn handle_aeron_on_unavailable_image(
        &mut self,
        subscription: AeronSubscription,
        image: AeronImage,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_unavailable_image),
            [
                format!("{} : {:?}", stringify!(subscription), subscription),
                format!("{} : {:?}", stringify!(image), image)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronUnavailableImageLogger {}
unsafe impl Sync for AeronUnavailableImageLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_unavailable_image_handler() -> Option<&'static Handler<AeronUnavailableImageLogger>> {
        None::<&Handler<AeronUnavailableImageLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and"]
#[doc = " should not be used any longer."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become unavailable."]
unsafe extern "C" fn aeron_on_unavailable_image_t_callback<F: AeronUnavailableImageCallback>(
    clientd: *mut ::std::os::raw::c_void,
    subscription: *mut aeron_subscription_t,
    image: *mut aeron_image_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_unavailable_image));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_unavailable_image(subscription.into(), image.into())
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and"]
#[doc = " should not be used any longer."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param subscription that image is part of."]
#[doc = " @param image that has become unavailable."]
unsafe extern "C" fn aeron_on_unavailable_image_t_callback_for_once_closure<
    F: FnMut(AeronSubscription, AeronImage) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    subscription: *mut aeron_subscription_t,
    image: *mut aeron_image_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_unavailable_image_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(subscription.into(), image.into())
}
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been added to the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronAvailableCounterCallback {
    fn handle_aeron_on_available_counter(
        &mut self,
        counters_reader: AeronCountersReader,
        registration_id: i64,
        counter_id: i32,
    ) -> ();
}
pub struct AeronAvailableCounterLogger;
impl AeronAvailableCounterCallback for AeronAvailableCounterLogger {
    fn handle_aeron_on_available_counter(
        &mut self,
        counters_reader: AeronCountersReader,
        registration_id: i64,
        counter_id: i32,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_available_counter),
            [
                format!("{} : {:?}", stringify!(counters_reader), counters_reader),
                format!("{} : {:?}", stringify!(registration_id), registration_id),
                format!("{} : {:?}", stringify!(counter_id), counter_id)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronAvailableCounterLogger {}
unsafe impl Sync for AeronAvailableCounterLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_available_counter_handler() -> Option<&'static Handler<AeronAvailableCounterLogger>> {
        None::<&Handler<AeronAvailableCounterLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been added to the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
unsafe extern "C" fn aeron_on_available_counter_t_callback<F: AeronAvailableCounterCallback>(
    clientd: *mut ::std::os::raw::c_void,
    counters_reader: *mut aeron_counters_reader_t,
    registration_id: i64,
    counter_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_available_counter));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_available_counter(
        counters_reader.into(),
        registration_id.into(),
        counter_id.into(),
    )
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been added to the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
unsafe extern "C" fn aeron_on_available_counter_t_callback_for_once_closure<
    F: FnMut(AeronCountersReader, i64, i32) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    counters_reader: *mut aeron_counters_reader_t,
    registration_id: i64,
    counter_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_available_counter_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        counters_reader.into(),
        registration_id.into(),
        counter_id.into(),
    )
}
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronUnavailableCounterCallback {
    fn handle_aeron_on_unavailable_counter(
        &mut self,
        counters_reader: AeronCountersReader,
        registration_id: i64,
        counter_id: i32,
    ) -> ();
}
pub struct AeronUnavailableCounterLogger;
impl AeronUnavailableCounterCallback for AeronUnavailableCounterLogger {
    fn handle_aeron_on_unavailable_counter(
        &mut self,
        counters_reader: AeronCountersReader,
        registration_id: i64,
        counter_id: i32,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_unavailable_counter),
            [
                format!("{} : {:?}", stringify!(counters_reader), counters_reader),
                format!("{} : {:?}", stringify!(registration_id), registration_id),
                format!("{} : {:?}", stringify!(counter_id), counter_id)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronUnavailableCounterLogger {}
unsafe impl Sync for AeronUnavailableCounterLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_unavailable_counter_handler(
    ) -> Option<&'static Handler<AeronUnavailableCounterLogger>> {
        None::<&Handler<AeronUnavailableCounterLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
unsafe extern "C" fn aeron_on_unavailable_counter_t_callback<F: AeronUnavailableCounterCallback>(
    clientd: *mut ::std::os::raw::c_void,
    counters_reader: *mut aeron_counters_reader_t,
    registration_id: i64,
    counter_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_on_unavailable_counter)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_unavailable_counter(
        counters_reader.into(),
        registration_id.into(),
        counter_id.into(),
    )
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = " @param counters_reader that holds the counter."]
#[doc = " @param registration_id of the counter."]
#[doc = " @param counter_id of the counter."]
unsafe extern "C" fn aeron_on_unavailable_counter_t_callback_for_once_closure<
    F: FnMut(AeronCountersReader, i64, i32) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    counters_reader: *mut aeron_counters_reader_t,
    registration_id: i64,
    counter_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_unavailable_counter_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        counters_reader.into(),
        registration_id.into(),
        counter_id.into(),
    )
}
#[doc = "Function called by aeron_client_t to deliver notifications that the client is closing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCloseClientCallback {
    fn handle_aeron_on_close_client(&mut self) -> ();
}
pub struct AeronCloseClientLogger;
impl AeronCloseClientCallback for AeronCloseClientLogger {
    fn handle_aeron_on_close_client(&mut self) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_on_close_client),
            [""].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronCloseClientLogger {}
unsafe impl Sync for AeronCloseClientLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_close_client_handler() -> Option<&'static Handler<AeronCloseClientLogger>> {
        None::<&Handler<AeronCloseClientLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that the client is closing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
unsafe extern "C" fn aeron_on_close_client_t_callback<F: AeronCloseClientCallback>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_on_close_client));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_on_close_client()
}
#[allow(dead_code)]
#[doc = "Function called by aeron_client_t to deliver notifications that the client is closing."]
#[doc = ""]
#[doc = " @param clientd to be returned in the call."]
unsafe extern "C" fn aeron_on_close_client_t_callback_for_once_closure<F: FnMut() -> ()>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_on_close_client_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronAgentStartFuncCallback {
    fn handle_aeron_agent_on_start_func(&mut self, role_name: &str) -> ();
}
pub struct AeronAgentStartFuncLogger;
impl AeronAgentStartFuncCallback for AeronAgentStartFuncLogger {
    fn handle_aeron_agent_on_start_func(&mut self, role_name: &str) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_agent_on_start_func),
            [format!("{} : {:?}", stringify!(role_name), role_name)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronAgentStartFuncLogger {}
unsafe impl Sync for AeronAgentStartFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_agent_start_func_handler() -> Option<&'static Handler<AeronAgentStartFuncLogger>> {
        None::<&Handler<AeronAgentStartFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_on_start_func_t_callback<F: AeronAgentStartFuncCallback>(
    state: *mut ::std::os::raw::c_void,
    role_name: *const ::std::os::raw::c_char,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_agent_on_start_func));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_agent_on_start_func(if role_name.is_null() {
        ""
    } else {
        unsafe { std::ffi::CStr::from_ptr(role_name).to_str().unwrap() }
    })
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_on_start_func_t_callback_for_once_closure<F: FnMut(&str) -> ()>(
    state: *mut ::std::os::raw::c_void,
    role_name: *const ::std::os::raw::c_char,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_agent_on_start_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(if role_name.is_null() {
        ""
    } else {
        unsafe { std::ffi::CStr::from_ptr(role_name).to_str().unwrap() }
    })
}
#[doc = "Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t."]
#[doc = ""]
#[doc = " @param value of the counter."]
#[doc = " @param id of the counter."]
#[doc = " @param label for the counter."]
#[doc = " @param label_length for the counter."]
#[doc = " @param clientd to be returned in the call"]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCountersReaderForeachCounterFuncCallback {
    fn handle_aeron_counters_reader_foreach_counter_func(
        &mut self,
        value: i64,
        id: i32,
        type_id: i32,
        key: &[u8],
        label: &str,
    ) -> ();
}
pub struct AeronCountersReaderForeachCounterFuncLogger;
impl AeronCountersReaderForeachCounterFuncCallback for AeronCountersReaderForeachCounterFuncLogger {
    fn handle_aeron_counters_reader_foreach_counter_func(
        &mut self,
        value: i64,
        id: i32,
        type_id: i32,
        key: &[u8],
        label: &str,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_counters_reader_foreach_counter_func),
            [
                format!("{} : {:?}", stringify!(value), value),
                format!("{} : {:?}", stringify!(id), id),
                format!("{} : {:?}", stringify!(type_id), type_id),
                format!("{} : {:?}", stringify!(key), key),
                format!("{} : {:?}", stringify!(label), label)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronCountersReaderForeachCounterFuncLogger {}
unsafe impl Sync for AeronCountersReaderForeachCounterFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_counters_reader_foreach_counter_func_handler(
    ) -> Option<&'static Handler<AeronCountersReaderForeachCounterFuncLogger>> {
        None::<&Handler<AeronCountersReaderForeachCounterFuncLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t."]
#[doc = ""]
#[doc = " @param value of the counter."]
#[doc = " @param id of the counter."]
#[doc = " @param label for the counter."]
#[doc = " @param label_length for the counter."]
#[doc = " @param clientd to be returned in the call"]
unsafe extern "C" fn aeron_counters_reader_foreach_counter_func_t_callback<
    F: AeronCountersReaderForeachCounterFuncCallback,
>(
    value: i64,
    id: i32,
    type_id: i32,
    key: *const u8,
    key_length: usize,
    label: *const ::std::os::raw::c_char,
    label_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_counters_reader_foreach_counter_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_counters_reader_foreach_counter_func(
        value.into(),
        id.into(),
        type_id.into(),
        if key.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(key, key_length)
        },
        if label.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                label as *const u8,
                label_length.try_into().unwrap(),
            ))
        },
    )
}
#[allow(dead_code)]
#[doc = "Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t."]
#[doc = ""]
#[doc = " @param value of the counter."]
#[doc = " @param id of the counter."]
#[doc = " @param label for the counter."]
#[doc = " @param label_length for the counter."]
#[doc = " @param clientd to be returned in the call"]
unsafe extern "C" fn aeron_counters_reader_foreach_counter_func_t_callback_for_once_closure<
    F: FnMut(i64, i32, i32, &[u8], &str) -> (),
>(
    value: i64,
    id: i32,
    type_id: i32,
    key: *const u8,
    key_length: usize,
    label: *const ::std::os::raw::c_char,
    label_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_counters_reader_foreach_counter_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        value.into(),
        id.into(),
        type_id.into(),
        if key.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(key, key_length)
        },
        if label.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                label as *const u8,
                label_length.try_into().unwrap(),
            ))
        },
    )
}
#[doc = "Function called when filling in the reserved value field of a message."]
#[doc = ""]
#[doc = " @param clientd passed to the offer function."]
#[doc = " @param buffer of the entire frame, including Aeron data header."]
#[doc = " @param frame_length of the entire frame."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronReservedValueSupplierCallback {
    fn handle_aeron_reserved_value_supplier(&mut self, buffer: *mut u8, frame_length: usize)
        -> i64;
}
pub struct AeronReservedValueSupplierLogger;
impl AeronReservedValueSupplierCallback for AeronReservedValueSupplierLogger {
    fn handle_aeron_reserved_value_supplier(
        &mut self,
        buffer: *mut u8,
        frame_length: usize,
    ) -> i64 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_reserved_value_supplier),
            [
                format!("{} : {:?}", stringify!(buffer), buffer),
                format!("{} : {:?}", stringify!(frame_length), frame_length)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronReservedValueSupplierLogger {}
unsafe impl Sync for AeronReservedValueSupplierLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_reserved_value_supplier_handler(
    ) -> Option<&'static Handler<AeronReservedValueSupplierLogger>> {
        None::<&Handler<AeronReservedValueSupplierLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Function called when filling in the reserved value field of a message."]
#[doc = ""]
#[doc = " @param clientd passed to the offer function."]
#[doc = " @param buffer of the entire frame, including Aeron data header."]
#[doc = " @param frame_length of the entire frame."]
unsafe extern "C" fn aeron_reserved_value_supplier_t_callback<
    F: AeronReservedValueSupplierCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *mut u8,
    frame_length: usize,
) -> i64 {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_reserved_value_supplier)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_reserved_value_supplier(buffer.into(), frame_length.into())
}
#[allow(dead_code)]
#[doc = "Function called when filling in the reserved value field of a message."]
#[doc = ""]
#[doc = " @param clientd passed to the offer function."]
#[doc = " @param buffer of the entire frame, including Aeron data header."]
#[doc = " @param frame_length of the entire frame."]
unsafe extern "C" fn aeron_reserved_value_supplier_t_callback_for_once_closure<
    F: FnMut(*mut u8, usize) -> i64,
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *mut u8,
    frame_length: usize,
) -> i64 {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_reserved_value_supplier_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(buffer.into(), frame_length.into())
}
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented"]
#[doc = " if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFragmentHandlerCallback {
    fn handle_aeron_fragment_handler(&mut self, buffer: &[u8], header: AeronHeader) -> ();
}
pub struct AeronFragmentHandlerLogger;
impl AeronFragmentHandlerCallback for AeronFragmentHandlerLogger {
    fn handle_aeron_fragment_handler(&mut self, buffer: &[u8], header: AeronHeader) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_fragment_handler),
            [
                format!("{} : {:?}", stringify!(buffer), buffer),
                format!("{} : {:?}", stringify!(header), header)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronFragmentHandlerLogger {}
unsafe impl Sync for AeronFragmentHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_fragment_handler_handler() -> Option<&'static Handler<AeronFragmentHandlerLogger>> {
        None::<&Handler<AeronFragmentHandlerLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented"]
#[doc = " if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
unsafe extern "C" fn aeron_fragment_handler_t_callback<F: AeronFragmentHandlerCallback>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    header: *mut aeron_header_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_fragment_handler));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_fragment_handler(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        header.into(),
    )
}
#[allow(dead_code)]
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented"]
#[doc = " if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
unsafe extern "C" fn aeron_fragment_handler_t_callback_for_once_closure<
    F: FnMut(&[u8], AeronHeader) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    header: *mut aeron_header_t,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_fragment_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        header.into(),
    )
}
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " Handler for reading data that is coming from a log buffer. The frame will either contain a whole message"]
#[doc = " or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the controlled poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
#[doc = " @return The action to be taken with regard to the stream position after the callback."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronControlledFragmentHandlerCallback {
    fn handle_aeron_controlled_fragment_handler(
        &mut self,
        buffer: &[u8],
        header: AeronHeader,
    ) -> aeron_controlled_fragment_handler_action_t;
}
pub struct AeronControlledFragmentHandlerLogger;
impl AeronControlledFragmentHandlerCallback for AeronControlledFragmentHandlerLogger {
    fn handle_aeron_controlled_fragment_handler(
        &mut self,
        buffer: &[u8],
        header: AeronHeader,
    ) -> aeron_controlled_fragment_handler_action_t {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_controlled_fragment_handler),
            [
                format!("{} : {:?}", stringify!(buffer), buffer),
                format!("{} : {:?}", stringify!(header), header)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronControlledFragmentHandlerLogger {}
unsafe impl Sync for AeronControlledFragmentHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_controlled_fragment_handler_handler(
    ) -> Option<&'static Handler<AeronControlledFragmentHandlerLogger>> {
        None::<&Handler<AeronControlledFragmentHandlerLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " Handler for reading data that is coming from a log buffer. The frame will either contain a whole message"]
#[doc = " or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the controlled poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
#[doc = " @return The action to be taken with regard to the stream position after the callback."]
unsafe extern "C" fn aeron_controlled_fragment_handler_t_callback<
    F: AeronControlledFragmentHandlerCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    header: *mut aeron_header_t,
) -> aeron_controlled_fragment_handler_action_t {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_controlled_fragment_handler)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_controlled_fragment_handler(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        header.into(),
    )
}
#[allow(dead_code)]
#[doc = "Callback for handling fragments of data being read from a log."]
#[doc = ""]
#[doc = " Handler for reading data that is coming from a log buffer. The frame will either contain a whole message"]
#[doc = " or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length."]
#[doc = ""]
#[doc = " @param clientd passed to the controlled poll function."]
#[doc = " @param buffer containing the data."]
#[doc = " @param length of the data in bytes."]
#[doc = " @param header representing the meta data for the data."]
#[doc = " @return The action to be taken with regard to the stream position after the callback."]
unsafe extern "C" fn aeron_controlled_fragment_handler_t_callback_for_once_closure<
    F: FnMut(&[u8], AeronHeader) -> aeron_controlled_fragment_handler_action_t,
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    header: *mut aeron_header_t,
) -> aeron_controlled_fragment_handler_action_t {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_controlled_fragment_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        header.into(),
    )
}
#[doc = "Callback for handling a block of messages being read from a log."]
#[doc = ""]
#[doc = " @param clientd passed to the block poll function."]
#[doc = " @param buffer containing the block of message fragments."]
#[doc = " @param offset at which the block begins, including any frame headers."]
#[doc = " @param length of the block in bytes, including any frame headers that is aligned."]
#[doc = " @param session_id of the stream containing this block of message fragments."]
#[doc = " @param term_id of the stream containing this block of message fragments."]
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronBlockHandlerCallback {
    fn handle_aeron_block_handler(&mut self, buffer: &[u8], session_id: i32, term_id: i32) -> ();
}
pub struct AeronBlockHandlerLogger;
impl AeronBlockHandlerCallback for AeronBlockHandlerLogger {
    fn handle_aeron_block_handler(&mut self, buffer: &[u8], session_id: i32, term_id: i32) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_block_handler),
            [
                format!("{} : {:?}", stringify!(buffer), buffer),
                format!("{} : {:?}", stringify!(session_id), session_id),
                format!("{} : {:?}", stringify!(term_id), term_id)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronBlockHandlerLogger {}
unsafe impl Sync for AeronBlockHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_block_handler_handler() -> Option<&'static Handler<AeronBlockHandlerLogger>> {
        None::<&Handler<AeronBlockHandlerLogger>>
    }
}
#[allow(dead_code)]
#[doc = "Callback for handling a block of messages being read from a log."]
#[doc = ""]
#[doc = " @param clientd passed to the block poll function."]
#[doc = " @param buffer containing the block of message fragments."]
#[doc = " @param offset at which the block begins, including any frame headers."]
#[doc = " @param length of the block in bytes, including any frame headers that is aligned."]
#[doc = " @param session_id of the stream containing this block of message fragments."]
#[doc = " @param term_id of the stream containing this block of message fragments."]
unsafe extern "C" fn aeron_block_handler_t_callback<F: AeronBlockHandlerCallback>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    session_id: i32,
    term_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_block_handler));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_block_handler(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        session_id.into(),
        term_id.into(),
    )
}
#[allow(dead_code)]
#[doc = "Callback for handling a block of messages being read from a log."]
#[doc = ""]
#[doc = " @param clientd passed to the block poll function."]
#[doc = " @param buffer containing the block of message fragments."]
#[doc = " @param offset at which the block begins, including any frame headers."]
#[doc = " @param length of the block in bytes, including any frame headers that is aligned."]
#[doc = " @param session_id of the stream containing this block of message fragments."]
#[doc = " @param term_id of the stream containing this block of message fragments."]
unsafe extern "C" fn aeron_block_handler_t_callback_for_once_closure<
    F: FnMut(&[u8], i32, i32) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    buffer: *const u8,
    length: usize,
    session_id: i32,
    term_id: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_block_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if buffer.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(buffer, length)
        },
        session_id.into(),
        term_id.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronErrorLogReaderFuncCallback {
    fn handle_aeron_error_log_reader_func(
        &mut self,
        observation_count: i32,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        error: &str,
    ) -> ();
}
pub struct AeronErrorLogReaderFuncLogger;
impl AeronErrorLogReaderFuncCallback for AeronErrorLogReaderFuncLogger {
    fn handle_aeron_error_log_reader_func(
        &mut self,
        observation_count: i32,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        error: &str,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_error_log_reader_func),
            [
                format!(
                    "{} : {:?}",
                    stringify!(observation_count),
                    observation_count
                ),
                format!(
                    "{} : {:?}",
                    stringify!(first_observation_timestamp),
                    first_observation_timestamp
                ),
                format!(
                    "{} : {:?}",
                    stringify!(last_observation_timestamp),
                    last_observation_timestamp
                ),
                format!("{} : {:?}", stringify!(error), error)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronErrorLogReaderFuncLogger {}
unsafe impl Sync for AeronErrorLogReaderFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_error_log_reader_func_handler(
    ) -> Option<&'static Handler<AeronErrorLogReaderFuncLogger>> {
        None::<&Handler<AeronErrorLogReaderFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_error_log_reader_func_t_callback<F: AeronErrorLogReaderFuncCallback>(
    observation_count: i32,
    first_observation_timestamp: i64,
    last_observation_timestamp: i64,
    error: *const ::std::os::raw::c_char,
    error_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_error_log_reader_func));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_error_log_reader_func(
        observation_count.into(),
        first_observation_timestamp.into(),
        last_observation_timestamp.into(),
        if error.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                error as *const u8,
                error_length.try_into().unwrap(),
            ))
        },
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_error_log_reader_func_t_callback_for_once_closure<
    F: FnMut(i32, i64, i64, &str) -> (),
>(
    observation_count: i32,
    first_observation_timestamp: i64,
    last_observation_timestamp: i64,
    error: *const ::std::os::raw::c_char,
    error_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_error_log_reader_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        observation_count.into(),
        first_observation_timestamp.into(),
        last_observation_timestamp.into(),
        if error.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                error as *const u8,
                error_length.try_into().unwrap(),
            ))
        },
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronLossReporterReadEntryFuncCallback {
    fn handle_aeron_loss_reporter_read_entry_func(
        &mut self,
        observation_count: i64,
        total_bytes_lost: i64,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        session_id: i32,
        stream_id: i32,
        channel: &str,
        source: &str,
    ) -> ();
}
pub struct AeronLossReporterReadEntryFuncLogger;
impl AeronLossReporterReadEntryFuncCallback for AeronLossReporterReadEntryFuncLogger {
    fn handle_aeron_loss_reporter_read_entry_func(
        &mut self,
        observation_count: i64,
        total_bytes_lost: i64,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        session_id: i32,
        stream_id: i32,
        channel: &str,
        source: &str,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_loss_reporter_read_entry_func),
            [
                format!(
                    "{} : {:?}",
                    stringify!(observation_count),
                    observation_count
                ),
                format!("{} : {:?}", stringify!(total_bytes_lost), total_bytes_lost),
                format!(
                    "{} : {:?}",
                    stringify!(first_observation_timestamp),
                    first_observation_timestamp
                ),
                format!(
                    "{} : {:?}",
                    stringify!(last_observation_timestamp),
                    last_observation_timestamp
                ),
                format!("{} : {:?}", stringify!(session_id), session_id),
                format!("{} : {:?}", stringify!(stream_id), stream_id),
                format!("{} : {:?}", stringify!(channel), channel),
                format!("{} : {:?}", stringify!(source), source)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronLossReporterReadEntryFuncLogger {}
unsafe impl Sync for AeronLossReporterReadEntryFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_loss_reporter_read_entry_func_handler(
    ) -> Option<&'static Handler<AeronLossReporterReadEntryFuncLogger>> {
        None::<&Handler<AeronLossReporterReadEntryFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_loss_reporter_read_entry_func_t_callback<
    F: AeronLossReporterReadEntryFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    observation_count: i64,
    total_bytes_lost: i64,
    first_observation_timestamp: i64,
    last_observation_timestamp: i64,
    session_id: i32,
    stream_id: i32,
    channel: *const ::std::os::raw::c_char,
    channel_length: i32,
    source: *const ::std::os::raw::c_char,
    source_length: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_loss_reporter_read_entry_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_loss_reporter_read_entry_func(
        observation_count.into(),
        total_bytes_lost.into(),
        first_observation_timestamp.into(),
        last_observation_timestamp.into(),
        session_id.into(),
        stream_id.into(),
        if channel.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                channel as *const u8,
                channel_length.try_into().unwrap(),
            ))
        },
        if source.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                source as *const u8,
                source_length.try_into().unwrap(),
            ))
        },
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_loss_reporter_read_entry_func_t_callback_for_once_closure<
    F: FnMut(i64, i64, i64, i64, i32, i32, &str, &str) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    observation_count: i64,
    total_bytes_lost: i64,
    first_observation_timestamp: i64,
    last_observation_timestamp: i64,
    session_id: i32,
    stream_id: i32,
    channel: *const ::std::os::raw::c_char,
    channel_length: i32,
    source: *const ::std::os::raw::c_char,
    source_length: i32,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_loss_reporter_read_entry_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        observation_count.into(),
        total_bytes_lost.into(),
        first_observation_timestamp.into(),
        last_observation_timestamp.into(),
        session_id.into(),
        stream_id.into(),
        if channel.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                channel as *const u8,
                channel_length.try_into().unwrap(),
            ))
        },
        if source.is_null() {
            ""
        } else {
            std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                source as *const u8,
                source_length.try_into().unwrap(),
            ))
        },
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronIdleStrategyFuncCallback {
    fn handle_aeron_idle_strategy_func(&mut self, work_count: ::std::os::raw::c_int) -> ();
}
pub struct AeronIdleStrategyFuncLogger;
impl AeronIdleStrategyFuncCallback for AeronIdleStrategyFuncLogger {
    fn handle_aeron_idle_strategy_func(&mut self, work_count: ::std::os::raw::c_int) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_idle_strategy_func),
            [format!("{} : {:?}", stringify!(work_count), work_count)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronIdleStrategyFuncLogger {}
unsafe impl Sync for AeronIdleStrategyFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_idle_strategy_func_handler() -> Option<&'static Handler<AeronIdleStrategyFuncLogger>>
    {
        None::<&Handler<AeronIdleStrategyFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_idle_strategy_func_t_callback<F: AeronIdleStrategyFuncCallback>(
    state: *mut ::std::os::raw::c_void,
    work_count: ::std::os::raw::c_int,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_idle_strategy_func));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_idle_strategy_func(work_count.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_idle_strategy_func_t_callback_for_once_closure<
    F: FnMut(::std::os::raw::c_int) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    work_count: ::std::os::raw::c_int,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_idle_strategy_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(work_count.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronUriParseCallbackCallback {
    fn handle_aeron_uri_parse_callback(&mut self, key: &str, value: &str) -> ::std::os::raw::c_int;
}
pub struct AeronUriParseCallbackLogger;
impl AeronUriParseCallbackCallback for AeronUriParseCallbackLogger {
    fn handle_aeron_uri_parse_callback(&mut self, key: &str, value: &str) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_uri_parse_callback),
            [
                format!("{} : {:?}", stringify!(key), key),
                format!("{} : {:?}", stringify!(value), value)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronUriParseCallbackLogger {}
unsafe impl Sync for AeronUriParseCallbackLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_uri_parse_callback_handler() -> Option<&'static Handler<AeronUriParseCallbackLogger>>
    {
        None::<&Handler<AeronUriParseCallbackLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_uri_parse_callback_t_callback<F: AeronUriParseCallbackCallback>(
    clientd: *mut ::std::os::raw::c_void,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_uri_parse_callback));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_uri_parse_callback(
        if key.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(key).to_str().unwrap() }
        },
        if value.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(value).to_str().unwrap() }
        },
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_uri_parse_callback_t_callback_for_once_closure<
    F: FnMut(&str, &str) -> ::std::os::raw::c_int,
>(
    clientd: *mut ::std::os::raw::c_void,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_uri_parse_callback_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if key.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(key).to_str().unwrap() }
        },
        if value.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(value).to_str().unwrap() }
        },
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronDriverTerminationValidatorFuncCallback {
    fn handle_aeron_driver_termination_validator_func(&mut self, buffer: &mut [u8]) -> bool;
}
pub struct AeronDriverTerminationValidatorFuncLogger;
impl AeronDriverTerminationValidatorFuncCallback for AeronDriverTerminationValidatorFuncLogger {
    fn handle_aeron_driver_termination_validator_func(&mut self, buffer: &mut [u8]) -> bool {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_driver_termination_validator_func),
            [format!("{} : {:?}", stringify!(buffer), buffer)].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronDriverTerminationValidatorFuncLogger {}
unsafe impl Sync for AeronDriverTerminationValidatorFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_driver_termination_validator_func_handler(
    ) -> Option<&'static Handler<AeronDriverTerminationValidatorFuncLogger>> {
        None::<&Handler<AeronDriverTerminationValidatorFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_driver_termination_validator_func_t_callback<
    F: AeronDriverTerminationValidatorFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    buffer: *mut u8,
    length: i32,
) -> bool {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_driver_termination_validator_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_driver_termination_validator_func(unsafe {
        if buffer.is_null() {
            &mut [] as &mut [_]
        } else {
            std::slice::from_raw_parts_mut(buffer, length.try_into().unwrap())
        }
    })
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_driver_termination_validator_func_t_callback_for_once_closure<
    F: FnMut(&mut [u8]) -> bool,
>(
    state: *mut ::std::os::raw::c_void,
    buffer: *mut u8,
    length: i32,
) -> bool {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_driver_termination_validator_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(unsafe {
        if buffer.is_null() {
            &mut [] as &mut [_]
        } else {
            std::slice::from_raw_parts_mut(buffer, length.try_into().unwrap())
        }
    })
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronDriverTerminationHookFuncCallback {
    fn handle_aeron_driver_termination_hook_func(&mut self) -> ();
}
pub struct AeronDriverTerminationHookFuncLogger;
impl AeronDriverTerminationHookFuncCallback for AeronDriverTerminationHookFuncLogger {
    fn handle_aeron_driver_termination_hook_func(&mut self) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_driver_termination_hook_func),
            [""].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronDriverTerminationHookFuncLogger {}
unsafe impl Sync for AeronDriverTerminationHookFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_driver_termination_hook_func_handler(
    ) -> Option<&'static Handler<AeronDriverTerminationHookFuncLogger>> {
        None::<&Handler<AeronDriverTerminationHookFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_driver_termination_hook_func_t_callback<
    F: AeronDriverTerminationHookFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_driver_termination_hook_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_driver_termination_hook_func()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_driver_termination_hook_func_t_callback_for_once_closure<
    F: FnMut() -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_driver_termination_hook_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronRbHandlerCallback {
    fn handle_aeron_rb_handler(
        &mut self,
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ();
}
pub struct AeronRbHandlerLogger;
impl AeronRbHandlerCallback for AeronRbHandlerLogger {
    fn handle_aeron_rb_handler(
        &mut self,
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_rb_handler),
            [
                format!("{} : {:?}", stringify!(arg1), arg1),
                format!("{} : {:?}", stringify!(arg2), arg2),
                format!("{} : {:?}", stringify!(arg3), arg3)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronRbHandlerLogger {}
unsafe impl Sync for AeronRbHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_rb_handler_handler() -> Option<&'static Handler<AeronRbHandlerLogger>> {
        None::<&Handler<AeronRbHandlerLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_rb_handler_t_callback<F: AeronRbHandlerCallback>(
    arg1: i32,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
    arg4: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if arg4.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_rb_handler));
    }
    let closure: &mut F = &mut *(arg4 as *mut F);
    closure.handle_aeron_rb_handler(arg1.into(), arg2.into(), arg3.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_rb_handler_t_callback_for_once_closure<
    F: FnMut(i32, *const ::std::os::raw::c_void, usize) -> (),
>(
    arg1: i32,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
    arg4: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if arg4.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_rb_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(arg4 as *mut F);
    closure(arg1.into(), arg2.into(), arg3.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronRbControlledHandlerCallback {
    fn handle_aeron_rb_controlled_handler(
        &mut self,
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> aeron_rb_read_action_t;
}
pub struct AeronRbControlledHandlerLogger;
impl AeronRbControlledHandlerCallback for AeronRbControlledHandlerLogger {
    fn handle_aeron_rb_controlled_handler(
        &mut self,
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> aeron_rb_read_action_t {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_rb_controlled_handler),
            [
                format!("{} : {:?}", stringify!(arg1), arg1),
                format!("{} : {:?}", stringify!(arg2), arg2),
                format!("{} : {:?}", stringify!(arg3), arg3)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronRbControlledHandlerLogger {}
unsafe impl Sync for AeronRbControlledHandlerLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_rb_controlled_handler_handler(
    ) -> Option<&'static Handler<AeronRbControlledHandlerLogger>> {
        None::<&Handler<AeronRbControlledHandlerLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_rb_controlled_handler_t_callback<F: AeronRbControlledHandlerCallback>(
    arg1: i32,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
    arg4: *mut ::std::os::raw::c_void,
) -> aeron_rb_read_action_t {
    #[cfg(debug_assertions)]
    if arg4.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_rb_controlled_handler));
    }
    let closure: &mut F = &mut *(arg4 as *mut F);
    closure.handle_aeron_rb_controlled_handler(arg1.into(), arg2.into(), arg3.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_rb_controlled_handler_t_callback_for_once_closure<
    F: FnMut(i32, *const ::std::os::raw::c_void, usize) -> aeron_rb_read_action_t,
>(
    arg1: i32,
    arg2: *const ::std::os::raw::c_void,
    arg3: usize,
    arg4: *mut ::std::os::raw::c_void,
) -> aeron_rb_read_action_t {
    #[cfg(debug_assertions)]
    if arg4.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_rb_controlled_handler_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(arg4 as *mut F);
    closure(arg1.into(), arg2.into(), arg3.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategyIdleFuncCallback {
    fn handle_aeron_flow_control_strategy_on_idle_func(
        &mut self,
        now_ns: i64,
        snd_lmt: i64,
        snd_pos: i64,
        is_end_of_stream: bool,
    ) -> i64;
}
pub struct AeronFlowControlStrategyIdleFuncLogger;
impl AeronFlowControlStrategyIdleFuncCallback for AeronFlowControlStrategyIdleFuncLogger {
    fn handle_aeron_flow_control_strategy_on_idle_func(
        &mut self,
        now_ns: i64,
        snd_lmt: i64,
        snd_pos: i64,
        is_end_of_stream: bool,
    ) -> i64 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_on_idle_func),
            [
                format!("{} : {:?}", stringify!(now_ns), now_ns),
                format!("{} : {:?}", stringify!(snd_lmt), snd_lmt),
                format!("{} : {:?}", stringify!(snd_pos), snd_pos),
                format!("{} : {:?}", stringify!(is_end_of_stream), is_end_of_stream)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronFlowControlStrategyIdleFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategyIdleFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_idle_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategyIdleFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategyIdleFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_idle_func_t_callback<
    F: AeronFlowControlStrategyIdleFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
    snd_lmt: i64,
    snd_pos: i64,
    is_end_of_stream: bool,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_on_idle_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_on_idle_func(
        now_ns.into(),
        snd_lmt.into(),
        snd_pos.into(),
        is_end_of_stream.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_idle_func_t_callback_for_once_closure<
    F: FnMut(i64, i64, i64, bool) -> i64,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
    snd_lmt: i64,
    snd_pos: i64,
    is_end_of_stream: bool,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_flow_control_strategy_on_idle_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        now_ns.into(),
        snd_lmt.into(),
        snd_pos.into(),
        is_end_of_stream.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategySmFuncCallback {
    fn handle_aeron_flow_control_strategy_on_sm_func(
        &mut self,
        sm: &[u8],
        recv_addr: SockaddrStorage,
        snd_lmt: i64,
        initial_term_id: i32,
        position_bits_to_shift: usize,
        now_ns: i64,
    ) -> i64;
}
pub struct AeronFlowControlStrategySmFuncLogger;
impl AeronFlowControlStrategySmFuncCallback for AeronFlowControlStrategySmFuncLogger {
    fn handle_aeron_flow_control_strategy_on_sm_func(
        &mut self,
        sm: &[u8],
        recv_addr: SockaddrStorage,
        snd_lmt: i64,
        initial_term_id: i32,
        position_bits_to_shift: usize,
        now_ns: i64,
    ) -> i64 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_on_sm_func),
            [
                format!("{} : {:?}", stringify!(sm), sm),
                format!("{} : {:?}", stringify!(recv_addr), recv_addr),
                format!("{} : {:?}", stringify!(snd_lmt), snd_lmt),
                format!("{} : {:?}", stringify!(initial_term_id), initial_term_id),
                format!(
                    "{} : {:?}",
                    stringify!(position_bits_to_shift),
                    position_bits_to_shift
                ),
                format!("{} : {:?}", stringify!(now_ns), now_ns)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronFlowControlStrategySmFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategySmFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_sm_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategySmFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategySmFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_sm_func_t_callback<
    F: AeronFlowControlStrategySmFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    sm: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    snd_lmt: i64,
    initial_term_id: i32,
    position_bits_to_shift: usize,
    now_ns: i64,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_on_sm_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_on_sm_func(
        if sm.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(sm, length)
        },
        recv_addr.into(),
        snd_lmt.into(),
        initial_term_id.into(),
        position_bits_to_shift.into(),
        now_ns.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_sm_func_t_callback_for_once_closure<
    F: FnMut(&[u8], SockaddrStorage, i64, i32, usize, i64) -> i64,
>(
    state: *mut ::std::os::raw::c_void,
    sm: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    snd_lmt: i64,
    initial_term_id: i32,
    position_bits_to_shift: usize,
    now_ns: i64,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_flow_control_strategy_on_sm_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        if sm.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(sm, length)
        },
        recv_addr.into(),
        snd_lmt.into(),
        initial_term_id.into(),
        position_bits_to_shift.into(),
        now_ns.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategySetupFuncCallback {
    fn handle_aeron_flow_control_strategy_on_setup_func(
        &mut self,
        setup: &[u8],
        now_ns: i64,
        snd_lmt: i64,
        position_bits_to_shift: usize,
        snd_pos: i64,
    ) -> i64;
}
pub struct AeronFlowControlStrategySetupFuncLogger;
impl AeronFlowControlStrategySetupFuncCallback for AeronFlowControlStrategySetupFuncLogger {
    fn handle_aeron_flow_control_strategy_on_setup_func(
        &mut self,
        setup: &[u8],
        now_ns: i64,
        snd_lmt: i64,
        position_bits_to_shift: usize,
        snd_pos: i64,
    ) -> i64 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_on_setup_func),
            [
                format!("{} : {:?}", stringify!(setup), setup),
                format!("{} : {:?}", stringify!(now_ns), now_ns),
                format!("{} : {:?}", stringify!(snd_lmt), snd_lmt),
                format!(
                    "{} : {:?}",
                    stringify!(position_bits_to_shift),
                    position_bits_to_shift
                ),
                format!("{} : {:?}", stringify!(snd_pos), snd_pos)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronFlowControlStrategySetupFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategySetupFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_setup_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategySetupFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategySetupFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_setup_func_t_callback<
    F: AeronFlowControlStrategySetupFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    setup: *const u8,
    length: usize,
    now_ns: i64,
    snd_lmt: i64,
    position_bits_to_shift: usize,
    snd_pos: i64,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_on_setup_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_on_setup_func(
        if setup.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(setup, length)
        },
        now_ns.into(),
        snd_lmt.into(),
        position_bits_to_shift.into(),
        snd_pos.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_setup_func_t_callback_for_once_closure<
    F: FnMut(&[u8], i64, i64, usize, i64) -> i64,
>(
    state: *mut ::std::os::raw::c_void,
    setup: *const u8,
    length: usize,
    now_ns: i64,
    snd_lmt: i64,
    position_bits_to_shift: usize,
    snd_pos: i64,
) -> i64 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_flow_control_strategy_on_setup_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        if setup.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(setup, length)
        },
        now_ns.into(),
        snd_lmt.into(),
        position_bits_to_shift.into(),
        snd_pos.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategyErrorFuncCallback {
    fn handle_aeron_flow_control_strategy_on_error_func(
        &mut self,
        error: &[u8],
        recv_addr: SockaddrStorage,
        now_ns: i64,
    ) -> ();
}
pub struct AeronFlowControlStrategyErrorFuncLogger;
impl AeronFlowControlStrategyErrorFuncCallback for AeronFlowControlStrategyErrorFuncLogger {
    fn handle_aeron_flow_control_strategy_on_error_func(
        &mut self,
        error: &[u8],
        recv_addr: SockaddrStorage,
        now_ns: i64,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_on_error_func),
            [
                format!("{} : {:?}", stringify!(error), error),
                format!("{} : {:?}", stringify!(recv_addr), recv_addr),
                format!("{} : {:?}", stringify!(now_ns), now_ns)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronFlowControlStrategyErrorFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategyErrorFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_error_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategyErrorFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategyErrorFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_error_func_t_callback<
    F: AeronFlowControlStrategyErrorFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    error: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_on_error_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_on_error_func(
        if error.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(error, length)
        },
        recv_addr.into(),
        now_ns.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_error_func_t_callback_for_once_closure<
    F: FnMut(&[u8], SockaddrStorage, i64) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    error: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_flow_control_strategy_on_error_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        if error.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(error, length)
        },
        recv_addr.into(),
        now_ns.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategyTriggerSendSetupFuncCallback {
    fn handle_aeron_flow_control_strategy_on_trigger_send_setup_func(
        &mut self,
        sm: &[u8],
        recv_addr: SockaddrStorage,
        now_ns: i64,
    ) -> ();
}
pub struct AeronFlowControlStrategyTriggerSendSetupFuncLogger;
impl AeronFlowControlStrategyTriggerSendSetupFuncCallback
    for AeronFlowControlStrategyTriggerSendSetupFuncLogger
{
    fn handle_aeron_flow_control_strategy_on_trigger_send_setup_func(
        &mut self,
        sm: &[u8],
        recv_addr: SockaddrStorage,
        now_ns: i64,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_on_trigger_send_setup_func),
            [
                format!("{} : {:?}", stringify!(sm), sm),
                format!("{} : {:?}", stringify!(recv_addr), recv_addr),
                format!("{} : {:?}", stringify!(now_ns), now_ns)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronFlowControlStrategyTriggerSendSetupFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategyTriggerSendSetupFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_trigger_send_setup_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategyTriggerSendSetupFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategyTriggerSendSetupFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_trigger_send_setup_func_t_callback<
    F: AeronFlowControlStrategyTriggerSendSetupFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    sm: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_on_trigger_send_setup_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_on_trigger_send_setup_func(
        if sm.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(sm, length)
        },
        recv_addr.into(),
        now_ns.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_on_trigger_send_setup_func_t_callback_for_once_closure<
    F: FnMut(&[u8], SockaddrStorage, i64) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    sm: *const u8,
    length: usize,
    recv_addr: *mut sockaddr_storage,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(
                aeron_flow_control_strategy_on_trigger_send_setup_func_t_callback_for_once_closure
            )
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        if sm.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(sm, length)
        },
        recv_addr.into(),
        now_ns.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronFlowControlStrategyMaxRetransmissionLengthFuncCallback {
    fn handle_aeron_flow_control_strategy_max_retransmission_length_func(
        &mut self,
        term_offset: usize,
        resend_length: usize,
        term_buffer_length: usize,
        mtu_length: usize,
    ) -> usize;
}
pub struct AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger;
impl AeronFlowControlStrategyMaxRetransmissionLengthFuncCallback
    for AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger
{
    fn handle_aeron_flow_control_strategy_max_retransmission_length_func(
        &mut self,
        term_offset: usize,
        resend_length: usize,
        term_buffer_length: usize,
        mtu_length: usize,
    ) -> usize {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_flow_control_strategy_max_retransmission_length_func),
            [
                format!("{} : {:?}", stringify!(term_offset), term_offset),
                format!("{} : {:?}", stringify!(resend_length), resend_length),
                format!(
                    "{} : {:?}",
                    stringify!(term_buffer_length),
                    term_buffer_length
                ),
                format!("{} : {:?}", stringify!(mtu_length), mtu_length)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger {}
unsafe impl Sync for AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_flow_control_strategy_max_retransmission_length_func_handler(
    ) -> Option<&'static Handler<AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger>> {
        None::<&Handler<AeronFlowControlStrategyMaxRetransmissionLengthFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_max_retransmission_length_func_t_callback<
    F: AeronFlowControlStrategyMaxRetransmissionLengthFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    term_offset: usize,
    resend_length: usize,
    term_buffer_length: usize,
    mtu_length: usize,
) -> usize {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_flow_control_strategy_max_retransmission_length_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_flow_control_strategy_max_retransmission_length_func(
        term_offset.into(),
        resend_length.into(),
        term_buffer_length.into(),
        mtu_length.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_flow_control_strategy_max_retransmission_length_func_t_callback_for_once_closure<
    F: FnMut(usize, usize, usize, usize) -> usize,
>(
    state: *mut ::std::os::raw::c_void,
    term_offset: usize,
    resend_length: usize,
    term_buffer_length: usize,
    mtu_length: usize,
) -> usize {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log :: debug ! ("calling {}" , stringify ! (aeron_flow_control_strategy_max_retransmission_length_func_t_callback_for_once_closure));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(
        term_offset.into(),
        resend_length.into(),
        term_buffer_length.into(),
        mtu_length.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCongestionControlStrategyShouldMeasureRttFuncCallback {
    fn handle_aeron_congestion_control_strategy_should_measure_rtt_func(
        &mut self,
        now_ns: i64,
    ) -> bool;
}
pub struct AeronCongestionControlStrategyShouldMeasureRttFuncLogger;
impl AeronCongestionControlStrategyShouldMeasureRttFuncCallback
    for AeronCongestionControlStrategyShouldMeasureRttFuncLogger
{
    fn handle_aeron_congestion_control_strategy_should_measure_rtt_func(
        &mut self,
        now_ns: i64,
    ) -> bool {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_congestion_control_strategy_should_measure_rtt_func),
            [format!("{} : {:?}", stringify!(now_ns), now_ns)].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronCongestionControlStrategyShouldMeasureRttFuncLogger {}
unsafe impl Sync for AeronCongestionControlStrategyShouldMeasureRttFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_congestion_control_strategy_should_measure_rtt_func_handler(
    ) -> Option<&'static Handler<AeronCongestionControlStrategyShouldMeasureRttFuncLogger>> {
        None::<&Handler<AeronCongestionControlStrategyShouldMeasureRttFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_should_measure_rtt_func_t_callback<
    F: AeronCongestionControlStrategyShouldMeasureRttFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> bool {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_congestion_control_strategy_should_measure_rtt_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_congestion_control_strategy_should_measure_rtt_func(now_ns.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_should_measure_rtt_func_t_callback_for_once_closure<
    F: FnMut(i64) -> bool,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> bool {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log :: debug ! ("calling {}" , stringify ! (aeron_congestion_control_strategy_should_measure_rtt_func_t_callback_for_once_closure));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(now_ns.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCongestionControlStrategyRttmSentFuncCallback {
    fn handle_aeron_congestion_control_strategy_on_rttm_sent_func(&mut self, now_ns: i64) -> ();
}
pub struct AeronCongestionControlStrategyRttmSentFuncLogger;
impl AeronCongestionControlStrategyRttmSentFuncCallback
    for AeronCongestionControlStrategyRttmSentFuncLogger
{
    fn handle_aeron_congestion_control_strategy_on_rttm_sent_func(&mut self, now_ns: i64) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_congestion_control_strategy_on_rttm_sent_func),
            [format!("{} : {:?}", stringify!(now_ns), now_ns)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronCongestionControlStrategyRttmSentFuncLogger {}
unsafe impl Sync for AeronCongestionControlStrategyRttmSentFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_congestion_control_strategy_rttm_sent_func_handler(
    ) -> Option<&'static Handler<AeronCongestionControlStrategyRttmSentFuncLogger>> {
        None::<&Handler<AeronCongestionControlStrategyRttmSentFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_on_rttm_sent_func_t_callback<
    F: AeronCongestionControlStrategyRttmSentFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_congestion_control_strategy_on_rttm_sent_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_congestion_control_strategy_on_rttm_sent_func(now_ns.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_on_rttm_sent_func_t_callback_for_once_closure<
    F: FnMut(i64) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(
                aeron_congestion_control_strategy_on_rttm_sent_func_t_callback_for_once_closure
            )
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(now_ns.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCongestionControlStrategyRttmFuncCallback {
    fn handle_aeron_congestion_control_strategy_on_rttm_func(
        &mut self,
        now_ns: i64,
        rtt_ns: i64,
        source_address: SockaddrStorage,
    ) -> ();
}
pub struct AeronCongestionControlStrategyRttmFuncLogger;
impl AeronCongestionControlStrategyRttmFuncCallback
    for AeronCongestionControlStrategyRttmFuncLogger
{
    fn handle_aeron_congestion_control_strategy_on_rttm_func(
        &mut self,
        now_ns: i64,
        rtt_ns: i64,
        source_address: SockaddrStorage,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_congestion_control_strategy_on_rttm_func),
            [
                format!("{} : {:?}", stringify!(now_ns), now_ns),
                format!("{} : {:?}", stringify!(rtt_ns), rtt_ns),
                format!("{} : {:?}", stringify!(source_address), source_address)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronCongestionControlStrategyRttmFuncLogger {}
unsafe impl Sync for AeronCongestionControlStrategyRttmFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_congestion_control_strategy_rttm_func_handler(
    ) -> Option<&'static Handler<AeronCongestionControlStrategyRttmFuncLogger>> {
        None::<&Handler<AeronCongestionControlStrategyRttmFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_on_rttm_func_t_callback<
    F: AeronCongestionControlStrategyRttmFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
    rtt_ns: i64,
    source_address: *mut sockaddr_storage,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_congestion_control_strategy_on_rttm_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_congestion_control_strategy_on_rttm_func(
        now_ns.into(),
        rtt_ns.into(),
        source_address.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_on_rttm_func_t_callback_for_once_closure<
    F: FnMut(i64, i64, SockaddrStorage) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
    rtt_ns: i64,
    source_address: *mut sockaddr_storage,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_congestion_control_strategy_on_rttm_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(now_ns.into(), rtt_ns.into(), source_address.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCongestionControlStrategyInitialWindowLengthFuncCallback {
    fn handle_aeron_congestion_control_strategy_initial_window_length_func(&mut self) -> i32;
}
pub struct AeronCongestionControlStrategyInitialWindowLengthFuncLogger;
impl AeronCongestionControlStrategyInitialWindowLengthFuncCallback
    for AeronCongestionControlStrategyInitialWindowLengthFuncLogger
{
    fn handle_aeron_congestion_control_strategy_initial_window_length_func(&mut self) -> i32 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_congestion_control_strategy_initial_window_length_func),
            [""].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronCongestionControlStrategyInitialWindowLengthFuncLogger {}
unsafe impl Sync for AeronCongestionControlStrategyInitialWindowLengthFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_congestion_control_strategy_initial_window_length_func_handler(
    ) -> Option<&'static Handler<AeronCongestionControlStrategyInitialWindowLengthFuncLogger>> {
        None::<&Handler<AeronCongestionControlStrategyInitialWindowLengthFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_initial_window_length_func_t_callback<
    F: AeronCongestionControlStrategyInitialWindowLengthFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
) -> i32 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_congestion_control_strategy_initial_window_length_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_congestion_control_strategy_initial_window_length_func()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_initial_window_length_func_t_callback_for_once_closure<
    F: FnMut() -> i32,
>(
    state: *mut ::std::os::raw::c_void,
) -> i32 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log :: debug ! ("calling {}" , stringify ! (aeron_congestion_control_strategy_initial_window_length_func_t_callback_for_once_closure));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCongestionControlStrategyMaxWindowLengthFuncCallback {
    fn handle_aeron_congestion_control_strategy_max_window_length_func(&mut self) -> i32;
}
pub struct AeronCongestionControlStrategyMaxWindowLengthFuncLogger;
impl AeronCongestionControlStrategyMaxWindowLengthFuncCallback
    for AeronCongestionControlStrategyMaxWindowLengthFuncLogger
{
    fn handle_aeron_congestion_control_strategy_max_window_length_func(&mut self) -> i32 {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_congestion_control_strategy_max_window_length_func),
            [""].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronCongestionControlStrategyMaxWindowLengthFuncLogger {}
unsafe impl Sync for AeronCongestionControlStrategyMaxWindowLengthFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_congestion_control_strategy_max_window_length_func_handler(
    ) -> Option<&'static Handler<AeronCongestionControlStrategyMaxWindowLengthFuncLogger>> {
        None::<&Handler<AeronCongestionControlStrategyMaxWindowLengthFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_max_window_length_func_t_callback<
    F: AeronCongestionControlStrategyMaxWindowLengthFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
) -> i32 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_congestion_control_strategy_max_window_length_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_congestion_control_strategy_max_window_length_func()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_congestion_control_strategy_max_window_length_func_t_callback_for_once_closure<
    F: FnMut() -> i32,
>(
    state: *mut ::std::os::raw::c_void,
) -> i32 {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log :: debug ! ("calling {}" , stringify ! (aeron_congestion_control_strategy_max_window_length_func_t_callback_for_once_closure));
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronAgentDoWorkFuncCallback {
    fn handle_aeron_agent_do_work_func(&mut self) -> ::std::os::raw::c_int;
}
pub struct AeronAgentDoWorkFuncLogger;
impl AeronAgentDoWorkFuncCallback for AeronAgentDoWorkFuncLogger {
    fn handle_aeron_agent_do_work_func(&mut self) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_agent_do_work_func),
            [""].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronAgentDoWorkFuncLogger {}
unsafe impl Sync for AeronAgentDoWorkFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_agent_do_work_func_handler() -> Option<&'static Handler<AeronAgentDoWorkFuncLogger>> {
        None::<&Handler<AeronAgentDoWorkFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_do_work_func_t_callback<F: AeronAgentDoWorkFuncCallback>(
    arg1: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if arg1.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_agent_do_work_func));
    }
    let closure: &mut F = &mut *(arg1 as *mut F);
    closure.handle_aeron_agent_do_work_func()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_do_work_func_t_callback_for_once_closure<
    F: FnMut() -> ::std::os::raw::c_int,
>(
    arg1: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if arg1.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_agent_do_work_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(arg1 as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronAgentCloseFuncCallback {
    fn handle_aeron_agent_on_close_func(&mut self) -> ();
}
pub struct AeronAgentCloseFuncLogger;
impl AeronAgentCloseFuncCallback for AeronAgentCloseFuncLogger {
    fn handle_aeron_agent_on_close_func(&mut self) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_agent_on_close_func),
            [""].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronAgentCloseFuncLogger {}
unsafe impl Sync for AeronAgentCloseFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_agent_close_func_handler() -> Option<&'static Handler<AeronAgentCloseFuncLogger>> {
        None::<&Handler<AeronAgentCloseFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_on_close_func_t_callback<F: AeronAgentCloseFuncCallback>(
    arg1: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if arg1.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_agent_on_close_func));
    }
    let closure: &mut F = &mut *(arg1 as *mut F);
    closure.handle_aeron_agent_on_close_func()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_agent_on_close_func_t_callback_for_once_closure<F: FnMut() -> ()>(
    arg1: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if arg1.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_agent_on_close_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(arg1 as *mut F);
    closure()
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronCountersReaderForeachMetadataFuncCallback {
    fn handle_aeron_counters_reader_foreach_metadata_func(
        &mut self,
        id: i32,
        type_id: i32,
        key: &[u8],
        label: &[u8],
    ) -> ();
}
pub struct AeronCountersReaderForeachMetadataFuncLogger;
impl AeronCountersReaderForeachMetadataFuncCallback
    for AeronCountersReaderForeachMetadataFuncLogger
{
    fn handle_aeron_counters_reader_foreach_metadata_func(
        &mut self,
        id: i32,
        type_id: i32,
        key: &[u8],
        label: &[u8],
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_counters_reader_foreach_metadata_func),
            [
                format!("{} : {:?}", stringify!(id), id),
                format!("{} : {:?}", stringify!(type_id), type_id),
                format!("{} : {:?}", stringify!(key), key),
                format!("{} : {:?}", stringify!(label), label)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronCountersReaderForeachMetadataFuncLogger {}
unsafe impl Sync for AeronCountersReaderForeachMetadataFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_counters_reader_foreach_metadata_func_handler(
    ) -> Option<&'static Handler<AeronCountersReaderForeachMetadataFuncLogger>> {
        None::<&Handler<AeronCountersReaderForeachMetadataFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_counters_reader_foreach_metadata_func_t_callback<
    F: AeronCountersReaderForeachMetadataFuncCallback,
>(
    id: i32,
    type_id: i32,
    key: *const u8,
    key_length: usize,
    label: *const u8,
    label_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_counters_reader_foreach_metadata_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_counters_reader_foreach_metadata_func(
        id.into(),
        type_id.into(),
        if key.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(key, key_length)
        },
        if label.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(label, label_length)
        },
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_counters_reader_foreach_metadata_func_t_callback_for_once_closure<
    F: FnMut(i32, i32, &[u8], &[u8]) -> (),
>(
    id: i32,
    type_id: i32,
    key: *const u8,
    key_length: usize,
    label: *const u8,
    label_length: usize,
    clientd: *mut ::std::os::raw::c_void,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_counters_reader_foreach_metadata_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        id.into(),
        type_id.into(),
        if key.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(key, key_length)
        },
        if label.is_null() {
            &[] as &[_]
        } else {
            std::slice::from_raw_parts(label, label_length)
        },
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronDutyCycleTrackerUpdateFuncCallback {
    fn handle_aeron_duty_cycle_tracker_update_func(&mut self, now_ns: i64) -> ();
}
pub struct AeronDutyCycleTrackerUpdateFuncLogger;
impl AeronDutyCycleTrackerUpdateFuncCallback for AeronDutyCycleTrackerUpdateFuncLogger {
    fn handle_aeron_duty_cycle_tracker_update_func(&mut self, now_ns: i64) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_duty_cycle_tracker_update_func),
            [format!("{} : {:?}", stringify!(now_ns), now_ns)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronDutyCycleTrackerUpdateFuncLogger {}
unsafe impl Sync for AeronDutyCycleTrackerUpdateFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_duty_cycle_tracker_update_func_handler(
    ) -> Option<&'static Handler<AeronDutyCycleTrackerUpdateFuncLogger>> {
        None::<&Handler<AeronDutyCycleTrackerUpdateFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_duty_cycle_tracker_update_func_t_callback<
    F: AeronDutyCycleTrackerUpdateFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_duty_cycle_tracker_update_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_duty_cycle_tracker_update_func(now_ns.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_duty_cycle_tracker_update_func_t_callback_for_once_closure<
    F: FnMut(i64) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_duty_cycle_tracker_update_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(now_ns.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronDutyCycleTrackerMeasureAndUpdateFuncCallback {
    fn handle_aeron_duty_cycle_tracker_measure_and_update_func(&mut self, now_ns: i64) -> ();
}
pub struct AeronDutyCycleTrackerMeasureAndUpdateFuncLogger;
impl AeronDutyCycleTrackerMeasureAndUpdateFuncCallback
    for AeronDutyCycleTrackerMeasureAndUpdateFuncLogger
{
    fn handle_aeron_duty_cycle_tracker_measure_and_update_func(&mut self, now_ns: i64) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_duty_cycle_tracker_measure_and_update_func),
            [format!("{} : {:?}", stringify!(now_ns), now_ns)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronDutyCycleTrackerMeasureAndUpdateFuncLogger {}
unsafe impl Sync for AeronDutyCycleTrackerMeasureAndUpdateFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_duty_cycle_tracker_measure_and_update_func_handler(
    ) -> Option<&'static Handler<AeronDutyCycleTrackerMeasureAndUpdateFuncLogger>> {
        None::<&Handler<AeronDutyCycleTrackerMeasureAndUpdateFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_duty_cycle_tracker_measure_and_update_func_t_callback<
    F: AeronDutyCycleTrackerMeasureAndUpdateFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_duty_cycle_tracker_measure_and_update_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_duty_cycle_tracker_measure_and_update_func(now_ns.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_duty_cycle_tracker_measure_and_update_func_t_callback_for_once_closure<
    F: FnMut(i64) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    now_ns: i64,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(
                aeron_duty_cycle_tracker_measure_and_update_func_t_callback_for_once_closure
            )
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(now_ns.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronInt64CounterMapForEachFuncCallback {
    fn handle_aeron_int64_counter_map_for_each_func(&mut self, key: i64, value: i64) -> ();
}
pub struct AeronInt64CounterMapForEachFuncLogger;
impl AeronInt64CounterMapForEachFuncCallback for AeronInt64CounterMapForEachFuncLogger {
    fn handle_aeron_int64_counter_map_for_each_func(&mut self, key: i64, value: i64) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_int64_counter_map_for_each_func),
            [
                format!("{} : {:?}", stringify!(key), key),
                format!("{} : {:?}", stringify!(value), value)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronInt64CounterMapForEachFuncLogger {}
unsafe impl Sync for AeronInt64CounterMapForEachFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_int64_counter_map_for_each_func_handler(
    ) -> Option<&'static Handler<AeronInt64CounterMapForEachFuncLogger>> {
        None::<&Handler<AeronInt64CounterMapForEachFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_int64_counter_map_for_each_func_t_callback<
    F: AeronInt64CounterMapForEachFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    key: i64,
    value: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_int64_counter_map_for_each_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_int64_counter_map_for_each_func(key.into(), value.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_int64_counter_map_for_each_func_t_callback_for_once_closure<
    F: FnMut(i64, i64) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    key: i64,
    value: i64,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_int64_counter_map_for_each_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(key.into(), value.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronInt64CounterMapPredicateFuncCallback {
    fn handle_aeron_int64_counter_map_predicate_func(&mut self, key: i64, value: i64) -> bool;
}
pub struct AeronInt64CounterMapPredicateFuncLogger;
impl AeronInt64CounterMapPredicateFuncCallback for AeronInt64CounterMapPredicateFuncLogger {
    fn handle_aeron_int64_counter_map_predicate_func(&mut self, key: i64, value: i64) -> bool {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_int64_counter_map_predicate_func),
            [
                format!("{} : {:?}", stringify!(key), key),
                format!("{} : {:?}", stringify!(value), value)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronInt64CounterMapPredicateFuncLogger {}
unsafe impl Sync for AeronInt64CounterMapPredicateFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_int64_counter_map_predicate_func_handler(
    ) -> Option<&'static Handler<AeronInt64CounterMapPredicateFuncLogger>> {
        None::<&Handler<AeronInt64CounterMapPredicateFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_int64_counter_map_predicate_func_t_callback<
    F: AeronInt64CounterMapPredicateFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    key: i64,
    value: i64,
) -> bool {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_int64_counter_map_predicate_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_int64_counter_map_predicate_func(key.into(), value.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_int64_counter_map_predicate_func_t_callback_for_once_closure<
    F: FnMut(i64, i64) -> bool,
>(
    clientd: *mut ::std::os::raw::c_void,
    key: i64,
    value: i64,
) -> bool {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_int64_counter_map_predicate_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(key.into(), value.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronPortManagerGetManagedPortFuncCallback {
    fn handle_aeron_port_manager_get_managed_port_func(
        &mut self,
        bind_addr_out: SockaddrStorage,
        udp_channel: AeronUdpChannel,
        bind_addr: SockaddrStorage,
    ) -> ::std::os::raw::c_int;
}
pub struct AeronPortManagerGetManagedPortFuncLogger;
impl AeronPortManagerGetManagedPortFuncCallback for AeronPortManagerGetManagedPortFuncLogger {
    fn handle_aeron_port_manager_get_managed_port_func(
        &mut self,
        bind_addr_out: SockaddrStorage,
        udp_channel: AeronUdpChannel,
        bind_addr: SockaddrStorage,
    ) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_port_manager_get_managed_port_func),
            [
                format!("{} : {:?}", stringify!(bind_addr_out), bind_addr_out),
                format!("{} : {:?}", stringify!(udp_channel), udp_channel),
                format!("{} : {:?}", stringify!(bind_addr), bind_addr)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronPortManagerGetManagedPortFuncLogger {}
unsafe impl Sync for AeronPortManagerGetManagedPortFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_port_manager_get_managed_port_func_handler(
    ) -> Option<&'static Handler<AeronPortManagerGetManagedPortFuncLogger>> {
        None::<&Handler<AeronPortManagerGetManagedPortFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_port_manager_get_managed_port_func_t_callback<
    F: AeronPortManagerGetManagedPortFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    bind_addr_out: *mut sockaddr_storage,
    udp_channel: *mut aeron_udp_channel_t,
    bind_addr: *mut sockaddr_storage,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_port_manager_get_managed_port_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_port_manager_get_managed_port_func(
        bind_addr_out.into(),
        udp_channel.into(),
        bind_addr.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_port_manager_get_managed_port_func_t_callback_for_once_closure<
    F: FnMut(SockaddrStorage, AeronUdpChannel, SockaddrStorage) -> ::std::os::raw::c_int,
>(
    state: *mut ::std::os::raw::c_void,
    bind_addr_out: *mut sockaddr_storage,
    udp_channel: *mut aeron_udp_channel_t,
    bind_addr: *mut sockaddr_storage,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_port_manager_get_managed_port_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(bind_addr_out.into(), udp_channel.into(), bind_addr.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronPortManagerFreeManagedPortFuncCallback {
    fn handle_aeron_port_manager_free_managed_port_func(
        &mut self,
        bind_addr: SockaddrStorage,
    ) -> ();
}
pub struct AeronPortManagerFreeManagedPortFuncLogger;
impl AeronPortManagerFreeManagedPortFuncCallback for AeronPortManagerFreeManagedPortFuncLogger {
    fn handle_aeron_port_manager_free_managed_port_func(
        &mut self,
        bind_addr: SockaddrStorage,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_port_manager_free_managed_port_func),
            [format!("{} : {:?}", stringify!(bind_addr), bind_addr)].join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronPortManagerFreeManagedPortFuncLogger {}
unsafe impl Sync for AeronPortManagerFreeManagedPortFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_port_manager_free_managed_port_func_handler(
    ) -> Option<&'static Handler<AeronPortManagerFreeManagedPortFuncLogger>> {
        None::<&Handler<AeronPortManagerFreeManagedPortFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_port_manager_free_managed_port_func_t_callback<
    F: AeronPortManagerFreeManagedPortFuncCallback,
>(
    state: *mut ::std::os::raw::c_void,
    bind_addr: *mut sockaddr_storage,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_port_manager_free_managed_port_func)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure.handle_aeron_port_manager_free_managed_port_func(bind_addr.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_port_manager_free_managed_port_func_t_callback_for_once_closure<
    F: FnMut(SockaddrStorage) -> (),
>(
    state: *mut ::std::os::raw::c_void,
    bind_addr: *mut sockaddr_storage,
) -> () {
    #[cfg(debug_assertions)]
    if state.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_port_manager_free_managed_port_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(state as *mut F);
    closure(bind_addr.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronExecutorExecutionCompleteFuncCallback {
    fn handle_aeron_executor_on_execution_complete_func(
        &mut self,
        task: *mut aeron_executor_task_t,
    ) -> ::std::os::raw::c_int;
}
pub struct AeronExecutorExecutionCompleteFuncLogger;
impl AeronExecutorExecutionCompleteFuncCallback for AeronExecutorExecutionCompleteFuncLogger {
    fn handle_aeron_executor_on_execution_complete_func(
        &mut self,
        task: *mut aeron_executor_task_t,
    ) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_executor_on_execution_complete_func),
            [format!("{} : {:?}", stringify!(task), task)].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronExecutorExecutionCompleteFuncLogger {}
unsafe impl Sync for AeronExecutorExecutionCompleteFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_executor_execution_complete_func_handler(
    ) -> Option<&'static Handler<AeronExecutorExecutionCompleteFuncLogger>> {
        None::<&Handler<AeronExecutorExecutionCompleteFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_executor_on_execution_complete_func_t_callback<
    F: AeronExecutorExecutionCompleteFuncCallback,
>(
    task: *mut aeron_executor_task_t,
    executor_clientd: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if executor_clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_executor_on_execution_complete_func)
        );
    }
    let closure: &mut F = &mut *(executor_clientd as *mut F);
    closure.handle_aeron_executor_on_execution_complete_func(task.into())
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_executor_on_execution_complete_func_t_callback_for_once_closure<
    F: FnMut(*mut aeron_executor_task_t) -> ::std::os::raw::c_int,
>(
    task: *mut aeron_executor_task_t,
    executor_clientd: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if executor_clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_executor_on_execution_complete_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(executor_clientd as *mut F);
    closure(task.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronUriHostnameResolverFuncCallback {
    fn handle_aeron_uri_hostname_resolver_func(
        &mut self,
        host: &str,
        hints: Addrinfo,
        info: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
pub struct AeronUriHostnameResolverFuncLogger;
impl AeronUriHostnameResolverFuncCallback for AeronUriHostnameResolverFuncLogger {
    fn handle_aeron_uri_hostname_resolver_func(
        &mut self,
        host: &str,
        hints: Addrinfo,
        info: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_uri_hostname_resolver_func),
            [
                format!("{} : {:?}", stringify!(host), host),
                format!("{} : {:?}", stringify!(hints), hints),
                format!("{} : {:?}", stringify!(info), info)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronUriHostnameResolverFuncLogger {}
unsafe impl Sync for AeronUriHostnameResolverFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_uri_hostname_resolver_func_handler(
    ) -> Option<&'static Handler<AeronUriHostnameResolverFuncLogger>> {
        None::<&Handler<AeronUriHostnameResolverFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_uri_hostname_resolver_func_t_callback<
    F: AeronUriHostnameResolverFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    host: *const ::std::os::raw::c_char,
    hints: *mut addrinfo,
    info: *mut *mut addrinfo,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_uri_hostname_resolver_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_uri_hostname_resolver_func(
        if host.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(host).to_str().unwrap() }
        },
        hints.into(),
        info.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_uri_hostname_resolver_func_t_callback_for_once_closure<
    F: FnMut(&str, Addrinfo, *mut *mut addrinfo) -> ::std::os::raw::c_int,
>(
    clientd: *mut ::std::os::raw::c_void,
    host: *const ::std::os::raw::c_char,
    hints: *mut addrinfo,
    info: *mut *mut addrinfo,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_uri_hostname_resolver_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if host.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(host).to_str().unwrap() }
        },
        hints.into(),
        info.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronIfaddrFuncCallback {
    fn handle_aeron_ifaddr_func(
        &mut self,
        name: &str,
        addr: Sockaddr,
        netmask: Sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub struct AeronIfaddrFuncLogger;
impl AeronIfaddrFuncCallback for AeronIfaddrFuncLogger {
    fn handle_aeron_ifaddr_func(
        &mut self,
        name: &str,
        addr: Sockaddr,
        netmask: Sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_ifaddr_func),
            [
                format!("{} : {:?}", stringify!(name), name),
                format!("{} : {:?}", stringify!(addr), addr),
                format!("{} : {:?}", stringify!(netmask), netmask),
                format!("{} : {:?}", stringify!(flags), flags)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronIfaddrFuncLogger {}
unsafe impl Sync for AeronIfaddrFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_ifaddr_func_handler() -> Option<&'static Handler<AeronIfaddrFuncLogger>> {
        None::<&Handler<AeronIfaddrFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_ifaddr_func_t_callback<F: AeronIfaddrFuncCallback>(
    clientd: *mut ::std::os::raw::c_void,
    name: *const ::std::os::raw::c_char,
    addr: *mut sockaddr,
    netmask: *mut sockaddr,
    flags: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!("calling {}", stringify!(handle_aeron_ifaddr_func));
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_ifaddr_func(
        if name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(name).to_str().unwrap() }
        },
        addr.into(),
        netmask.into(),
        flags.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_ifaddr_func_t_callback_for_once_closure<
    F: FnMut(&str, Sockaddr, Sockaddr, ::std::os::raw::c_uint) -> ::std::os::raw::c_int,
>(
    clientd: *mut ::std::os::raw::c_void,
    name: *const ::std::os::raw::c_char,
    addr: *mut sockaddr,
    netmask: *mut sockaddr,
    flags: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_ifaddr_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(
        if name.is_null() {
            ""
        } else {
            unsafe { std::ffi::CStr::from_ptr(name).to_str().unwrap() }
        },
        addr.into(),
        netmask.into(),
        flags.into(),
    )
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronRetransmitHandlerResendFuncCallback {
    fn handle_aeron_retransmit_handler_resend_func(
        &mut self,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
pub struct AeronRetransmitHandlerResendFuncLogger;
impl AeronRetransmitHandlerResendFuncCallback for AeronRetransmitHandlerResendFuncLogger {
    fn handle_aeron_retransmit_handler_resend_func(
        &mut self,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> ::std::os::raw::c_int {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_retransmit_handler_resend_func),
            [
                format!("{} : {:?}", stringify!(term_id), term_id),
                format!("{} : {:?}", stringify!(term_offset), term_offset),
                format!("{} : {:?}", stringify!(length), length)
            ]
            .join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronRetransmitHandlerResendFuncLogger {}
unsafe impl Sync for AeronRetransmitHandlerResendFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_retransmit_handler_resend_func_handler(
    ) -> Option<&'static Handler<AeronRetransmitHandlerResendFuncLogger>> {
        None::<&Handler<AeronRetransmitHandlerResendFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_retransmit_handler_resend_func_t_callback<
    F: AeronRetransmitHandlerResendFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    term_id: i32,
    term_offset: i32,
    length: usize,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_retransmit_handler_resend_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_retransmit_handler_resend_func(
        term_id.into(),
        term_offset.into(),
        length.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_retransmit_handler_resend_func_t_callback_for_once_closure<
    F: FnMut(i32, i32, usize) -> ::std::os::raw::c_int,
>(
    clientd: *mut ::std::os::raw::c_void,
    term_id: i32,
    term_offset: i32,
    length: usize,
) -> ::std::os::raw::c_int {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_retransmit_handler_resend_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(term_id.into(), term_offset.into(), length.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronTermGapScannerGapDetectedFuncCallback {
    fn handle_aeron_term_gap_scanner_on_gap_detected_func(
        &mut self,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> ();
}
pub struct AeronTermGapScannerGapDetectedFuncLogger;
impl AeronTermGapScannerGapDetectedFuncCallback for AeronTermGapScannerGapDetectedFuncLogger {
    fn handle_aeron_term_gap_scanner_on_gap_detected_func(
        &mut self,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> () {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_term_gap_scanner_on_gap_detected_func),
            [
                format!("{} : {:?}", stringify!(term_id), term_id),
                format!("{} : {:?}", stringify!(term_offset), term_offset),
                format!("{} : {:?}", stringify!(length), length)
            ]
            .join(",\n\t"),
        );
        ()
    }
}
unsafe impl Send for AeronTermGapScannerGapDetectedFuncLogger {}
unsafe impl Sync for AeronTermGapScannerGapDetectedFuncLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_term_gap_scanner_gap_detected_func_handler(
    ) -> Option<&'static Handler<AeronTermGapScannerGapDetectedFuncLogger>> {
        None::<&Handler<AeronTermGapScannerGapDetectedFuncLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_term_gap_scanner_on_gap_detected_func_t_callback<
    F: AeronTermGapScannerGapDetectedFuncCallback,
>(
    clientd: *mut ::std::os::raw::c_void,
    term_id: i32,
    term_offset: i32,
    length: usize,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_term_gap_scanner_on_gap_detected_func)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure.handle_aeron_term_gap_scanner_on_gap_detected_func(
        term_id.into(),
        term_offset.into(),
        length.into(),
    )
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_term_gap_scanner_on_gap_detected_func_t_callback_for_once_closure<
    F: FnMut(i32, i32, usize) -> (),
>(
    clientd: *mut ::std::os::raw::c_void,
    term_id: i32,
    term_offset: i32,
    length: usize,
) -> () {
    #[cfg(debug_assertions)]
    if clientd.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_term_gap_scanner_on_gap_detected_func_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(clientd as *mut F);
    closure(term_id.into(), term_offset.into(), length.into())
}
#[doc = r""]
#[doc = r""]
#[doc = r" _(note you must copy any arguments that you use afterwards even those with static lifetimes)_"]
pub trait AeronEndOfLifeResourceFreeCallback {
    fn handle_aeron_end_of_life_resource_free(&mut self) -> bool;
}
pub struct AeronEndOfLifeResourceFreeLogger;
impl AeronEndOfLifeResourceFreeCallback for AeronEndOfLifeResourceFreeLogger {
    fn handle_aeron_end_of_life_resource_free(&mut self) -> bool {
        log::info!(
            "{}(\n\t{}\n)",
            stringify!(handle_aeron_end_of_life_resource_free),
            [""].join(",\n\t"),
        );
        unimplemented!()
    }
}
unsafe impl Send for AeronEndOfLifeResourceFreeLogger {}
unsafe impl Sync for AeronEndOfLifeResourceFreeLogger {}
impl Handlers {
    #[doc = r" No handler is set i.e. None with correct type"]
    pub fn no_end_of_life_resource_free_handler(
    ) -> Option<&'static Handler<AeronEndOfLifeResourceFreeLogger>> {
        None::<&Handler<AeronEndOfLifeResourceFreeLogger>>
    }
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_end_of_life_resource_free_t_callback<
    F: AeronEndOfLifeResourceFreeCallback,
>(
    resource: *mut ::std::os::raw::c_void,
) -> bool {
    #[cfg(debug_assertions)]
    if resource.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(handle_aeron_end_of_life_resource_free)
        );
    }
    let closure: &mut F = &mut *(resource as *mut F);
    closure.handle_aeron_end_of_life_resource_free()
}
#[allow(dead_code)]
unsafe extern "C" fn aeron_end_of_life_resource_free_t_callback_for_once_closure<
    F: FnMut() -> bool,
>(
    resource: *mut ::std::os::raw::c_void,
) -> bool {
    #[cfg(debug_assertions)]
    if resource.is_null() {
        unimplemented!("closure should not be null")
    }
    #[cfg(feature = "extra-logging")]
    {
        log::debug!(
            "calling {}",
            stringify!(aeron_end_of_life_resource_free_t_callback_for_once_closure)
        );
    }
    let closure: &mut F = &mut *(resource as *mut F);
    closure()
}
