/* automatically generated by rust-bindgen 0.72.0 */

pub const AERON_NULL_VALUE: i32 = -1;
pub const AERON_CLIENT_ERROR_DRIVER_TIMEOUT: i32 = -1000;
pub const AERON_CLIENT_ERROR_CLIENT_TIMEOUT: i32 = -1001;
pub const AERON_CLIENT_ERROR_CONDUCTOR_SERVICE_TIMEOUT: i32 = -1002;
pub const AERON_CLIENT_ERROR_BUFFER_FULL: i32 = -1003;
pub const AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN: u32 = 64;
pub const AERON_RESPONSE_ADDRESS_TYPE_IPV4: u32 = 1;
pub const AERON_RESPONSE_ADDRESS_TYPE_IPV6: u32 = 2;
pub const AERON_DIR_ENV_VAR: &[u8; 10] = b"AERON_DIR\0";
pub const AERON_DRIVER_TIMEOUT_ENV_VAR: &[u8; 21] = b"AERON_DRIVER_TIMEOUT\0";
pub const AERON_CLIENT_RESOURCE_LINGER_DURATION_ENV_VAR: &[u8; 38] =
    b"AERON_CLIENT_RESOURCE_LINGER_DURATION\0";
pub const AERON_CLIENT_IDLE_SLEEP_DURATION_ENV_VAR: &[u8; 33] =
    b"AERON_CLIENT_IDLE_SLEEP_DURATION\0";
pub const AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY_ENV_VAR: &[u8; 37] =
    b"AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY\0";
pub const AERON_CLIENT_NAME_ENV_VAR: &[u8; 18] = b"AERON_CLIENT_NAME\0";
pub const AERON_AGENT_ON_START_FUNCTION_ENV_VAR: &[u8; 30] = b"AERON_AGENT_ON_START_FUNCTION\0";
pub const AERON_COUNTER_CACHE_LINE_LENGTH: u32 = 64;
pub const AERON_COUNTER_MAX_CLIENT_NAME_LENGTH: u32 = 100;
pub const AERON_COUNTER_RECORD_UNUSED: u32 = 0;
pub const AERON_COUNTER_RECORD_ALLOCATED: u32 = 1;
pub const AERON_COUNTER_RECORD_RECLAIMED: i32 = -1;
pub const AERON_COUNTER_NOT_FREE_TO_REUSE: u64 = 9223372036854775807;
pub const AERON_NULL_COUNTER_ID: i32 = -1;
pub const AERON_PUBLICATION_NOT_CONNECTED: i32 = -1;
pub const AERON_PUBLICATION_BACK_PRESSURED: i32 = -2;
pub const AERON_PUBLICATION_ADMIN_ACTION: i32 = -3;
pub const AERON_PUBLICATION_CLOSED: i32 = -4;
pub const AERON_PUBLICATION_MAX_POSITION_EXCEEDED: i32 = -5;
pub const AERON_PUBLICATION_ERROR: i32 = -6;
pub const AERON_MAX_PATH: u32 = 4096;
pub const AERON_NULL_POSITION: i32 = -1;
pub const AERON_ARCHIVE_PROXY_REQUEST_BUFFER_LENGTH: u32 = 8192;
pub const AERON_ARCHIVE_PROXY_RETRY_ATTEMPTS_DEFAULT: u32 = 3;
pub const AERON_ARCHIVE_CONTROL_RESPONSE_POLLER_FRAGMENT_LIMIT_DEFAULT: u32 = 10;
pub const AERON_ARCHIVE_RECORDING_DESCRIPTOR_POLLER_FRAGMENT_LIMIT_DEFAULT: u32 = 10;
pub const AERON_ARCHIVE_RECORDING_SUBSCRIPTION_DESCRIPTOR_POLLER_FRAGMENT_LIMIT_DEFAULT: u32 = 10;
pub const AERON_COMPILER_GCC: u32 = 1;
pub const AERON_COMPILER_LLVM: u32 = 1;
pub const AERON_CPU_ARM: u32 = 1;
pub const AERON_SPY_PREFIX: &[u8; 11] = b"aeron-spy:\0";
pub const AERON_IPC_CHANNEL: &[u8; 10] = b"aeron:ipc\0";
pub const AERON_UDP_CHANNEL_RELIABLE_KEY: &[u8; 9] = b"reliable\0";
pub const AERON_UDP_CHANNEL_TTL_KEY: &[u8; 4] = b"ttl\0";
pub const AERON_UDP_CHANNEL_ENDPOINT_KEY: &[u8; 9] = b"endpoint\0";
pub const AERON_UDP_CHANNEL_INTERFACE_KEY: &[u8; 10] = b"interface\0";
pub const AERON_UDP_CHANNEL_CONTROL_KEY: &[u8; 8] = b"control\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_KEY: &[u8; 13] = b"control-mode\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_MANUAL_VALUE: &[u8; 7] = b"manual\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_DYNAMIC_VALUE: &[u8; 8] = b"dynamic\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_RESPONSE_VALUE: &[u8; 9] = b"response\0";
pub const AERON_URI_INITIAL_TERM_ID_KEY: &[u8; 13] = b"init-term-id\0";
pub const AERON_URI_TERM_ID_KEY: &[u8; 8] = b"term-id\0";
pub const AERON_URI_TERM_OFFSET_KEY: &[u8; 12] = b"term-offset\0";
pub const AERON_URI_ALIAS_KEY: &[u8; 6] = b"alias\0";
pub const AERON_URI_TERM_LENGTH_KEY: &[u8; 12] = b"term-length\0";
pub const AERON_URI_LINGER_TIMEOUT_KEY: &[u8; 7] = b"linger\0";
pub const AERON_URI_MTU_LENGTH_KEY: &[u8; 4] = b"mtu\0";
pub const AERON_URI_SPARSE_TERM_KEY: &[u8; 7] = b"sparse\0";
pub const AERON_URI_EOS_KEY: &[u8; 4] = b"eos\0";
pub const AERON_URI_TETHER_KEY: &[u8; 7] = b"tether\0";
pub const AERON_URI_TAGS_KEY: &[u8; 5] = b"tags\0";
pub const AERON_URI_SESSION_ID_KEY: &[u8; 11] = b"session-id\0";
pub const AERON_URI_GROUP_KEY: &[u8; 6] = b"group\0";
pub const AERON_URI_REJOIN_KEY: &[u8; 7] = b"rejoin\0";
pub const AERON_URI_FC_KEY: &[u8; 3] = b"fc\0";
pub const AERON_URI_GTAG_KEY: &[u8; 5] = b"gtag\0";
pub const AERON_URI_CC_KEY: &[u8; 3] = b"cc\0";
pub const AERON_URI_SPIES_SIMULATE_CONNECTION_KEY: &[u8; 4] = b"ssc\0";
pub const AERON_URI_ATS_KEY: &[u8; 4] = b"ats\0";
pub const AERON_URI_SOCKET_SNDBUF_KEY: &[u8; 10] = b"so-sndbuf\0";
pub const AERON_URI_SOCKET_RCVBUF_KEY: &[u8; 10] = b"so-rcvbuf\0";
pub const AERON_URI_RECEIVER_WINDOW_KEY: &[u8; 8] = b"rcv-wnd\0";
pub const AERON_URI_MEDIA_RCV_TIMESTAMP_OFFSET_KEY: &[u8; 20] = b"media-rcv-ts-offset\0";
pub const AERON_URI_CHANNEL_RCV_TIMESTAMP_OFFSET_KEY: &[u8; 22] = b"channel-rcv-ts-offset\0";
pub const AERON_URI_CHANNEL_SND_TIMESTAMP_OFFSET_KEY: &[u8; 22] = b"channel-snd-ts-offset\0";
pub const AERON_URI_TIMESTAMP_OFFSET_RESERVED: &[u8; 9] = b"reserved\0";
pub const AERON_URI_RESPONSE_CORRELATION_ID_PROTOTYPE: &[u8; 10] = b"prototype\0";
pub const AERON_URI_RESPONSE_CORRELATION_ID_KEY: &[u8; 24] = b"response-correlation-id\0";
pub const AERON_URI_NAK_DELAY_KEY: &[u8; 10] = b"nak-delay\0";
pub const AERON_URI_UNTETHERED_WINDOW_LIMIT_TIMEOUT_KEY: &[u8; 32] =
    b"untethered-window-limit-timeout\0";
pub const AERON_URI_UNTETHERED_LINGER_TIMEOUT_KEY: &[u8; 26] = b"untethered-linger-timeout\0";
pub const AERON_URI_UNTETHERED_RESTING_TIMEOUT_KEY: &[u8; 27] = b"untethered-resting-timeout\0";
pub const AERON_URI_MAX_RESEND_KEY: &[u8; 11] = b"max-resend\0";
pub const AERON_URI_STREAM_ID_KEY: &[u8; 10] = b"stream-id\0";
pub const AERON_URI_PUBLICATION_WINDOW_KEY: &[u8; 8] = b"pub-wnd\0";
pub const AERON_URI_INVALID_TAG: i32 = -1;
pub const AERON_URI_MAX_LENGTH: u32 = 4096;
pub const AERON_CACHE_LINE_LENGTH: u32 = 64;
pub const AERON_FORMAT_DATE_MAX_LENGTH: u32 = 100;
pub const AERON_FORMAT_NUMBER_TO_LOCALE_STR_LEN: u32 = 32;
pub const AERON_ERROR_MAX_TOTAL_LENGTH: u32 = 8192;
pub const AERON_MAP_DEFAULT_LOAD_FACTOR: f64 = 0.65;
pub const AERON_URI_STRING_BUILDER_PREFIX_KEY: &[u8; 9] = b"__prefix\0";
pub const AERON_URI_STRING_BUILDER_MEDIA_KEY: &[u8; 8] = b"__media\0";
pub const AERON_RES_HEADER_ADDRESS_LENGTH_IP4: u32 = 4;
pub const AERON_RES_HEADER_ADDRESS_LENGTH_IP6: u32 = 16;
pub const AERON_FRAME_HEADER_VERSION: u32 = 0;
pub const AERON_RES_HEADER_TYPE_NAME_TO_IP4_MD: u32 = 1;
pub const AERON_RES_HEADER_TYPE_NAME_TO_IP6_MD: u32 = 2;
pub const AERON_FRAME_MAX_MESSAGE_LENGTH: u32 = 16777216;
pub const AERON_OPT_HDR_ALIGNMENT: u32 = 4;
pub const AERON_ERROR_MAX_TEXT_LENGTH: u32 = 1023;
pub const AERON_ERROR_HAS_GROUP_TAG_FLAG: u32 = 8;
pub const AERON_LOGBUFFER_PARTITION_COUNT: u32 = 3;
pub const AERON_LOGBUFFER_TERM_MIN_LENGTH: u32 = 65536;
pub const AERON_LOGBUFFER_TERM_MAX_LENGTH: u32 = 1073741824;
pub const AERON_LOGBUFFER_DEFAULT_FRAME_HEADER_MAX_LENGTH: u32 = 128;
pub const AERON_MAX_UDP_PAYLOAD_LENGTH: u32 = 65504;
pub const AERON_LOGBUFFER_FRAME_ALIGNMENT: u32 = 32;
pub const AERON_FILEUTIL_ERROR_ENOSPC: u32 = 28;
pub const AERON_PUBLICATIONS_DIR: &[u8; 13] = b"publications\0";
pub const AERON_IMAGES_DIR: &[u8; 7] = b"images\0";
pub const AERON_CNC_FILE: &[u8; 8] = b"cnc.dat\0";
pub const AERON_LOSS_REPORT_FILE: &[u8; 16] = b"loss-report.dat\0";
pub const AERON_LOSS_REPORTER_ENTRY_ALIGNMENT: u32 = 64;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_context_stct {
    _unused: [u8; 0],
}
pub type aeron_context_t = aeron_context_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_stct {
    _unused: [u8; 0],
}
pub type aeron_t = aeron_stct;
#[doc = " Structure used to hold information for a try_claim function call."]
pub type aeron_buffer_claim_t = aeron_buffer_claim_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_publication_stct {
    _unused: [u8; 0],
}
pub type aeron_publication_t = aeron_publication_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_exclusive_publication_stct {
    _unused: [u8; 0],
}
pub type aeron_exclusive_publication_t = aeron_exclusive_publication_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_header_stct {
    _unused: [u8; 0],
}
pub type aeron_header_t = aeron_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_header_values_frame_stct {
    pub frame_length: i32,
    pub version: i8,
    pub flags: u8,
    pub type_: i16,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub reserved_value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_header_values_frame_stct"]
        [::std::mem::size_of::<aeron_header_values_frame_stct>() - 32usize];
    ["Alignment of aeron_header_values_frame_stct"]
        [::std::mem::align_of::<aeron_header_values_frame_stct>() - 4usize];
    ["Offset of field: aeron_header_values_frame_stct::frame_length"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, frame_length) - 0usize];
    ["Offset of field: aeron_header_values_frame_stct::version"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, version) - 4usize];
    ["Offset of field: aeron_header_values_frame_stct::flags"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, flags) - 5usize];
    ["Offset of field: aeron_header_values_frame_stct::type_"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, type_) - 6usize];
    ["Offset of field: aeron_header_values_frame_stct::term_offset"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, term_offset) - 8usize];
    ["Offset of field: aeron_header_values_frame_stct::session_id"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, session_id) - 12usize];
    ["Offset of field: aeron_header_values_frame_stct::stream_id"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, stream_id) - 16usize];
    ["Offset of field: aeron_header_values_frame_stct::term_id"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, term_id) - 20usize];
    ["Offset of field: aeron_header_values_frame_stct::reserved_value"]
        [::std::mem::offset_of!(aeron_header_values_frame_stct, reserved_value) - 24usize];
};
pub type aeron_header_values_frame_t = aeron_header_values_frame_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_header_values_stct {
    pub frame: aeron_header_values_frame_t,
    pub initial_term_id: i32,
    pub position_bits_to_shift: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_header_values_stct"]
        [::std::mem::size_of::<aeron_header_values_stct>() - 44usize];
    ["Alignment of aeron_header_values_stct"]
        [::std::mem::align_of::<aeron_header_values_stct>() - 4usize];
    ["Offset of field: aeron_header_values_stct::frame"]
        [::std::mem::offset_of!(aeron_header_values_stct, frame) - 0usize];
    ["Offset of field: aeron_header_values_stct::initial_term_id"]
        [::std::mem::offset_of!(aeron_header_values_stct, initial_term_id) - 32usize];
    ["Offset of field: aeron_header_values_stct::position_bits_to_shift"]
        [::std::mem::offset_of!(aeron_header_values_stct, position_bits_to_shift) - 36usize];
};
pub type aeron_header_values_t = aeron_header_values_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_publication_error_values_stct {
    pub registration_id: i64,
    pub destination_registration_id: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub receiver_id: i64,
    pub group_tag: i64,
    pub address_type: i16,
    pub source_port: u16,
    pub source_address: [u8; 16usize],
    pub error_code: i32,
    pub error_message_length: i32,
    pub error_message: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_publication_error_values_stct"]
        [::std::mem::size_of::<aeron_publication_error_values_stct>() - 72usize];
    ["Alignment of aeron_publication_error_values_stct"]
        [::std::mem::align_of::<aeron_publication_error_values_stct>() - 4usize];
    ["Offset of field: aeron_publication_error_values_stct::registration_id"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, registration_id) - 0usize];
    ["Offset of field: aeron_publication_error_values_stct::destination_registration_id"][::std::mem::offset_of!(
        aeron_publication_error_values_stct,
        destination_registration_id
    )
        - 8usize];
    ["Offset of field: aeron_publication_error_values_stct::session_id"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, session_id) - 16usize];
    ["Offset of field: aeron_publication_error_values_stct::stream_id"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, stream_id) - 20usize];
    ["Offset of field: aeron_publication_error_values_stct::receiver_id"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, receiver_id) - 24usize];
    ["Offset of field: aeron_publication_error_values_stct::group_tag"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, group_tag) - 32usize];
    ["Offset of field: aeron_publication_error_values_stct::address_type"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, address_type) - 40usize];
    ["Offset of field: aeron_publication_error_values_stct::source_port"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, source_port) - 42usize];
    ["Offset of field: aeron_publication_error_values_stct::source_address"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, source_address) - 44usize];
    ["Offset of field: aeron_publication_error_values_stct::error_code"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, error_code) - 60usize];
    ["Offset of field: aeron_publication_error_values_stct::error_message_length"][::std::mem::offset_of!(
        aeron_publication_error_values_stct,
        error_message_length
    ) - 64usize];
    ["Offset of field: aeron_publication_error_values_stct::error_message"]
        [::std::mem::offset_of!(aeron_publication_error_values_stct, error_message) - 68usize];
};
pub type aeron_publication_error_values_t = aeron_publication_error_values_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_subscription_stct {
    _unused: [u8; 0],
}
pub type aeron_subscription_t = aeron_subscription_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_image_stct {
    _unused: [u8; 0],
}
pub type aeron_image_t = aeron_image_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_counter_stct {
    _unused: [u8; 0],
}
pub type aeron_counter_t = aeron_counter_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_log_buffer_stct {
    _unused: [u8; 0],
}
pub type aeron_log_buffer_t = aeron_log_buffer_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_counters_reader_stct {
    _unused: [u8; 0],
}
pub type aeron_counters_reader_t = aeron_counters_reader_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_client_registering_resource_stct {
    _unused: [u8; 0],
}
pub type aeron_async_add_publication_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_exclusive_publication_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_subscription_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_counter_t = aeron_client_registering_resource_stct;
pub type aeron_async_destination_t = aeron_client_registering_resource_stct;
pub type aeron_async_destination_by_id_t = aeron_client_registering_resource_stct;
pub type aeron_async_get_next_available_session_id_t = aeron_client_registering_resource_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_image_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_image_fragment_assembler_t = aeron_image_fragment_assembler_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_image_controlled_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_image_controlled_fragment_assembler_t =
    aeron_image_controlled_fragment_assembler_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_fragment_assembler_t = aeron_fragment_assembler_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_controlled_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_controlled_fragment_assembler_t = aeron_controlled_fragment_assembler_stct;
unsafe extern "C" {
    pub fn aeron_context_set_dir(
        context: *mut aeron_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_dir(context: *mut aeron_context_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn aeron_context_set_driver_timeout_ms(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_driver_timeout_ms(context: *mut aeron_context_t) -> u64;
}
unsafe extern "C" {
    pub fn aeron_context_set_keepalive_interval_ns(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_keepalive_interval_ns(context: *mut aeron_context_t) -> u64;
}
unsafe extern "C" {
    pub fn aeron_context_set_resource_linger_duration_ns(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_resource_linger_duration_ns(context: *mut aeron_context_t) -> u64;
}
unsafe extern "C" {
    pub fn aeron_context_get_idle_sleep_duration_ns(context: *mut aeron_context_t) -> u64;
}
unsafe extern "C" {
    pub fn aeron_context_set_idle_sleep_duration_ns(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_set_pre_touch_mapped_memory(
        context: *mut aeron_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_pre_touch_mapped_memory(context: *mut aeron_context_t) -> bool;
}
unsafe extern "C" {
    pub fn aeron_context_set_client_name(
        context: *mut aeron_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_client_name(
        context: *mut aeron_context_t,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " The error handler to be called when an error occurs."]
pub type aeron_error_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        errcode: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " The error frame handler to be called when the driver notifies the client about an error frame being received.\n The data passed to this callback will only be valid for the lifetime of the callback. The user should use\n <code>aeron_publication_error_values_copy</code> if they require the data to live longer than that."]
pub type aeron_publication_error_frame_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        error_frame: *mut aeron_publication_error_values_t,
    ),
>;
unsafe extern "C" {
    #[doc = " Copy an existing aeron_publication_error_values_t to the supplied pointer. The caller is responsible for freeing the\n allocated memory using aeron_publication_error_values_delete when the copy is not longer required.\n\n @param dst to copy the values to.\n @param src to copy the values from.\n @return 0 if this is successful, -1 otherwise. Will set aeron_errcode() and aeron_errmsg() on failure."]
    pub fn aeron_publication_error_values_copy(
        dst: *mut *mut aeron_publication_error_values_t,
        src: *mut aeron_publication_error_values_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a instance of aeron_publication_error_values_t that was created when making a copy\n (aeron_publication_error_values_copy). This should not be use on the pointer received via the aeron_frame_handler_t.\n @param to_delete to be deleted."]
    pub fn aeron_publication_error_values_delete(to_delete: *mut aeron_publication_error_values_t);
}
#[doc = " Generalised notification callback."]
pub type aeron_notification_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn aeron_context_set_error_handler(
        context: *mut aeron_context_t,
        handler: aeron_error_handler_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_error_handler(context: *mut aeron_context_t) -> aeron_error_handler_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_error_handler_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aeron_context_set_publication_error_frame_handler(
        context: *mut aeron_context_t,
        handler: aeron_publication_error_frame_handler_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_publication_error_frame_handler(
        context: *mut aeron_context_t,
    ) -> aeron_publication_error_frame_handler_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_publication_error_frame_handler_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t\n or aeron_exclusive_publication_t successfully.\n\n Implementations should do the minimum work for passing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original add publication call\n @param channel of the publication\n @param stream_id within the channel of the publication\n @param session_id of the publication\n @param correlation_id used by the publication"]
pub type aeron_on_new_publication_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        async_: *mut aeron_async_add_publication_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
        session_id: i32,
        correlation_id: i64,
    ),
>;
unsafe extern "C" {
    pub fn aeron_context_set_on_new_publication(
        context: *mut aeron_context_t,
        handler: aeron_on_new_publication_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_publication(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_publication_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_publication_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aeron_context_set_on_new_exclusive_publication(
        context: *mut aeron_context_t,
        handler: aeron_on_new_publication_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_exclusive_publication(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_publication_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_exclusive_publication_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t\n successfully.\n\n Implementations should do the minimum work for handing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original aeron_add_async_subscription call\n @param channel of the subscription\n @param stream_id within the channel of the subscription\n @param session_id of the subscription\n @param correlation_id used by the subscription"]
pub type aeron_on_new_subscription_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        async_: *mut aeron_async_add_subscription_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
        correlation_id: i64,
    ),
>;
unsafe extern "C" {
    pub fn aeron_context_set_on_new_subscription(
        context: *mut aeron_context_t,
        handler: aeron_on_new_subscription_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_subscription(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_subscription_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_new_subscription_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t was added.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become available."]
pub type aeron_on_available_image_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ),
>;
#[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and\n should not be used any longer.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become unavailable."]
pub type aeron_on_unavailable_image_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ),
>;
#[doc = " Function called by aeron_client_t to deliver notifications that a counter has been added to the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
pub type aeron_on_available_counter_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        counters_reader: *mut aeron_counters_reader_t,
        registration_id: i64,
        counter_id: i32,
    ),
>;
unsafe extern "C" {
    pub fn aeron_context_set_on_available_counter(
        context: *mut aeron_context_t,
        handler: aeron_on_available_counter_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_available_counter(
        context: *mut aeron_context_t,
    ) -> aeron_on_available_counter_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_available_counter_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
pub type aeron_on_unavailable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        counters_reader: *mut aeron_counters_reader_t,
        registration_id: i64,
        counter_id: i32,
    ),
>;
unsafe extern "C" {
    pub fn aeron_context_set_on_unavailable_counter(
        context: *mut aeron_context_t,
        handler: aeron_on_unavailable_counter_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_unavailable_counter(
        context: *mut aeron_context_t,
    ) -> aeron_on_unavailable_counter_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_unavailable_counter_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that the client is closing.\n\n @param clientd to be returned in the call."]
pub type aeron_on_close_client_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn aeron_context_set_on_close_client(
        context: *mut aeron_context_t,
        handler: aeron_on_close_client_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_close_client(
        context: *mut aeron_context_t,
    ) -> aeron_on_close_client_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_on_close_client_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Whether to use an invoker to control the conductor agent or spawn a thread."]
    pub fn aeron_context_set_use_conductor_agent_invoker(
        context: *mut aeron_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_use_conductor_agent_invoker(context: *mut aeron_context_t) -> bool;
}
pub type aeron_agent_on_start_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        role_name: *const ::std::os::raw::c_char,
    ),
>;
unsafe extern "C" {
    pub fn aeron_context_set_agent_on_start_function(
        context: *mut aeron_context_t,
        value: aeron_agent_on_start_func_t,
        state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_context_get_agent_on_start_function(
        context: *mut aeron_context_t,
    ) -> aeron_agent_on_start_func_t;
}
unsafe extern "C" {
    pub fn aeron_context_get_agent_on_start_state(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Create a aeron_context_t struct and initialize with default values.\n\n @param context to create and initialize\n @return 0 for success and -1 for error."]
    pub fn aeron_context_init(context: *mut *mut aeron_context_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close and delete aeron_context_t struct.\n\n @param context to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_context_close(context: *mut aeron_context_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a aeron_t client struct and initialize from the aeron_context_t struct.\n\n The given aeron_context_t struct will be used exclusively by the client. Do not reuse between clients.\n\n @param aeron  client to create and initialize.\n @param context to use for initialization.\n @return 0 for success and -1 for error."]
    pub fn aeron_init(
        client: *mut *mut aeron_t,
        context: *mut aeron_context_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start an aeron_t. This may spawn a thread for the Client Conductor.\n\n @param client to start.\n @return 0 for success and -1 for error."]
    pub fn aeron_start(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Call the Conductor main do_work duty cycle once.\n\n Client must have been created with use conductor invoker set to true.\n\n @param client to call do_work duty cycle on.\n @return 0 for success and -1 for error."]
    pub fn aeron_main_do_work(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Call the Conductor Idle Strategy.\n\n @param client to idle.\n @param work_count to pass to idle strategy."]
    pub fn aeron_main_idle_strategy(client: *mut aeron_t, work_count: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Close and delete aeron_t struct.\n\n @param client to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_close(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Determines if the client has been closed, e.g. via a driver timeout. Don't call this method after calling\n aeron_close as that will have already freed the associated memory.\n\n @param client to check if closed.\n @return true if it has been closed, false otherwise."]
    pub fn aeron_is_closed(client: *mut aeron_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Call stream_out to print the counter labels and values.\n\n @param client to get the counters from.\n @param stream_out to call for each label and value."]
    pub fn aeron_print_counters(
        client: *mut aeron_t,
        stream_out: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Return the aeron_context_t that is in use by the given client.\n\n @param client to return the aeron_context_t for.\n @return the aeron_context_t for the given client or NULL for an error."]
    pub fn aeron_context(client: *mut aeron_t) -> *mut aeron_context_t;
}
unsafe extern "C" {
    #[doc = " Return the client id in use by the client.\n\n @param client to return the client id for.\n @return id value or -1 for an error."]
    pub fn aeron_client_id(client: *mut aeron_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Return a unique correlation id from the driver.\n\n @param client to use to get the id.\n @return unique correlation id or -1 for an error."]
    pub fn aeron_next_correlation_id(client: *mut aeron_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Asynchronously request next available session from the media driver. The session id will be unique for the\n connected media driver and given {@code stream_id}.\n\n @param async object to use for polling completion.\n @param client connected to the media driver.\n @param stream_id for which a new session id is requested. Media driver only checks for session clashes at the\n                 stream level.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_next_session_id(
        async_: *mut *mut aeron_async_get_next_available_session_id_t,
        client: *mut aeron_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the aeron_async_next_session_id call.\n\n @param next_session_id to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_next_session_id_poll(
        next_session_id: *mut i32,
        async_: *mut aeron_async_get_next_available_session_id_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously add a publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_publication(
        async_: *mut *mut aeron_async_add_publication_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_publication_poll(
        publication: *mut *mut aeron_publication_t,
        async_: *mut aeron_async_add_publication_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously add an exclusive publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_exclusive_publication(
        async_: *mut *mut aeron_async_add_exclusive_publication_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_exclusive_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_exclusive_publication_poll(
        publication: *mut *mut aeron_exclusive_publication_t,
        async_: *mut aeron_async_add_exclusive_publication_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously add a subscription using the given client and return an object to use to determine when the\n subscription is available.\n\n @param async object to use for polling completion.\n @param client to add the subscription to.\n @param uri for the channel of the subscription.\n @param stream_id for the subscription.\n @param on_available_image_handler to be called when images become available on the subscription.\n @param on_available_image_clientd to be passed when images become available on the subscription.\n @param on_unavailable_image_handler to be called when images go unavailable on the subscription.\n @param on_unavailable_image_clientd to be passed when images go unavailable on the subscription.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_subscription(
        async_: *mut *mut aeron_async_add_subscription_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
        on_available_image_handler: aeron_on_available_image_t,
        on_available_image_clientd: *mut ::std::os::raw::c_void,
        on_unavailable_image_handler: aeron_on_unavailable_image_t,
        on_unavailable_image_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_subscription call.\n\n @param subscription to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_subscription_poll(
        subscription: *mut *mut aeron_subscription_t,
        async_: *mut aeron_async_add_subscription_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return a reference to the counters reader of the given client.\n\n The aeron_counters_reader_t is maintained by the client. And should not be freed.\n\n @param client that contains the counters reader.\n @return aeron_counters_reader_t or NULL for error."]
    pub fn aeron_counters_reader(client: *mut aeron_t) -> *mut aeron_counters_reader_t;
}
unsafe extern "C" {
    #[doc = " Asynchronously add a counter using the given client and return an object to use to determine when the\n counter is available.\n\n @param async object to use for polling completion.\n @param client to add the counter to.\n @param type_id for the counter.\n @param key_buffer for the counter.\n @param key_buffer_length for the counter.\n @param label_buffer for the counter.\n @param label_buffer_length for the counter.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_counter(
        async_: *mut *mut aeron_async_add_counter_t,
        client: *mut aeron_t,
        type_id: i32,
        key_buffer: *const u8,
        key_buffer_length: usize,
        label_buffer: *const ::std::os::raw::c_char,
        label_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the <code>aeron_async_add_counter</code> or <code>aeron_async_add_static_counter</code> calls.\n\n @param counter to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_counter_poll(
        counter: *mut *mut aeron_counter_t,
        async_: *mut aeron_async_add_counter_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously allocates or returns an existing static counter instance using specified <code>type_id</code> and\n <code>registration_id</code>. Such counter cannot be deleted and its lifecycle is decoupled from the client that created it.\n Returns an object to use to determine when the counter is available.\n\n @param async object to use for polling completion.\n @param client to add the counter to.\n @param type_id for the counter.\n @param key_buffer for the counter.\n @param key_buffer_length for the counter.\n @param label_buffer for the counter.\n @param label_buffer_length for the counter.\n @param registration_id that uniquely identifies the counter.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_static_counter(
        async_: *mut *mut aeron_async_add_counter_t,
        client: *mut aeron_t,
        type_id: i32,
        key_buffer: *const u8,
        key_buffer_length: usize,
        label_buffer: *const ::std::os::raw::c_char,
        label_buffer_length: usize,
        registration_id: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_on_available_counter_pair_stct {
    pub handler: aeron_on_available_counter_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_on_available_counter_pair_stct"]
        [::std::mem::size_of::<aeron_on_available_counter_pair_stct>() - 16usize];
    ["Alignment of aeron_on_available_counter_pair_stct"]
        [::std::mem::align_of::<aeron_on_available_counter_pair_stct>() - 8usize];
    ["Offset of field: aeron_on_available_counter_pair_stct::handler"]
        [::std::mem::offset_of!(aeron_on_available_counter_pair_stct, handler) - 0usize];
    ["Offset of field: aeron_on_available_counter_pair_stct::clientd"]
        [::std::mem::offset_of!(aeron_on_available_counter_pair_stct, clientd) - 8usize];
};
impl Default for aeron_on_available_counter_pair_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_on_available_counter_pair_t = aeron_on_available_counter_pair_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_on_unavailable_counter_pair_stct {
    pub handler: aeron_on_unavailable_counter_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_on_unavailable_counter_pair_stct"]
        [::std::mem::size_of::<aeron_on_unavailable_counter_pair_stct>() - 16usize];
    ["Alignment of aeron_on_unavailable_counter_pair_stct"]
        [::std::mem::align_of::<aeron_on_unavailable_counter_pair_stct>() - 8usize];
    ["Offset of field: aeron_on_unavailable_counter_pair_stct::handler"]
        [::std::mem::offset_of!(aeron_on_unavailable_counter_pair_stct, handler) - 0usize];
    ["Offset of field: aeron_on_unavailable_counter_pair_stct::clientd"]
        [::std::mem::offset_of!(aeron_on_unavailable_counter_pair_stct, clientd) - 8usize];
};
impl Default for aeron_on_unavailable_counter_pair_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_on_unavailable_counter_pair_t = aeron_on_unavailable_counter_pair_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_on_close_client_pair_stct {
    pub handler: aeron_on_close_client_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_on_close_client_pair_stct"]
        [::std::mem::size_of::<aeron_on_close_client_pair_stct>() - 16usize];
    ["Alignment of aeron_on_close_client_pair_stct"]
        [::std::mem::align_of::<aeron_on_close_client_pair_stct>() - 8usize];
    ["Offset of field: aeron_on_close_client_pair_stct::handler"]
        [::std::mem::offset_of!(aeron_on_close_client_pair_stct, handler) - 0usize];
    ["Offset of field: aeron_on_close_client_pair_stct::clientd"]
        [::std::mem::offset_of!(aeron_on_close_client_pair_stct, clientd) - 8usize];
};
impl Default for aeron_on_close_client_pair_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_on_close_client_pair_t = aeron_on_close_client_pair_stct;
unsafe extern "C" {
    #[doc = " Add a handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_available_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_available_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a previously added handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_available_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_available_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_unavailable_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_unavailable_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a previously added handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_unavailable_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_unavailable_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_close_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_close_client_pair_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a previously added handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_close_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_close_client_pair_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_counter_value_descriptor_stct {
    pub counter_value: i64,
    pub registration_id: i64,
    pub owner_id: i64,
    pub reference_id: i64,
    pub pad1: [u8; 96usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_counter_value_descriptor_stct"]
        [::std::mem::size_of::<aeron_counter_value_descriptor_stct>() - 128usize];
    ["Alignment of aeron_counter_value_descriptor_stct"]
        [::std::mem::align_of::<aeron_counter_value_descriptor_stct>() - 4usize];
    ["Offset of field: aeron_counter_value_descriptor_stct::counter_value"]
        [::std::mem::offset_of!(aeron_counter_value_descriptor_stct, counter_value) - 0usize];
    ["Offset of field: aeron_counter_value_descriptor_stct::registration_id"]
        [::std::mem::offset_of!(aeron_counter_value_descriptor_stct, registration_id) - 8usize];
    ["Offset of field: aeron_counter_value_descriptor_stct::owner_id"]
        [::std::mem::offset_of!(aeron_counter_value_descriptor_stct, owner_id) - 16usize];
    ["Offset of field: aeron_counter_value_descriptor_stct::reference_id"]
        [::std::mem::offset_of!(aeron_counter_value_descriptor_stct, reference_id) - 24usize];
    ["Offset of field: aeron_counter_value_descriptor_stct::pad1"]
        [::std::mem::offset_of!(aeron_counter_value_descriptor_stct, pad1) - 32usize];
};
impl Default for aeron_counter_value_descriptor_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_counter_value_descriptor_t = aeron_counter_value_descriptor_stct;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_counter_metadata_descriptor_stct {
    pub state: i32,
    pub type_id: i32,
    pub free_for_reuse_deadline_ms: i64,
    pub key: [u8; 112usize],
    pub label_length: i32,
    pub label: [u8; 380usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_counter_metadata_descriptor_stct"]
        [::std::mem::size_of::<aeron_counter_metadata_descriptor_stct>() - 512usize];
    ["Alignment of aeron_counter_metadata_descriptor_stct"]
        [::std::mem::align_of::<aeron_counter_metadata_descriptor_stct>() - 4usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::state"]
        [::std::mem::offset_of!(aeron_counter_metadata_descriptor_stct, state) - 0usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::type_id"]
        [::std::mem::offset_of!(aeron_counter_metadata_descriptor_stct, type_id) - 4usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::free_for_reuse_deadline_ms"][::std::mem::offset_of!(
        aeron_counter_metadata_descriptor_stct,
        free_for_reuse_deadline_ms
    )
        - 8usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::key"]
        [::std::mem::offset_of!(aeron_counter_metadata_descriptor_stct, key) - 16usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::label_length"]
        [::std::mem::offset_of!(aeron_counter_metadata_descriptor_stct, label_length) - 128usize];
    ["Offset of field: aeron_counter_metadata_descriptor_stct::label"]
        [::std::mem::offset_of!(aeron_counter_metadata_descriptor_stct, label) - 132usize];
};
impl Default for aeron_counter_metadata_descriptor_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_counter_metadata_descriptor_t = aeron_counter_metadata_descriptor_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_counters_reader_buffers_stct {
    pub values: *mut u8,
    pub metadata: *mut u8,
    pub values_length: usize,
    pub metadata_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_counters_reader_buffers_stct"]
        [::std::mem::size_of::<aeron_counters_reader_buffers_stct>() - 32usize];
    ["Alignment of aeron_counters_reader_buffers_stct"]
        [::std::mem::align_of::<aeron_counters_reader_buffers_stct>() - 8usize];
    ["Offset of field: aeron_counters_reader_buffers_stct::values"]
        [::std::mem::offset_of!(aeron_counters_reader_buffers_stct, values) - 0usize];
    ["Offset of field: aeron_counters_reader_buffers_stct::metadata"]
        [::std::mem::offset_of!(aeron_counters_reader_buffers_stct, metadata) - 8usize];
    ["Offset of field: aeron_counters_reader_buffers_stct::values_length"]
        [::std::mem::offset_of!(aeron_counters_reader_buffers_stct, values_length) - 16usize];
    ["Offset of field: aeron_counters_reader_buffers_stct::metadata_length"]
        [::std::mem::offset_of!(aeron_counters_reader_buffers_stct, metadata_length) - 24usize];
};
impl Default for aeron_counters_reader_buffers_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_counters_reader_buffers_t = aeron_counters_reader_buffers_stct;
unsafe extern "C" {
    #[doc = " Get buffer pointers and lengths for the counters reader.\n\n @param reader reader containing the buffers.\n @param buffers output structure to return the buffers.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_get_buffers(
        reader: *mut aeron_counters_reader_t,
        buffers: *mut aeron_counters_reader_buffers_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t.\n\n @param value of the counter.\n @param id of the counter.\n @param label for the counter.\n @param label_length for the counter.\n @param clientd to be returned in the call"]
pub type aeron_counters_reader_foreach_counter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        value: i64,
        id: i32,
        type_id: i32,
        key: *const u8,
        key_length: usize,
        label: *const ::std::os::raw::c_char,
        label_length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Iterate over the counters in the counters_reader and call the given function for each counter.\n\n @param counters_reader to iterate over.\n @param func to call for each counter.\n @param clientd to pass for each call to func."]
    pub fn aeron_counters_reader_foreach_counter(
        counters_reader: *mut aeron_counters_reader_t,
        func: aeron_counters_reader_foreach_counter_func_t,
        clientd: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Iterate over allocated counters and find the first matching a given type id and registration id.\n\n @param counters_reader\n @param type_id to find.\n @param registration_id to find.\n @return the counter id if found otherwise AERON_NULL_COUNTER_ID."]
    pub fn aeron_counters_reader_find_by_type_id_and_registration_id(
        counters_reader: *mut aeron_counters_reader_t,
        type_id: i32,
        registration_id: i64,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the current max counter id.\n\n @param reader to query\n @return -1 on failure, max counter id on success."]
    pub fn aeron_counters_reader_max_counter_id(reader: *mut aeron_counters_reader_t) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the address for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @return address of the counter value"]
    pub fn aeron_counters_reader_addr(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
    ) -> *mut i64;
}
unsafe extern "C" {
    #[doc = " Get the registration id assigned to a counter.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the registration id is requested.\n @param registration_id pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_registration_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        registration_id: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the owner id assigned to a counter which will typically be the client id.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the owner id is requested.\n @param owner_id        pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_owner_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        owner_id: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the reference id assigned to a counter which will typically be the registration id of an associated Image,\n Subscription, Publication, etc.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the reference id is requested.\n @param reference_id    pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_reference_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        reference_id: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the state for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param state out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_state(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        state: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the type id for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param type id out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_type_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        type_id: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a pointer to the key of a counter's metadata\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param key_p out pointer set to location of metadata key\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_metadata_key(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        key_p: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the label for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param buffer to store the counter in.\n @param buffer_length length of the output buffer\n @return -1 on failure, number of characters copied to buffer on success."]
    pub fn aeron_counters_reader_counter_label(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the free for reuse deadline (ms) for a counter.\n\n @param counters_reader that contains the counter.\n @param counter_id to find.\n @param deadline_ms output value to store the deadline.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_free_for_reuse_deadline_ms(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        deadline_ms: *mut i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function called when filling in the reserved value field of a message.\n\n @param clientd passed to the offer function.\n @param buffer of the entire frame, including Aeron data header.\n @param frame_length of the entire frame."]
pub type aeron_reserved_value_supplier_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        frame_length: usize,
    ) -> i64,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_iovec_stct {
    pub iov_base: *mut u8,
    pub iov_len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_iovec_stct"][::std::mem::size_of::<aeron_iovec_stct>() - 16usize];
    ["Alignment of aeron_iovec_stct"][::std::mem::align_of::<aeron_iovec_stct>() - 8usize];
    ["Offset of field: aeron_iovec_stct::iov_base"]
        [::std::mem::offset_of!(aeron_iovec_stct, iov_base) - 0usize];
    ["Offset of field: aeron_iovec_stct::iov_len"]
        [::std::mem::offset_of!(aeron_iovec_stct, iov_len) - 8usize];
};
impl Default for aeron_iovec_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_iovec_t = aeron_iovec_stct;
#[doc = " Structure used to hold information for a try_claim function call."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_buffer_claim_stct {
    pub frame_header: *mut u8,
    pub data: *mut u8,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_buffer_claim_stct"][::std::mem::size_of::<aeron_buffer_claim_stct>() - 24usize];
    ["Alignment of aeron_buffer_claim_stct"]
        [::std::mem::align_of::<aeron_buffer_claim_stct>() - 8usize];
    ["Offset of field: aeron_buffer_claim_stct::frame_header"]
        [::std::mem::offset_of!(aeron_buffer_claim_stct, frame_header) - 0usize];
    ["Offset of field: aeron_buffer_claim_stct::data"]
        [::std::mem::offset_of!(aeron_buffer_claim_stct, data) - 8usize];
    ["Offset of field: aeron_buffer_claim_stct::length"]
        [::std::mem::offset_of!(aeron_buffer_claim_stct, length) - 16usize];
};
impl Default for aeron_buffer_claim_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Commit the given buffer_claim as a complete message available for consumption.\n\n @param buffer_claim to commit.\n @return 0 for success or -1 for error."]
    pub fn aeron_buffer_claim_commit(
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Abort the given buffer_claim and assign its position as padding.\n\n @param buffer_claim to abort.\n @return 0 for success or -1 for error."]
    pub fn aeron_buffer_claim_abort(
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for a publication that does not change during it's lifetime."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_publication_constants_stct {
    #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the publication."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " The registration used to register this Publication with the media driver by the first publisher."]
    pub original_registration_id: i64,
    #[doc = " Get the registration id used to register this Publication with the media driver.\n\n If this value is different from the original_registration_id then a previous active registration exists."]
    pub registration_id: i64,
    #[doc = " The maximum possible position this stream can reach due to its term buffer length.\n\n Maximum possible position is term-length times 2^31 in bytes."]
    pub max_possible_position: i64,
    #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
    pub position_bits_to_shift: usize,
    #[doc = " Get the length in bytes for each term partition in the log buffer."]
    pub term_buffer_length: usize,
    #[doc = " Maximum message length supported in bytes. Messages may be made of multiple fragments if greater than\n MTU length."]
    pub max_message_length: usize,
    #[doc = " Maximum length of a message payload that fits within a message fragment.\n\n This is the MTU length minus the message fragment header length."]
    pub max_payload_length: usize,
    #[doc = " Stream id of the publication."]
    pub stream_id: i32,
    #[doc = " Session id of the publication."]
    pub session_id: i32,
    #[doc = " The initial term id assigned when this publication was created. This can be used to determine how many\n terms have passed since creation."]
    pub initial_term_id: i32,
    #[doc = " Counter id for the publication limit."]
    pub publication_limit_counter_id: i32,
    #[doc = " Counter id for the channel status indicator"]
    pub channel_status_indicator_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_publication_constants_stct"]
        [::std::mem::size_of::<aeron_publication_constants_stct>() - 88usize];
    ["Alignment of aeron_publication_constants_stct"]
        [::std::mem::align_of::<aeron_publication_constants_stct>() - 8usize];
    ["Offset of field: aeron_publication_constants_stct::channel"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, channel) - 0usize];
    ["Offset of field: aeron_publication_constants_stct::original_registration_id"][::std::mem::offset_of!(
        aeron_publication_constants_stct,
        original_registration_id
    ) - 8usize];
    ["Offset of field: aeron_publication_constants_stct::registration_id"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, registration_id) - 16usize];
    ["Offset of field: aeron_publication_constants_stct::max_possible_position"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, max_possible_position) - 24usize];
    ["Offset of field: aeron_publication_constants_stct::position_bits_to_shift"][::std::mem::offset_of!(
        aeron_publication_constants_stct,
        position_bits_to_shift
    ) - 32usize];
    ["Offset of field: aeron_publication_constants_stct::term_buffer_length"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, term_buffer_length) - 40usize];
    ["Offset of field: aeron_publication_constants_stct::max_message_length"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, max_message_length) - 48usize];
    ["Offset of field: aeron_publication_constants_stct::max_payload_length"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, max_payload_length) - 56usize];
    ["Offset of field: aeron_publication_constants_stct::stream_id"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, stream_id) - 64usize];
    ["Offset of field: aeron_publication_constants_stct::session_id"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, session_id) - 68usize];
    ["Offset of field: aeron_publication_constants_stct::initial_term_id"]
        [::std::mem::offset_of!(aeron_publication_constants_stct, initial_term_id) - 72usize];
    ["Offset of field: aeron_publication_constants_stct::publication_limit_counter_id"][::std::mem::offset_of!(
        aeron_publication_constants_stct,
        publication_limit_counter_id
    )
        - 76usize];
    ["Offset of field: aeron_publication_constants_stct::channel_status_indicator_id"][::std::mem::offset_of!(
        aeron_publication_constants_stct,
        channel_status_indicator_id
    ) - 80usize];
};
impl Default for aeron_publication_constants_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Configuration for a publication that does not change during it's lifetime."]
pub type aeron_publication_constants_t = aeron_publication_constants_stct;
unsafe extern "C" {
    #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_offer(
        publication: *mut aeron_publication_t,
        buffer: *const u8,
        length: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_offerv(
        publication: *mut aeron_publication_t,
        iov: *mut aeron_iovec_t,
        iovcnt: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n If the claim is held for more than the aeron.publication.unblock.timeout system property then the driver will\n assume the publication thread is dead and will unblock the claim thus allowing other threads to make progress\n and other claims to be sent to reach end-of-stream (EOS).\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_try_claim(
        publication: *mut aeron_publication_t,
        length: usize,
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_publication_channel_status(publication: *mut aeron_publication_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Has the publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
    pub fn aeron_publication_is_closed(publication: *mut aeron_publication_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Has the publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
    pub fn aeron_publication_is_connected(publication: *mut aeron_publication_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_constants(
        publication: *mut aeron_publication_t,
        constants: *mut aeron_publication_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn aeron_publication_position(publication: *mut aeron_publication_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn aeron_publication_position_limit(publication: *mut aeron_publication_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Add a destination manually to a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param destination_registration_id for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_async_remove_destination_by_id(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_publication_t,
        destination_registration_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the add/remove of a destination to/from a publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_publication_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a destination manually to a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_exclusive_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_exclusive_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param destination_registration_id for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_remove_destination_by_id(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_exclusive_publication_t,
        destination_registration_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of the add/remove of a destination to/from an exclusive publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_exclusive_publication_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously close the publication. Will callback on the on_complete notification when the publication is closed.\n The callback is optional, use NULL for the on_complete callback if not required.\n\n @param publication to close\n @param on_close_complete optional callback to execute once the publication has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
    pub fn aeron_publication_close(
        publication: *mut aeron_publication_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the publication's channel\n\n @param publication this\n @return channel uri string"]
    pub fn aeron_publication_channel(
        publication: *mut aeron_publication_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the publication's stream id\n\n @param publication this\n @return stream id"]
    pub fn aeron_publication_stream_id(publication: *mut aeron_publication_t) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the publication's session id\n @param publication this\n @return session id"]
    pub fn aeron_publication_session_id(publication: *mut aeron_publication_t) -> i32;
}
unsafe extern "C" {
    #[doc = " Get all of the local socket addresses for this publication. Typically only one representing the control address.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error.\n @see aeron_subscription_local_sockaddrs"]
    pub fn aeron_publication_local_sockaddrs(
        publication: *mut aeron_publication_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offer(
        publication: *mut aeron_exclusive_publication_t,
        buffer: *const u8,
        length: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offerv(
        publication: *mut aeron_exclusive_publication_t,
        iov: *mut aeron_iovec_t,
        iovcnt: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_exclusive_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_try_claim(
        publication: *mut aeron_exclusive_publication_t,
        length: usize,
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Append a padding record log of a given length to make up the log to a position.\n\n @param length of the range to claim, in bytes.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_append_padding(
        publication: *mut aeron_exclusive_publication_t,
        length: usize,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Offer a block of pre-formatted message fragments directly into the current term.\n\n @param buffer containing the pre-formatted block of message fragments.\n @param offset offset in the buffer at which the first fragment begins.\n @param length in bytes of the encoded block.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offer_block(
        publication: *mut aeron_exclusive_publication_t,
        buffer: *const u8,
        length: usize,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_exclusive_publication_channel_status(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_constants(
        publication: *mut aeron_exclusive_publication_t,
        constants: *mut aeron_publication_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn aeron_exclusive_publication_position(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn aeron_exclusive_publication_position_limit(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Asynchronously close the publication.\n\n @param publication to close\n @return 0 for success or -1 for error."]
    pub fn aeron_exclusive_publication_close(
        publication: *mut aeron_exclusive_publication_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Revoke this publication when it's closed.\n\n @param publication to revoke on close"]
    pub fn aeron_exclusive_publication_revoke_on_close(
        publication: *mut aeron_exclusive_publication_t,
    );
}
unsafe extern "C" {
    #[doc = " Asynchronously revoke and close the publication. Will callback on the on_complete notification when the publicaiton is closed.\n The callback is optional, use NULL for the on_complete callback if not required.\n\n @param publication to revoke and close\n @param on_close_complete optional callback to execute once the publication has been revoked, closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
    pub fn aeron_exclusive_publication_revoke(
        publication: *mut aeron_exclusive_publication_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Has the exclusive publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
    pub fn aeron_exclusive_publication_is_closed(
        publication: *mut aeron_exclusive_publication_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Has the exclusive publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
    pub fn aeron_exclusive_publication_is_connected(
        publication: *mut aeron_exclusive_publication_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Get all of the local socket addresses for this exclusive publication. Typically only one representing the control\n address.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
    pub fn aeron_exclusive_publication_local_sockaddrs(
        publication: *mut aeron_exclusive_publication_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Callback for handling fragments of data being read from a log.\n\n The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented\n if greater than the frame for MTU in length.\n\n @param clientd passed to the poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
pub type aeron_fragment_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_controlled_fragment_handler_action_en {
    #[doc = " Abort the current polling operation and do not advance the position for this fragment."]
    AERON_ACTION_ABORT = 1,
    #[doc = " Break from the current polling operation and commit the position as of the end of the current fragment\n being handled."]
    AERON_ACTION_BREAK = 2,
    #[doc = " Continue processing but commit the position as of the end of the current fragment so that\n flow control is applied to this point."]
    AERON_ACTION_COMMIT = 3,
    #[doc = " Continue processing until fragment limit or no fragments with position commit at end of poll as in\n aeron_fragment_handler_t."]
    AERON_ACTION_CONTINUE = 4,
}
pub use self::aeron_controlled_fragment_handler_action_en as aeron_controlled_fragment_handler_action_t;
#[doc = " Callback for handling fragments of data being read from a log.\n\n Handler for reading data that is coming from a log buffer. The frame will either contain a whole message\n or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length.\n\n @param clientd passed to the controlled poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
pub type aeron_controlled_fragment_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t,
>;
#[doc = " Callback for handling a block of messages being read from a log.\n\n @param clientd passed to the block poll function.\n @param buffer containing the block of message fragments.\n @param offset at which the block begins, including any frame headers.\n @param length of the block in bytes, including any frame headers that is aligned.\n @param session_id of the stream containing this block of message fragments.\n @param term_id of the stream containing this block of message fragments."]
pub type aeron_block_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        session_id: i32,
        term_id: i32,
    ),
>;
unsafe extern "C" {
    #[doc = " Get all of the field values from the header. This will do a memcpy into the supplied header_values_t pointer.\n\n @param header to read values from.\n @param values to copy values to, must not be null.\n @return 0 on success, -1 on failure."]
    pub fn aeron_header_values(
        header: *mut aeron_header_t,
        values: *mut aeron_header_values_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current position to which the Image has advanced on reading this message.\n\n @param header the current header message\n @return the current position to which the Image has advanced on reading this message."]
    pub fn aeron_header_position(header: *mut aeron_header_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the number of times to left shift the term count to multiply by term length.\n\n @return number of times to left shift the term count to multiply by term length."]
    pub fn aeron_header_position_bits_to_shift(header: *mut aeron_header_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Calculates the offset of the frame immediately after this one.\n\n @return the offset of the next frame."]
    pub fn aeron_header_next_term_offset(header: *mut aeron_header_t) -> i32;
}
unsafe extern "C" {
    #[doc = " Get a pointer to the context associated with this message. Only valid during poll handling. Is normally a\n pointer to an Image instance.\n\n @return a pointer to the context associated with this message."]
    pub fn aeron_header_context(header: *mut aeron_header_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_subscription_constants_stct {
    #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the subscription."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " Callback used to indicate when an Image becomes available under this Subscription."]
    pub on_available_image: aeron_on_available_image_t,
    #[doc = " Callback used to indicate when an Image goes unavailable under this Subscription."]
    pub on_unavailable_image: aeron_on_unavailable_image_t,
    #[doc = " Return the registration id used to register this Subscription with the media driver."]
    pub registration_id: i64,
    #[doc = " Stream identity for scoping within the channel media address."]
    pub stream_id: i32,
    #[doc = " Counter id for the channel status indicator"]
    pub channel_status_indicator_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_subscription_constants_stct"]
        [::std::mem::size_of::<aeron_subscription_constants_stct>() - 40usize];
    ["Alignment of aeron_subscription_constants_stct"]
        [::std::mem::align_of::<aeron_subscription_constants_stct>() - 8usize];
    ["Offset of field: aeron_subscription_constants_stct::channel"]
        [::std::mem::offset_of!(aeron_subscription_constants_stct, channel) - 0usize];
    ["Offset of field: aeron_subscription_constants_stct::on_available_image"]
        [::std::mem::offset_of!(aeron_subscription_constants_stct, on_available_image) - 8usize];
    ["Offset of field: aeron_subscription_constants_stct::on_unavailable_image"]
        [::std::mem::offset_of!(aeron_subscription_constants_stct, on_unavailable_image) - 16usize];
    ["Offset of field: aeron_subscription_constants_stct::registration_id"]
        [::std::mem::offset_of!(aeron_subscription_constants_stct, registration_id) - 24usize];
    ["Offset of field: aeron_subscription_constants_stct::stream_id"]
        [::std::mem::offset_of!(aeron_subscription_constants_stct, stream_id) - 32usize];
    ["Offset of field: aeron_subscription_constants_stct::channel_status_indicator_id"][::std::mem::offset_of!(
        aeron_subscription_constants_stct,
        channel_status_indicator_id
    )
        - 36usize];
};
impl Default for aeron_subscription_constants_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_subscription_constants_t = aeron_subscription_constants_stct;
unsafe extern "C" {
    #[doc = " Poll the images under the subscription for available message fragments.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
    pub fn aeron_subscription_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll in a controlled manner the images under the subscription for available message fragments.\n Control is applied to fragments in the stream. If more fragments can be read on another stream\n they will even if BREAK or ABORT is returned from the fragment handler.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_controlled_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
    pub fn aeron_subscription_controlled_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the images under the subscription for available message fragments in blocks.\n <p>\n This method is useful for operations like bulk archiving and messaging indexing.\n\n @param subscription to poll.\n @param handler to receive a block of fragments from each image.\n @param block_length_limit for each image polled.\n @return the number of bytes consumed or -1 for error."]
    pub fn aeron_subscription_block_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_block_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[doc = " Is this subscription connected by having at least one open publication image.\n\n @param subscription to check.\n @return true if this subscription connected by having at least one open publication image."]
    pub fn aeron_subscription_is_connected(subscription: *mut aeron_subscription_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Fill in a structure with the constants in use by a subscription.\n\n @param subscription to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_constants(
        subscription: *mut aeron_subscription_t,
        constants: *mut aeron_subscription_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Count of images associated to this subscription.\n\n @param subscription to count images for.\n @return count of count associated to this subscription or -1 for error."]
    pub fn aeron_subscription_image_count(
        subscription: *mut aeron_subscription_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the image associated with the given session_id under the given subscription.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param session_id associated with the image.\n @return image associated with the given session_id or NULL if no image exists."]
    pub fn aeron_subscription_image_by_session_id(
        subscription: *mut aeron_subscription_t,
        session_id: i32,
    ) -> *mut aeron_image_t;
}
unsafe extern "C" {
    #[doc = " Return the image at the given index.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param index for the image.\n @return image at the given index or NULL if no image exists."]
    pub fn aeron_subscription_image_at_index(
        subscription: *mut aeron_subscription_t,
        index: usize,
    ) -> *mut aeron_image_t;
}
unsafe extern "C" {
    #[doc = " Iterate over the images for this subscription calling the given function.\n\n @param subscription to iterate over.\n @param handler to be called for each image.\n @param clientd to be passed to the handler."]
    pub fn aeron_subscription_for_each_image(
        subscription: *mut aeron_subscription_t,
        handler: ::std::option::Option<
            unsafe extern "C" fn(image: *mut aeron_image_t, clientd: *mut ::std::os::raw::c_void),
        >,
        clientd: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Retain the given image for access in the application.\n\n Note: A retain call must have a corresponding release call.\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to retain\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_image_retain(
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release the given image and relinquish desire to use the image directly.\n\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to release\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_image_release(
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is the subscription closed.\n\n @param subscription to be checked.\n @return true if it has been closed otherwise false."]
    pub fn aeron_subscription_is_closed(subscription: *mut aeron_subscription_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the status of the media channel for this subscription.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param subscription to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_subscription_channel_status(subscription: *mut aeron_subscription_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Add a destination manually to a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        subscription: *mut aeron_subscription_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        subscription: *mut aeron_subscription_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the completion of add/remove of a destination to/from a subscription.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_subscription_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously close the subscription. Will callback on the on_complete notification when the subscription is\n closed. The callback is optional, use NULL for the on_complete callback if not required.\n\n @param subscription to close\n @param on_close_complete optional callback to execute once the subscription has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
    pub fn aeron_subscription_close(
        subscription: *mut aeron_subscription_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get all of the local socket addresses for this subscription. Multiple addresses can occur if this is a\n multi-destination subscription. Addresses will a string representation in numeric form. IPv6 addresses will be\n surrounded by '[' and ']' so that the ':' that separate the parts are distinguishable from the port delimiter.\n E.g. [fe80::7552:c06e:6bf4:4160]:12345. As of writing the maximum length for a formatted address is 54 bytes\n including the NULL terminator. AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN is defined to provide enough space to fit the\n returned string. Returned strings will be NULL terminated. If the buffer to hold the address can not hold enough\n of the message it will be truncated and the last character will be null.\n\n If the address_vec_len is less the total number of addresses available then the first addresses found up to that\n length will be placed into the address_vec. However the function will return the total number of addresses available\n so if if that is larger than the input array then the client code may wish to re-query with a larger array to get\n them all.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
    pub fn aeron_subscription_local_sockaddrs(
        subscription: *mut aeron_subscription_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the first local socket address for this subscription. If this is not MDS then it will be the one\n representing endpoint for this subscription.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address for the received address\n @param address_len available length for the copied address.\n @return -1 on error, 0 if address not found, 1 if address is found."]
    pub fn aeron_subscription_resolved_endpoint(
        subscription: *mut aeron_subscription_t,
        address: *const ::std::os::raw::c_char,
        address_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or\n does not have a wildcard port (<code>0</code>), then it will return the original URI.\n\n @param subscription to query\n @param uri buffer to hold the resolved uri\n @param uri_len length of the buffer\n @return -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done\n on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up\n to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been\n truncated."]
    pub fn aeron_subscription_try_resolve_channel_endpoint_port(
        subscription: *mut aeron_subscription_t,
        uri: *mut ::std::os::raw::c_char,
        uri_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for an image that does not change during it's lifetime."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_image_constants_stct {
    #[doc = " The subscription to which this image belongs."]
    pub subscription: *mut aeron_subscription_t,
    #[doc = " The source identity of the sending publisher as an abstract concept appropriate for the media."]
    pub source_identity: *const ::std::os::raw::c_char,
    #[doc = " The correlationId for identification of the image with the media driver."]
    pub correlation_id: i64,
    #[doc = " Get the position the subscriber joined this stream at."]
    pub join_position: i64,
    #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
    pub position_bits_to_shift: usize,
    #[doc = " Get the length in bytes for each term partition in the log buffer."]
    pub term_buffer_length: usize,
    #[doc = " The length in bytes of the MTU (Maximum Transmission Unit) the Sender used for the datagram."]
    pub mtu_length: usize,
    #[doc = " The sessionId for the steam of messages. Sessions are unique within a subscription and unique across\n all publications from a source identity."]
    pub session_id: i32,
    #[doc = " The initial term at which the stream started for this session."]
    pub initial_term_id: i32,
    #[doc = " Counter id that refers to the subscriber position for this image."]
    pub subscriber_position_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_image_constants_stct"]
        [::std::mem::size_of::<aeron_image_constants_stct>() - 72usize];
    ["Alignment of aeron_image_constants_stct"]
        [::std::mem::align_of::<aeron_image_constants_stct>() - 8usize];
    ["Offset of field: aeron_image_constants_stct::subscription"]
        [::std::mem::offset_of!(aeron_image_constants_stct, subscription) - 0usize];
    ["Offset of field: aeron_image_constants_stct::source_identity"]
        [::std::mem::offset_of!(aeron_image_constants_stct, source_identity) - 8usize];
    ["Offset of field: aeron_image_constants_stct::correlation_id"]
        [::std::mem::offset_of!(aeron_image_constants_stct, correlation_id) - 16usize];
    ["Offset of field: aeron_image_constants_stct::join_position"]
        [::std::mem::offset_of!(aeron_image_constants_stct, join_position) - 24usize];
    ["Offset of field: aeron_image_constants_stct::position_bits_to_shift"]
        [::std::mem::offset_of!(aeron_image_constants_stct, position_bits_to_shift) - 32usize];
    ["Offset of field: aeron_image_constants_stct::term_buffer_length"]
        [::std::mem::offset_of!(aeron_image_constants_stct, term_buffer_length) - 40usize];
    ["Offset of field: aeron_image_constants_stct::mtu_length"]
        [::std::mem::offset_of!(aeron_image_constants_stct, mtu_length) - 48usize];
    ["Offset of field: aeron_image_constants_stct::session_id"]
        [::std::mem::offset_of!(aeron_image_constants_stct, session_id) - 56usize];
    ["Offset of field: aeron_image_constants_stct::initial_term_id"]
        [::std::mem::offset_of!(aeron_image_constants_stct, initial_term_id) - 60usize];
    ["Offset of field: aeron_image_constants_stct::subscriber_position_id"]
        [::std::mem::offset_of!(aeron_image_constants_stct, subscriber_position_id) - 64usize];
};
impl Default for aeron_image_constants_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Configuration for an image that does not change during it's lifetime."]
pub type aeron_image_constants_t = aeron_image_constants_stct;
unsafe extern "C" {
    #[doc = " Fill in a structure with the constants in use by a image.\n\n @param image to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_image_constants(
        image: *mut aeron_image_t,
        constants: *mut aeron_image_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The position this image has been consumed to by the subscriber.\n\n @param image to query position of.\n @return the position this image has been consumed to by the subscriber."]
    pub fn aeron_image_position(image: *mut aeron_image_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Set the subscriber position for this image to indicate where it has been consumed to.\n\n @param image to set the position of.\n @param new_position for the consumption point."]
    pub fn aeron_image_set_position(
        image: *mut aeron_image_t,
        position: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is the current consumed position at the end of the stream?\n\n @param image to check.\n @return true if at the end of the stream or false if not."]
    pub fn aeron_image_is_end_of_stream(image: *mut aeron_image_t) -> bool;
}
unsafe extern "C" {
    #[doc = " The position the stream reached when EOS was received from the publisher. The position will be\n INT64_MAX until the stream ends and EOS is set.\n\n @param image to check.\n @return position the stream reached when EOS was received from the publisher."]
    pub fn aeron_image_end_of_stream_position(image: *mut aeron_image_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Count of observed active transports within the image liveness timeout.\n\n If the image is closed, then this is 0. This may also be 0 if no actual datagrams have arrived. IPC\n Images also will be 0.\n\n @param image to check.\n @return count of active transports - 0 if Image is closed, no datagrams yet, or IPC. Or -1 for error."]
    pub fn aeron_image_active_transport_count(image: *mut aeron_image_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Was the associated publication revoked?\n\n @param image to check\n @return true if the associated publication was revoked."]
    pub fn aeron_image_is_publication_revoked(image: *mut aeron_image_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_poll(
        image: *mut aeron_image_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_controlled_poll(
        image: *mut aeron_image_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_bounded_poll(
        image: *mut aeron_image_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_bounded_controlled_poll(
        image: *mut aeron_image_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Peek for new messages in a stream by scanning forward from an initial position. If new messages are found then\n they will be delivered to the handler up to a limited position.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments. Scans must also\n start at the beginning of a message so that the assembler is reset.\n\n @param image to peek.\n @param initial_position from which to peek forward.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position up to which can be scanned.\n @return the resulting position after the scan terminates which is a complete message or -1 for error."]
    pub fn aeron_image_controlled_peek(
        image: *mut aeron_image_t,
        initial_position: i64,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of bytes.\n <p>\n A scan will terminate if a padding frame is encountered. If first frame in a scan is padding then a block\n for the padding is notified. If the padding comes after the first frame in a scan then the scan terminates\n at the offset the padding frame begins. Padding frames are delivered singularly in a block.\n <p>\n Padding frames may be for a greater range than the limit offset but only the header needs to be valid so\n relevant length of the frame is data header length.\n\n @param image to poll.\n @param handler to which block is delivered.\n @param clientd to pass to the handler.\n @param block_length_limit up to which a block may be in length.\n @return the number of bytes that have been consumed or -1 for error."]
    pub fn aeron_image_block_poll(
        image: *mut aeron_image_t,
        handler: aeron_block_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_image_is_closed(image: *mut aeron_image_t) -> bool;
}
unsafe extern "C" {
    pub fn aeron_image_reject(
        image: *mut aeron_image_t,
        reason: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create an image fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed.\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_image_fragment_assembler_create(
        assembler: *mut *mut aeron_image_fragment_assembler_t,
        delegate: aeron_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete an image fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_image_fragment_assembler_delete(
        assembler: *mut aeron_image_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
    pub fn aeron_image_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    );
}
unsafe extern "C" {
    #[doc = " Create an image controlled fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_image_controlled_fragment_assembler_create(
        assembler: *mut *mut aeron_image_controlled_fragment_assembler_t,
        delegate: aeron_controlled_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete an image controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_image_controlled_fragment_assembler_delete(
        assembler: *mut aeron_image_controlled_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
    pub fn aeron_image_controlled_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t;
}
unsafe extern "C" {
    #[doc = " Create a fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_fragment_assembler_create(
        assembler: *mut *mut aeron_fragment_assembler_t,
        delegate: aeron_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_fragment_assembler_delete(
        assembler: *mut aeron_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
    pub fn aeron_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    );
}
unsafe extern "C" {
    #[doc = " Create a controlled fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_controlled_fragment_assembler_create(
        assembler: *mut *mut aeron_controlled_fragment_assembler_t,
        delegate: aeron_controlled_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_controlled_fragment_assembler_delete(
        assembler: *mut aeron_controlled_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
    pub fn aeron_controlled_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t;
}
unsafe extern "C" {
    #[doc = " Return a pointer to the counter value.\n\n @param counter to pointer to.\n @return pointer to the counter value."]
    pub fn aeron_counter_addr(counter: *mut aeron_counter_t) -> *mut i64;
}
#[doc = " Configuration for a counter that does not change during it's lifetime."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_counter_constants_stct {
    #[doc = " Return the registration id used to register this counter with the media driver."]
    pub registration_id: i64,
    #[doc = " Identity for the counter within the counters reader and counters manager."]
    pub counter_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_counter_constants_stct"]
        [::std::mem::size_of::<aeron_counter_constants_stct>() - 16usize];
    ["Alignment of aeron_counter_constants_stct"]
        [::std::mem::align_of::<aeron_counter_constants_stct>() - 8usize];
    ["Offset of field: aeron_counter_constants_stct::registration_id"]
        [::std::mem::offset_of!(aeron_counter_constants_stct, registration_id) - 0usize];
    ["Offset of field: aeron_counter_constants_stct::counter_id"]
        [::std::mem::offset_of!(aeron_counter_constants_stct, counter_id) - 8usize];
};
#[doc = " Configuration for a counter that does not change during it's lifetime."]
pub type aeron_counter_constants_t = aeron_counter_constants_stct;
unsafe extern "C" {
    #[doc = " Fill in a structure with the constants in use by a counter.\n\n @param counter to get the constants for.\n @param constants structure to fill in with the constants.\n @return 0 for success and -1 for error."]
    pub fn aeron_counter_constants(
        counter: *mut aeron_counter_t,
        constants: *mut aeron_counter_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously close the counter.\n\n @param counter to close.\n @return 0 for success or -1 for error."]
    pub fn aeron_counter_close(
        counter: *mut aeron_counter_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the counter is closed\n @param counter to check\n @return true if closed, false otherwise."]
    pub fn aeron_counter_is_closed(counter: *mut aeron_counter_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Return full version and build string.\n\n @return full version and build string."]
    pub fn aeron_version_full() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return version text.\n\n @return version text."]
    pub fn aeron_version_text() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return major version number.\n\n @return major version number."]
    pub fn aeron_version_major() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return minor version number.\n\n @return minor version number."]
    pub fn aeron_version_minor() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return patch version number.\n\n @return patch version number."]
    pub fn aeron_version_patch() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the git sha for the current build.\n\n @return git version"]
    pub fn aeron_version_gitsha() -> *const ::std::os::raw::c_char;
}
#[doc = " Clock function used by aeron."]
pub type aeron_clock_func_t = ::std::option::Option<unsafe extern "C" fn() -> i64>;
unsafe extern "C" {
    #[doc = " Return time in nanoseconds for machine. Is not wall clock time.\n\n @return nanoseconds since epoch for machine."]
    pub fn aeron_nano_clock() -> i64;
}
unsafe extern "C" {
    #[doc = " Return time in milliseconds since epoch. Is wall clock time.\n\n @return milliseconds since epoch."]
    pub fn aeron_epoch_clock() -> i64;
}
#[doc = " Function to return logging information."]
pub type aeron_log_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Determine if an aeron driver is using a given aeron directory.\n\n @param dirname  for aeron directory\n @param timeout_ms  to use to determine activity for aeron directory\n @param log_func to call during activity check to log diagnostic information.\n @return true for active driver or false for no active driver."]
    pub fn aeron_is_driver_active(
        dirname: *const ::std::os::raw::c_char,
        timeout_ms: i64,
        log_func: aeron_log_func_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Load properties from a string containing name=value pairs and set appropriate environment variables for the\n process so that subsequent calls to aeron_driver_context_init will use those values.\n\n @param buffer containing properties and values.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_buffer_load(
        buffer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load properties file and set appropriate environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param filename to load.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_file_load(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load properties from HTTP URL and set environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param url to attempt to retrieve and load.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_http_load(url: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load properties based on URL or filename. If string contains file or http URL, it will attempt\n to load properties from a file or http as indicated. If not a URL, then it will try to load the string\n as a filename.\n\n @param url_or_filename to load properties from.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_load(
        url_or_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return current aeron error code (errno) for calling thread.\n\n @return aeron error code for calling thread."]
    pub fn aeron_errcode() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the current aeron error message for calling thread.\n\n @return aeron error message for calling thread."]
    pub fn aeron_errmsg() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the default path used by the Aeron media driver.\n\n @param path buffer to store the path.\n @param path_length space available in the buffer\n @return -1 if there is an issue or the number of bytes written to path excluding the terminator <code>\\0</code>. If this\n is equal to or greater than the path_length then the path has been truncated."]
    pub fn aeron_default_path(
        path: *mut ::std::os::raw::c_char,
        path_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the registration id for addition of the counter. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_counter_t may have been freed.\n\n @param add_counter used to check for completion.\n @return registration id for the counter."]
    pub fn aeron_async_add_counter_get_registration_id(
        add_counter: *mut aeron_async_add_counter_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the registration id for addition of the publication. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_publication_t may have been freed.\n\n @param add_publication used to check for completion.\n @return registration id for the publication."]
    pub fn aeron_async_add_publication_get_registration_id(
        add_publication: *mut aeron_async_add_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the\n succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed.\n\n @param add_exclusive_publication used to check for completion.\n @return registration id for the exclusive_publication.\n @deprecated Use aeron_async_add_exclusive_publication_get_registration_id instead."]
    pub fn aeron_async_add_exclusive_exclusive_publication_get_registration_id(
        add_exclusive_publication: *mut aeron_async_add_exclusive_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the\n succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed.\n\n @param add_exclusive_publication used to check for completion.\n @return registration id for the exclusive_publication."]
    pub fn aeron_async_add_exclusive_publication_get_registration_id(
        add_exclusive_publication: *mut aeron_async_add_exclusive_publication_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the registration id for addition of the subscription. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_subscription_t may have been freed.\n\n @param add_subscription used to check for completion.\n @return registration id for the subscription."]
    pub fn aeron_async_add_subscription_get_registration_id(
        add_subscription: *mut aeron_async_add_subscription_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets the registration_id for the destination command supplied. Note that this is the correlation_id used for\n the specified destination command, not the registration_id for the original parent resource (publication,\n subscription).\n\n @param async_destination tracking the current destination command.\n @return correlation_id sent to driver."]
    pub fn aeron_async_destination_get_registration_id(
        async_destination: *mut aeron_async_destination_t,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Request the media driver terminates operation and closes all resources.\n\n @param directory    in which the media driver is running.\n @param token_buffer containing the authentication token confirming the client is allowed to terminate the driver.\n @param token_length of the token in the buffer.\n @return"]
    pub fn aeron_context_request_driver_termination(
        directory: *const ::std::os::raw::c_char,
        token_buffer: *const u8,
        token_length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_cnc_stct {
    _unused: [u8; 0],
}
pub type aeron_cnc_t = aeron_cnc_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_cnc_constants_stct {
    pub cnc_version: i32,
    pub to_driver_buffer_length: i32,
    pub to_clients_buffer_length: i32,
    pub counter_metadata_buffer_length: i32,
    pub counter_values_buffer_length: i32,
    pub error_log_buffer_length: i32,
    pub client_liveness_timeout: i64,
    pub start_timestamp: i64,
    pub pid: i64,
    pub file_page_size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_cnc_constants_stct"]
        [::std::mem::size_of::<aeron_cnc_constants_stct>() - 52usize];
    ["Alignment of aeron_cnc_constants_stct"]
        [::std::mem::align_of::<aeron_cnc_constants_stct>() - 4usize];
    ["Offset of field: aeron_cnc_constants_stct::cnc_version"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, cnc_version) - 0usize];
    ["Offset of field: aeron_cnc_constants_stct::to_driver_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, to_driver_buffer_length) - 4usize];
    ["Offset of field: aeron_cnc_constants_stct::to_clients_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, to_clients_buffer_length) - 8usize];
    ["Offset of field: aeron_cnc_constants_stct::counter_metadata_buffer_length"][::std::mem::offset_of!(
        aeron_cnc_constants_stct,
        counter_metadata_buffer_length
    ) - 12usize];
    ["Offset of field: aeron_cnc_constants_stct::counter_values_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, counter_values_buffer_length) - 16usize];
    ["Offset of field: aeron_cnc_constants_stct::error_log_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, error_log_buffer_length) - 20usize];
    ["Offset of field: aeron_cnc_constants_stct::client_liveness_timeout"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, client_liveness_timeout) - 24usize];
    ["Offset of field: aeron_cnc_constants_stct::start_timestamp"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, start_timestamp) - 32usize];
    ["Offset of field: aeron_cnc_constants_stct::pid"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, pid) - 40usize];
    ["Offset of field: aeron_cnc_constants_stct::file_page_size"]
        [::std::mem::offset_of!(aeron_cnc_constants_stct, file_page_size) - 48usize];
};
pub type aeron_cnc_constants_t = aeron_cnc_constants_stct;
unsafe extern "C" {
    #[doc = " Initialise an aeron_cnc, which gives user level access to the command and control file used to communicate\n with the media driver. Will wait until the media driver has loaded and the cnc file is created, up to timeout_ms.\n Use a value of 0 for a non-blocking initialisation.\n\n @param aeron_cnc to hold the loaded aeron_cnc\n @param base_path media driver's base path\n @param timeout_ms Number of milliseconds to wait before timing out.\n @return 0 on success, -1 on failure."]
    pub fn aeron_cnc_init(
        aeron_cnc: *mut *mut aeron_cnc_t,
        base_path: *const ::std::os::raw::c_char,
        timeout_ms: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetch the sets of constant values associated with this command and control file.\n\n @param aeron_cnc to query\n @param constants user supplied structure to hold return values.\n @return 0 on success, -1 on failure."]
    pub fn aeron_cnc_constants(
        aeron_cnc: *mut aeron_cnc_t,
        constants: *mut aeron_cnc_constants_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current file name of the cnc file.\n\n @param aeron_cnc to query\n @return name of the cnc file"]
    pub fn aeron_cnc_filename(aeron_cnc: *mut aeron_cnc_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the timestamp of the last heartbeat sent to the media driver from any client.\n\n @param aeron_cnc to query\n @return last heartbeat timestamp in ms."]
    pub fn aeron_cnc_to_driver_heartbeat(aeron_cnc: *mut aeron_cnc_t) -> i64;
}
pub type aeron_error_log_reader_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        observation_count: i32,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        error: *const ::std::os::raw::c_char,
        error_length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Reads the current error log for this driver.\n\n @param aeron_cnc to query\n @param callback called for every distinct error observation\n @param clientd client data to be passed to the callback\n @param since_timestamp only return errors after this timestamp (0 returns all)\n @return the number of distinct errors seen"]
    pub fn aeron_cnc_error_log_read(
        aeron_cnc: *mut aeron_cnc_t,
        callback: aeron_error_log_reader_func_t,
        clientd: *mut ::std::os::raw::c_void,
        since_timestamp: i64,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Gets a counters reader for this command and control file. This does not need to be closed manually, resources\n are tied to the instance of aeron_cnc.\n\n @param aeron_cnc to query\n @return pointer to a counters reader."]
    pub fn aeron_cnc_counters_reader(aeron_cnc: *mut aeron_cnc_t) -> *mut aeron_counters_reader_t;
}
pub type aeron_loss_reporter_read_entry_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        observation_count: i64,
        total_bytes_lost: i64,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        session_id: i32,
        stream_id: i32,
        channel: *const ::std::os::raw::c_char,
        channel_length: i32,
        source: *const ::std::os::raw::c_char,
        source_length: i32,
    ),
>;
unsafe extern "C" {
    #[doc = " Read all of the data loss observations from the report in the same media driver instances as the cnc file.\n\n @param aeron_cnc to query\n @param entry_func callback for each observation found\n @param clientd client data to be passed to the callback.\n @return -1 on failure, number of observations on success (could be 0)."]
    pub fn aeron_cnc_loss_reporter_read(
        aeron_cnc: *mut aeron_cnc_t,
        entry_func: aeron_loss_reporter_read_entry_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Closes the instance of the aeron cnc and frees its resources.\n\n @param aeron_cnc to close"]
    pub fn aeron_cnc_close(aeron_cnc: *mut aeron_cnc_t);
}
pub type aeron_idle_strategy_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, work_count: ::std::os::raw::c_int),
>;
pub type aeron_idle_strategy_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut *mut ::std::os::raw::c_void,
        env_var: *const ::std::os::raw::c_char,
        init_args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn aeron_semantic_version_compose(major: u8, minor: u8, patch: u8) -> i32;
}
unsafe extern "C" {
    pub fn aeron_semantic_version_major(version: i32) -> u8;
}
unsafe extern "C" {
    pub fn aeron_semantic_version_minor(version: i32) -> u8;
}
unsafe extern "C" {
    pub fn aeron_semantic_version_patch(version: i32) -> u8;
}
pub type aeron_fptr_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type aeron_archive_t = aeron_archive_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_archive_context_stct {
    _unused: [u8; 0],
}
pub type aeron_archive_context_t = aeron_archive_context_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_archive_async_connect_stct {
    _unused: [u8; 0],
}
pub type aeron_archive_async_connect_t = aeron_archive_async_connect_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_encoded_credentials_stct {
    pub data: *const ::std::os::raw::c_char,
    pub length: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_encoded_credentials_stct"]
        [::std::mem::size_of::<aeron_archive_encoded_credentials_stct>() - 16usize];
    ["Alignment of aeron_archive_encoded_credentials_stct"]
        [::std::mem::align_of::<aeron_archive_encoded_credentials_stct>() - 8usize];
    ["Offset of field: aeron_archive_encoded_credentials_stct::data"]
        [::std::mem::offset_of!(aeron_archive_encoded_credentials_stct, data) - 0usize];
    ["Offset of field: aeron_archive_encoded_credentials_stct::length"]
        [::std::mem::offset_of!(aeron_archive_encoded_credentials_stct, length) - 8usize];
};
impl Default for aeron_archive_encoded_credentials_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_archive_encoded_credentials_t = aeron_archive_encoded_credentials_stct;
#[doc = " Callback to return encoded credentials.\n\n @return encoded credentials to include with the connect request"]
pub type aeron_archive_credentials_encoded_credentials_supplier_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
    ) -> *mut aeron_archive_encoded_credentials_t,
>;
#[doc = " Callback to return encoded credentials given a specific encoded challenge.\n\n @param encoded_challenge to use to generate the encoded credentials\n @return encoded credentials to include with the challenge response"]
pub type aeron_archive_credentials_challenge_supplier_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        encoded_challenge: *mut aeron_archive_encoded_credentials_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> *mut aeron_archive_encoded_credentials_t,
>;
#[doc = " Callback to return encoded credentials so they may be reused or freed.\n\n @param credentials to reuse or free"]
pub type aeron_archive_credentials_free_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        credentials: *mut aeron_archive_encoded_credentials_t,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback to allow execution of a delegating invoker to be run."]
pub type aeron_archive_delegating_invoker_func_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
#[doc = " Struct containing the available replay parameters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_replay_params_stct {
    #[doc = " Set the counter id to be used for bounding the replay.\n Setting this value will trigger the sending of a bounded replay request, instead of a normal replay.\n By default, a bound will not be applied."]
    pub bounding_limit_counter_id: i32,
    #[doc = " The maximum size of a file operation when reading from the archive to execute the replay."]
    pub file_io_max_length: i32,
    #[doc = " The position at which to start the replay.\n By default, the stream is replayed from the start."]
    pub position: i64,
    #[doc = " The length of the recorded stream to replay.\n By default, the whole stream will be replayed.\n If set to INT64_MAX, it will follow a live recording."]
    pub length: i64,
    #[doc = " The token used for replays when the initiating image is not the one used to create the archive connection/session."]
    pub replay_token: i64,
    #[doc = " The subscription registration id used when doing a start replay using response channels and the response channel is already created."]
    pub subscription_registration_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_replay_params_stct"]
        [::std::mem::size_of::<aeron_archive_replay_params_stct>() - 40usize];
    ["Alignment of aeron_archive_replay_params_stct"]
        [::std::mem::align_of::<aeron_archive_replay_params_stct>() - 8usize];
    ["Offset of field: aeron_archive_replay_params_stct::bounding_limit_counter_id"][::std::mem::offset_of!(
        aeron_archive_replay_params_stct,
        bounding_limit_counter_id
    ) - 0usize];
    ["Offset of field: aeron_archive_replay_params_stct::file_io_max_length"]
        [::std::mem::offset_of!(aeron_archive_replay_params_stct, file_io_max_length) - 4usize];
    ["Offset of field: aeron_archive_replay_params_stct::position"]
        [::std::mem::offset_of!(aeron_archive_replay_params_stct, position) - 8usize];
    ["Offset of field: aeron_archive_replay_params_stct::length"]
        [::std::mem::offset_of!(aeron_archive_replay_params_stct, length) - 16usize];
    ["Offset of field: aeron_archive_replay_params_stct::replay_token"]
        [::std::mem::offset_of!(aeron_archive_replay_params_stct, replay_token) - 24usize];
    ["Offset of field: aeron_archive_replay_params_stct::subscription_registration_id"][::std::mem::offset_of!(
        aeron_archive_replay_params_stct,
        subscription_registration_id
    )
        - 32usize];
};
#[doc = " Struct containing the available replay parameters."]
pub type aeron_archive_replay_params_t = aeron_archive_replay_params_stct;
unsafe extern "C" {
    #[doc = " Initialize an aeron_archive_replay_params_t with the default values."]
    pub fn aeron_archive_replay_params_init(
        params: *mut aeron_archive_replay_params_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Struct containing the available replication parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_replication_params_stct {
    #[doc = " The stop position for the replication.\n The default of AERON_NULL_VALUE indicates a continuous replication."]
    pub stop_position: i64,
    #[doc = " The recording id of the destination Archive to extend.\n The default of AERON_NULL_VALUE triggers the creation of a new recording at the destination Archive."]
    pub dst_recording_id: i64,
    #[doc = " Specify the destination for the live stream if a merge is required.\n The default of an empty string means no merge will occur."]
    pub live_destination: *const ::std::os::raw::c_char,
    #[doc = " Specify the channel to use to replicate the recording.\n The default of an empty string will trigger the use of the context's default replication channel."]
    pub replication_channel: *const ::std::os::raw::c_char,
    #[doc = " Specify the control address of the source archive when using response channels during replication."]
    pub src_response_channel: *const ::std::os::raw::c_char,
    #[doc = " Specify a tag to apply to the channel used by the Archive's subscription for replication."]
    pub channel_tag_id: i64,
    #[doc = " Specify a subscription tag to apply to the channel used by the Archive's subscription for replication."]
    pub subscription_tag_id: i64,
    #[doc = " Specify the max length for file IO operations used in the replay."]
    pub file_io_max_length: i32,
    #[doc = " Specify session id to be used for the replicated file instead of the session id from the source archive.\n This is useful in cases where we are replicating the same recording in multiple stages."]
    pub replication_session_id: i32,
    #[doc = " Specify the encoded credentials that will be passed to the source archive for authentication.\n Currently, only simple authentication (i.e. not challenge/response) is supported for replication."]
    pub encoded_credentials: *mut aeron_archive_encoded_credentials_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_replication_params_stct"]
        [::std::mem::size_of::<aeron_archive_replication_params_stct>() - 72usize];
    ["Alignment of aeron_archive_replication_params_stct"]
        [::std::mem::align_of::<aeron_archive_replication_params_stct>() - 8usize];
    ["Offset of field: aeron_archive_replication_params_stct::stop_position"]
        [::std::mem::offset_of!(aeron_archive_replication_params_stct, stop_position) - 0usize];
    ["Offset of field: aeron_archive_replication_params_stct::dst_recording_id"]
        [::std::mem::offset_of!(aeron_archive_replication_params_stct, dst_recording_id) - 8usize];
    ["Offset of field: aeron_archive_replication_params_stct::live_destination"]
        [::std::mem::offset_of!(aeron_archive_replication_params_stct, live_destination) - 16usize];
    ["Offset of field: aeron_archive_replication_params_stct::replication_channel"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        replication_channel
    ) - 24usize];
    ["Offset of field: aeron_archive_replication_params_stct::src_response_channel"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        src_response_channel
    ) - 32usize];
    ["Offset of field: aeron_archive_replication_params_stct::channel_tag_id"]
        [::std::mem::offset_of!(aeron_archive_replication_params_stct, channel_tag_id) - 40usize];
    ["Offset of field: aeron_archive_replication_params_stct::subscription_tag_id"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        subscription_tag_id
    ) - 48usize];
    ["Offset of field: aeron_archive_replication_params_stct::file_io_max_length"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        file_io_max_length
    ) - 56usize];
    ["Offset of field: aeron_archive_replication_params_stct::replication_session_id"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        replication_session_id
    ) - 60usize];
    ["Offset of field: aeron_archive_replication_params_stct::encoded_credentials"][::std::mem::offset_of!(
        aeron_archive_replication_params_stct,
        encoded_credentials
    ) - 64usize];
};
impl Default for aeron_archive_replication_params_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct containing the available replication parameters."]
pub type aeron_archive_replication_params_t = aeron_archive_replication_params_stct;
unsafe extern "C" {
    #[doc = " Initialize an aeron_archive_replication_params_t with the default values"]
    pub fn aeron_archive_replication_params_init(
        params: *mut aeron_archive_replication_params_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Struct containing the details of a recording"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_recording_descriptor_stct {
    #[doc = " control session id of the request"]
    pub control_session_id: i64,
    #[doc = " correlation id of the request"]
    pub correlation_id: i64,
    #[doc = " id of the recording"]
    pub recording_id: i64,
    #[doc = " timestamp of recording start"]
    pub start_timestamp: i64,
    #[doc = " timestamp of recording stop"]
    pub stop_timestamp: i64,
    #[doc = " the start position of the recording against the recorded publication"]
    pub start_position: i64,
    #[doc = " the highest position reached for this recording"]
    pub stop_position: i64,
    #[doc = " the initial term id of the recorded publication"]
    pub initial_term_id: i32,
    #[doc = " the segment file length - a multiple of the term_buffer_length"]
    pub segment_file_length: i32,
    #[doc = " term buffer length of the publication"]
    pub term_buffer_length: i32,
    #[doc = " mtu length of the recorded publication"]
    pub mtu_length: i32,
    #[doc = " session id of the recorded publication"]
    pub session_id: i32,
    #[doc = " stream id of the recorded publication"]
    pub stream_id: i32,
    #[doc = " channel used for recording subscription at the Aeron Archive"]
    pub stripped_channel: *mut ::std::os::raw::c_char,
    #[doc = " length of the stripped_channel string"]
    pub stripped_channel_length: usize,
    #[doc = " channel provided to start the recording request"]
    pub original_channel: *mut ::std::os::raw::c_char,
    #[doc = " length of the original_channel string"]
    pub original_channel_length: usize,
    #[doc = " source identity of the recorded stream"]
    pub source_identity: *mut ::std::os::raw::c_char,
    #[doc = " length of the source_identity string"]
    pub source_identity_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_recording_descriptor_stct"]
        [::std::mem::size_of::<aeron_archive_recording_descriptor_stct>() - 128usize];
    ["Alignment of aeron_archive_recording_descriptor_stct"]
        [::std::mem::align_of::<aeron_archive_recording_descriptor_stct>() - 8usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::control_session_id"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        control_session_id
    ) - 0usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::correlation_id"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, correlation_id) - 8usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::recording_id"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, recording_id) - 16usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::start_timestamp"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        start_timestamp
    ) - 24usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::stop_timestamp"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, stop_timestamp) - 32usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::start_position"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, start_position) - 40usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::stop_position"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, stop_position) - 48usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::initial_term_id"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        initial_term_id
    ) - 56usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::segment_file_length"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        segment_file_length
    ) - 60usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::term_buffer_length"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        term_buffer_length
    ) - 64usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::mtu_length"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, mtu_length) - 68usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::session_id"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, session_id) - 72usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::stream_id"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_stct, stream_id) - 76usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::stripped_channel"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        stripped_channel
    ) - 80usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::stripped_channel_length"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        stripped_channel_length
    )
        - 88usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::original_channel"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        original_channel
    ) - 96usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::original_channel_length"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        original_channel_length
    )
        - 104usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::source_identity"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        source_identity
    ) - 112usize];
    ["Offset of field: aeron_archive_recording_descriptor_stct::source_identity_length"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_stct,
        source_identity_length
    )
        - 120usize];
};
impl Default for aeron_archive_recording_descriptor_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct containing the details of a recording"]
pub type aeron_archive_recording_descriptor_t = aeron_archive_recording_descriptor_stct;
#[doc = " Callback to return recording descriptors."]
pub type aeron_archive_recording_descriptor_consumer_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        recording_descriptor: *mut aeron_archive_recording_descriptor_t,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Struct containing the details of a recording subscription"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_recording_subscription_descriptor_stct {
    #[doc = " control session id of the request"]
    pub control_session_id: i64,
    #[doc = " correlation id of the request"]
    pub correlation_id: i64,
    #[doc = " the subscription id - can be used to stop the recording subscription"]
    pub subscription_id: i64,
    #[doc = " the stream id the subscription was registered with"]
    pub stream_id: i32,
    #[doc = " the channel the subscription was registered with"]
    pub stripped_channel: *mut ::std::os::raw::c_char,
    #[doc = " the length of the stripped_channel string"]
    pub stripped_channel_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_recording_subscription_descriptor_stct"]
        [::std::mem::size_of::<aeron_archive_recording_subscription_descriptor_stct>() - 48usize];
    ["Alignment of aeron_archive_recording_subscription_descriptor_stct"]
        [::std::mem::align_of::<aeron_archive_recording_subscription_descriptor_stct>() - 8usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_stct::control_session_id"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        control_session_id
    )
        - 0usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_stct::correlation_id"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        correlation_id
    )
        - 8usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_stct::subscription_id"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        subscription_id
    )
        - 16usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_stct::stream_id"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        stream_id
    )
        - 24usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_stct::stripped_channel"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        stripped_channel
    )
        - 32usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_stct::stripped_channel_length",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_stct,
        stripped_channel_length
    ) - 40usize];
};
impl Default for aeron_archive_recording_subscription_descriptor_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct containing the details of a recording subscription"]
pub type aeron_archive_recording_subscription_descriptor_t =
    aeron_archive_recording_subscription_descriptor_stct;
#[doc = " Callback to return recording subscription descriptors."]
pub type aeron_archive_recording_subscription_descriptor_consumer_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        recording_subscription_descriptor: *mut aeron_archive_recording_subscription_descriptor_t,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_archive_client_recording_signal_en {
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_START = 0,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_STOP = 1,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_EXTEND = 2,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_REPLICATE = 3,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_MERGE = 4,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_SYNC = 5,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_DELETE = 6,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_REPLICATE_END = 7,
    AERON_ARCHIVE_CLIENT_RECORDING_SIGNAL_NULL_VALUE = -2147483648,
}
pub use self::aeron_archive_client_recording_signal_en as aeron_archive_client_recording_signal_t;
#[doc = " Struct containing the details of a recording signal."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_recording_signal_stct {
    #[doc = " Control session id of the originating session."]
    pub control_session_id: i64,
    #[doc = " Recording ID of the recording which transitioned."]
    pub recording_id: i64,
    #[doc = " Subscription ID of the subscription which captured the recording."]
    pub subscription_id: i64,
    #[doc = " The position of the recording at the time of transition."]
    pub position: i64,
    #[doc = " Raw code representing the operation the recording has undertaken."]
    pub recording_signal_code: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_recording_signal_stct"]
        [::std::mem::size_of::<aeron_archive_recording_signal_stct>() - 40usize];
    ["Alignment of aeron_archive_recording_signal_stct"]
        [::std::mem::align_of::<aeron_archive_recording_signal_stct>() - 8usize];
    ["Offset of field: aeron_archive_recording_signal_stct::control_session_id"]
        [::std::mem::offset_of!(aeron_archive_recording_signal_stct, control_session_id) - 0usize];
    ["Offset of field: aeron_archive_recording_signal_stct::recording_id"]
        [::std::mem::offset_of!(aeron_archive_recording_signal_stct, recording_id) - 8usize];
    ["Offset of field: aeron_archive_recording_signal_stct::subscription_id"]
        [::std::mem::offset_of!(aeron_archive_recording_signal_stct, subscription_id) - 16usize];
    ["Offset of field: aeron_archive_recording_signal_stct::position"]
        [::std::mem::offset_of!(aeron_archive_recording_signal_stct, position) - 24usize];
    ["Offset of field: aeron_archive_recording_signal_stct::recording_signal_code"][::std::mem::offset_of!(
        aeron_archive_recording_signal_stct,
        recording_signal_code
    ) - 32usize];
};
#[doc = " Struct containing the details of a recording signal."]
pub type aeron_archive_recording_signal_t = aeron_archive_recording_signal_stct;
#[doc = " Callback to return recording signals."]
pub type aeron_archive_recording_signal_consumer_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        recording_signal: *mut aeron_archive_recording_signal_t,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_archive_source_location_en {
    AERON_ARCHIVE_SOURCE_LOCATION_LOCAL = 0,
    AERON_ARCHIVE_SOURCE_LOCATION_REMOTE = 1,
}
pub use self::aeron_archive_source_location_en as aeron_archive_source_location_t;
unsafe extern "C" {
    #[doc = " Create an aeron_archive_context_t struct.\n\n @param ctx context to create and initialize"]
    pub fn aeron_archive_context_init(
        ctx: *mut *mut aeron_archive_context_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close and delete the aeron_archive_context_t struct.\n\n @param ctx context to delete"]
    pub fn aeron_archive_context_close(ctx: *mut aeron_archive_context_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify the client used for communicating with the local Media Driver.\n <p>\n This client will be closed with the aeron_archive_t is closed if aeron_archive_context_set_owns_aeron_client is true."]
    pub fn aeron_archive_context_set_aeron(
        ctx: *mut aeron_archive_context_t,
        aeron: *mut aeron_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_aeron(ctx: *mut aeron_archive_context_t) -> *mut aeron_t;
}
unsafe extern "C" {
    #[doc = " Specify whether or not this context owns the client and, therefore, takes responsibility for closing it."]
    pub fn aeron_archive_context_set_owns_aeron_client(
        ctx: *mut aeron_archive_context_t,
        owns_aeron_client: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_owns_aeron_client(ctx: *mut aeron_archive_context_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Specify the top level Aeron directory used for communication between the Aeron client and the Media Driver."]
    pub fn aeron_archive_context_set_aeron_directory_name(
        ctx: *mut aeron_archive_context_t,
        aeron_directory_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_aeron_directory_name(
        ctx: *mut aeron_archive_context_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Specify the channel used for sending requests to the Aeron Archive."]
    pub fn aeron_archive_context_set_control_request_channel(
        ctx: *mut aeron_archive_context_t,
        control_request_channel: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_request_channel(
        ctx: *mut aeron_archive_context_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Specify the stream used for sending requests to the Aeron Archive."]
    pub fn aeron_archive_context_set_control_request_stream_id(
        ctx: *mut aeron_archive_context_t,
        control_request_stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_request_stream_id(
        ctx: *mut aeron_archive_context_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Specify the channel used for receiving responses from the Aeron Archive."]
    pub fn aeron_archive_context_set_control_response_channel(
        ctx: *mut aeron_archive_context_t,
        control_response_channel: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_response_channel(
        ctx: *mut aeron_archive_context_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Specify the stream used for receiving responses from the Aeron Archive."]
    pub fn aeron_archive_context_set_control_response_stream_id(
        ctx: *mut aeron_archive_context_t,
        control_response_stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_response_stream_id(
        ctx: *mut aeron_archive_context_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Specify the channel used for receiving recording events from the Aeron Archive."]
    pub fn aeron_archive_context_set_recording_events_channel(
        ctx: *mut aeron_archive_context_t,
        recording_events_channel: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_recording_events_channel(
        ctx: *mut aeron_archive_context_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Specify the stream id used for recording events channel."]
    pub fn aeron_archive_context_set_recording_events_stream_id(
        ctx: *mut aeron_archive_context_t,
        recording_events_stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_recording_events_stream_id(
        ctx: *mut aeron_archive_context_t,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Specify the message timeout, in nanoseconds, to wait for sending or receiving a message."]
    pub fn aeron_archive_context_set_message_timeout_ns(
        ctx: *mut aeron_archive_context_t,
        message_timeout_ns: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_message_timeout_ns(ctx: *mut aeron_archive_context_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Specify the default term buffer length for the control request/response channels."]
    pub fn aeron_archive_context_set_control_term_buffer_length(
        ctx: *mut aeron_archive_context_t,
        control_term_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_term_buffer_length(
        ctx: *mut aeron_archive_context_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Specify the default MTU length for the control request/response channels."]
    pub fn aeron_archive_context_set_control_mtu_length(
        ctx: *mut aeron_archive_context_t,
        control_mtu_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_mtu_length(ctx: *mut aeron_archive_context_t)
    -> usize;
}
unsafe extern "C" {
    #[doc = " Specify the default MTU length for the control request/response channels."]
    pub fn aeron_archive_context_set_control_term_buffer_sparse(
        ctx: *mut aeron_archive_context_t,
        control_term_buffer_sparse: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_control_term_buffer_sparse(
        ctx: *mut aeron_archive_context_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Specify client name to identify this client on the archive side."]
    pub fn aeron_archive_context_set_client_name(
        context: *mut aeron_archive_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_context_get_client_name(
        context: *mut aeron_archive_context_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Specify the idle strategy function and associated state used by the client between polling calls."]
    pub fn aeron_archive_context_set_idle_strategy(
        ctx: *mut aeron_archive_context_t,
        idle_strategy_func: aeron_idle_strategy_func_t,
        idle_strategy_state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify the various credentials callbacks to use when connecting to the Aeron Archive."]
    pub fn aeron_archive_context_set_credentials_supplier(
        ctx: *mut aeron_archive_context_t,
        encoded_credentials: aeron_archive_credentials_encoded_credentials_supplier_func_t,
        on_challenge: aeron_archive_credentials_challenge_supplier_func_t,
        on_free: aeron_archive_credentials_free_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify the callback to which recording signals are dispatched while polling for control responses."]
    pub fn aeron_archive_context_set_recording_signal_consumer(
        ctx: *mut aeron_archive_context_t,
        on_recording_signal: aeron_archive_recording_signal_consumer_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify the callback to which errors are dispatched while executing archive client commands."]
    pub fn aeron_archive_context_set_error_handler(
        ctx: *mut aeron_archive_context_t,
        error_handler: aeron_error_handler_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify the callback to be invoked in addition to any invoker used by the Aeron instance.\n <p>\n Useful when running in a low thread count environment."]
    pub fn aeron_archive_context_set_delegating_invoker(
        ctx: *mut aeron_archive_context_t,
        delegating_invoker_func: aeron_archive_delegating_invoker_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Begin an attempt at creating a connection which can be completed by calling aeron_archive_async_connect_poll.\n\n @param async aeron_archive_async_connect_t to create and initialize\n @param ctx aeron_archive_context_t for the archive connection"]
    pub fn aeron_archive_async_connect(
        async_: *mut *mut aeron_archive_async_connect_t,
        ctx: *mut aeron_archive_context_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll for a complete connection.\n\n @param aeron_archive aeron_archive_t that will be created/initialized upon successful connection\n @param async aeron_archive_async_connect_t to poll\n @return -1 for failure, 0 for 'try again', and 1 for success\n <p>\n Note that after a return of either -1 or 1, the provided aeron_archive_async_connect_t will have been deleted.\n <p>\n Also note that after a return of 1, the aeron_archive pointer will be set to a ready to use aeron_archive_t."]
    pub fn aeron_archive_async_connect_poll(
        aeron_archive: *mut *mut aeron_archive_t,
        async_: *mut aeron_archive_async_connect_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Connect to an Aeron Archive.\n\n @param aeron_archive aeron_archive_t that will be created/initialized upon successful connection\n @param ctx aeron_archive_context_t for the archive connection"]
    pub fn aeron_archive_connect(
        aeron_archive: *mut *mut aeron_archive_t,
        ctx: *mut aeron_archive_context_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close the connection to the Aeron Archive and free up associated resources."]
    pub fn aeron_archive_close(aeron_archive: *mut aeron_archive_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the underlying aeron_archive_context_t used to configure the provided aeron_archive_t."]
    pub fn aeron_archive_get_archive_context(
        aeron_archive: *mut aeron_archive_t,
    ) -> *mut aeron_archive_context_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the underlying aeron_archive_context_t used to configure the provided aeron_archive_t.\n <p>\n Additionally, calling this function transfers ownership of the returned aeron_archive_context_t to the caller.\n i.e. it is now the the caller's responsibility to close the context.\n This is useful when wrapping the C library in other, higher level languages."]
    pub fn aeron_archive_get_and_own_archive_context(
        aeron_archive: *mut aeron_archive_t,
    ) -> *mut aeron_archive_context_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the archive id of the connected Aeron Archive."]
    pub fn aeron_archive_get_archive_id(aeron_archive: *mut aeron_archive_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Retrieve the underlying aeron_subscription_t used for reading responses from the connected Aeron Archive."]
    pub fn aeron_archive_get_control_response_subscription(
        aeron_archive: *mut aeron_archive_t,
    ) -> *mut aeron_subscription_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the underlying aeron_subscription_t used for reading responses from the connected Aeron Archive.\n <p>\n Additionally, calling this function transfers ownership of the returned aeron_subscription_t to the caller.\n i.e. it is now the caller's responsibility to close the subscription.\n This is useful when wrapping the C library in other, high level languages."]
    pub fn aeron_archive_get_and_own_control_response_subscription(
        aeron_archive: *mut aeron_archive_t,
    ) -> *mut aeron_subscription_t;
}
unsafe extern "C" {
    pub fn aeron_archive_control_session_id(aeron_archive: *mut aeron_archive_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Poll for recording signals, dispatching them to the configured aeron_archive_recording_signal_consumer_func_t in the context\n\n @param count_p out param that indicates the number of recording signals dispatched.\n @return 0 for success, -1 for failure."]
    pub fn aeron_archive_poll_for_recording_signals(
        count_p: *mut i32,
        aeron_archive: *mut aeron_archive_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the response stream once for an error.\n If another message is present then it will be skipped over, so only call when not expecting another response.\n\n @return 0 if an error sent from the Aeron Archive is found, in which case, the provided buffer contains the error message.\n If there was no error, the buffer will be an empty string.\n <p>\n -1 if an error occurs while attempting to read from the subscription."]
    pub fn aeron_archive_poll_for_error_response(
        aeron_archive: *mut aeron_archive_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the response stream once for an error.\n\n @return 0 if no error is found OR if an error is found but an error handler is specified in the context.\n <p>\n -1 if an error is found and no error handler is specified.  The error message can be retrieved by calling aeron_errmsg()"]
    pub fn aeron_archive_check_for_error_response(
        aeron_archive: *mut aeron_archive_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a publication and set it up to be recorded.\n\n @param publication_p out param set to the aeron_publication_t upon success\n @param aeron_archive the archive client\n @param channel the channel for the publication\n @param stream_id the stream id for the publication"]
    pub fn aeron_archive_add_recorded_publication(
        publication_p: *mut *mut aeron_publication_t,
        aeron_archive: *mut aeron_archive_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an exclusive publication and set it up to be recorded.\n\n @param publication_p out param set to the aeron_exclusive_publication_t upon success\n @param aeron_archive the archive client\n @param channel the channel for the exclusive publication\n @param stream_id the stream id for the exclusive publication\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_add_recorded_exclusive_publication(
        exclusive_publication_p: *mut *mut aeron_exclusive_publication_t,
        aeron_archive: *mut aeron_archive_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start recording a channel/stream pairing.\n <p>\n Channels that include session id parameters are considered different than channels without session ids.\n If a publication matches both a session id specific channel recording and a non session id specific recording,\n it will be recorded twice.\n\n @param subscription_id_p out param set to the subscription id of the recording\n @param aeron_archive the archive client\n @param recording_channel the channel of the publication to be recorded\n @param recording_stream_id the stream id of the publication to be recorded\n @param source_location the source location of the publication to be recorded\n @param auto_stop should the recording be automatically stopped when complete\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_start_recording(
        subscription_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_channel: *const ::std::os::raw::c_char,
        recording_stream_id: i32,
        source_location: aeron_archive_source_location_t,
        auto_stop: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetch the position recorded for the specified recording.\n\n @param recording_position_p out param set to the recording position of the specified recording\n @param aeron_archive the archive client\n @param recording_id the active recording id\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_get_recording_position(
        recording_position_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetch the start position for the specified recording.\n\n @param start_position_p out param set to the start position of the specified recording\n @param aeron_archive the archive client\n @param recording_id the active recording id\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_get_start_position(
        start_position_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetch the stop position for the specified recording.\n\n @param stop_position_p out param set to the stop position of the specified recording\n @param aeron_archive the archive client\n @param recording_id the active recording id\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_get_stop_position(
        stop_position_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetch the stop or active position for the specified recording.\n\n @param max_recorded_position_p out param set to the stop or active position of the specified recording\n @param aeron_archive the archive client\n @param recording_id the active recording id\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_get_max_recorded_position(
        max_recorded_position_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop recording for the specified subscription id.\n This is the subscription id returned from aeron_archive_start_recording or aeron_archive_extend_recording.\n\n @param aeron_archive the archive client\n @param subscription_id the subscription id for the recording in the Aeron Archive\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_recording_subscription(
        aeron_archive: *mut aeron_archive_t,
        subscription_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Try to stop a recording for the specified subscription id.\n This is the subscription id returned from aeron_archive_start_recording or aeron_archive_extend_recording.\n\n @param stopped_p out param indicating true if stopped, or false if the subscription is not currently active\n @param aeron_archive the archive client\n @param subscription_id the subscription id for the recording in the Aeron Archive\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_try_stop_recording_subscription(
        stopped_p: *mut bool,
        aeron_archive: *mut aeron_archive_t,
        subscription_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop recording for the specified channel and stream.\n <p>\n Channels that include session id parameters are considered different than channels without session ids.\n Stopping a recording on a channel without a session id parameter will not stop the recording of any\n session id specific recordings that use the same channel and stream id.\n\n @param aeron_archive the archive client\n @param channel the channel of the recording to be stopped\n @param stream_id the stream id of the recording to be stopped\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_recording_channel_and_stream(
        aeron_archive: *mut aeron_archive_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Try to stop recording for the specified channel and stream.\n <p>\n Channels that include session id parameters are considered different than channels without session ids.\n Stopping a recording on a channel without a session id parameter will not stop the recording of any\n session id specific recordings that use the same channel and stream id.\n\n @param stopped_p out param indicating true if stopped, or false if the channel/stream pair is not currently active\n @param aeron_archive the archive client\n @param channel the channel of the recording to be stopped\n @param stream_id the stream id of the recording to be stopped\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_try_stop_recording_channel_and_stream(
        stopped_p: *mut bool,
        aeron_archive: *mut aeron_archive_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop recording for the specified recording id.\n\n @param stopped_p out param indicating true if stopped, or false if the recording is not currently active\n @param aeron_archive the archive client\n @param recording_id the id of the recording to be stopped\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_try_stop_recording_by_identity(
        stopped_p: *mut bool,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop recording a session id specific recording that pertains to the given publication.\n\n @param aeron_archive the archive client\n @param publication the publication to stop recording\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_recording_publication(
        aeron_archive: *mut aeron_archive_t,
        publication: *mut aeron_publication_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop recording a session id specific recording that pertains to the given exclusive publication.\n\n @param aeron_archive the archive client\n @param exclusive_publication the exclusive publication to stop recording\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_recording_exclusive_publication(
        aeron_archive: *mut aeron_archive_t,
        exclusive_publication: *mut aeron_exclusive_publication_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find the last recording that matches the given criteria.\n\n @param recording_id_p out param for the recording id that matches\n @param aeron_archive the archive client\n @param min_recording_id the lowest recording id to search back to\n @param channel_fragment for a 'contains' match on the original channel stored with the Aeron Archive\n @param stream_id the stream id of the recording\n @param session_id the session id of the recording\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_find_last_matching_recording(
        recording_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        min_recording_id: i64,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List a recording descriptor for a single recording id.\n\n @param count_p out param indicating the number of descriptors found\n @param aeron_archive the archive client\n @param recording_id the id of the recording\n @param recording_descriptor_consumer to be called for each descriptor\n @param recording_descriptor_consumer_clientd to be passed for each descriptor\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_list_recording(
        count_p: *mut i32,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        recording_descriptor_consumer: aeron_archive_recording_descriptor_consumer_func_t,
        recording_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List all recording descriptors starting at a particular recording id, with a limit of total descriptors delivered.\n\n @param count_p out param indicating the number of descriptors found\n @param aeron_archive the archive client\n @param from_recording_id the id at which to begin the listing\n @param record_count the limit of total descriptors to deliver\n @param recording_descriptor_consumer to be called for each descriptor\n @param recording_descriptor_consumer_clientd to be passed for each descriptor\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_list_recordings(
        count_p: *mut i32,
        aeron_archive: *mut aeron_archive_t,
        from_recording_id: i64,
        record_count: i32,
        recording_descriptor_consumer: aeron_archive_recording_descriptor_consumer_func_t,
        recording_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List all recording descriptors for a given channel fragment and stream id, starting at a particular recording id, with a limit of total descriptors delivered.\n\n @param count_p out param indicating the number of descriptors found\n @param aeron_archive the archive client\n @param from_recording_id the id at which to begin the listing\n @param record_count the limit of total descriptors to deliver\n @param channel_fragment for a 'contains' match on the original channel stored with the Aeron Archive\n @param stream_id the stream id of the recording\n @param recording_descriptor_consumer to be called for each descriptor\n @param recording_descriptor_consumer_clientd to be passed for each descriptor\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_list_recordings_for_uri(
        count_p: *mut i32,
        aeron_archive: *mut aeron_archive_t,
        from_recording_id: i64,
        record_count: i32,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
        recording_descriptor_consumer: aeron_archive_recording_descriptor_consumer_func_t,
        recording_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start a replay\n <p>\n The lower 32-bits of the replay session id contain the session id of the image of the received replay\n and can be obtained by casting the replay session id to an int32_t.\n All 64-bits are required to uniquely identify the replay when calling aeron_archive_stop_replay.\n\n @param replay_session_id_p out param set to the replay session id\n @param aeron_archive the archive client\n @param recording_id the id of the recording\n @param replay_channel the channel to which the replay should be sent\n @param replay_stream_id the stream id to which the replay should be sent\n @param params the aeron_archive_replay_params_t that control the behaviour of the replay\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_start_replay(
        replay_session_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        replay_channel: *const ::std::os::raw::c_char,
        replay_stream_id: i32,
        params: *mut aeron_archive_replay_params_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start a replay.\n\n @param subscription_p out param set to the subscription created for consuming the replay\n @param aeron_archive the archive client\n @param recording_id the id of the recording\n @param replay_channel the channel to which the replay should be sent\n @param replay_stream_id the stream id to which the replay should be sent\n @param params the aeron_archive_replay_params_t that control the behaviour of the replay\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_replay(
        subscription_p: *mut *mut aeron_subscription_t,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        replay_channel: *const ::std::os::raw::c_char,
        replay_stream_id: i32,
        params: *mut aeron_archive_replay_params_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Truncate a stopped recording to the specified position.\n The position must be less than the stopped position.\n The position must be on a fragment boundary.\n Truncating a recording to the start position effectively deletes the recording.\n\n @param count_p out param set to the number of segments deleted\n @param aeron_archive the archive client\n @param recording_id the id of the recording\n @param position the position to which the recording will be truncated\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_truncate_recording(
        count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        position: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop a replay session.\n\n @param aeron_archive the archive client\n @param replay_session_id the replay session id indicating the replay to stop\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_replay(
        aeron_archive: *mut aeron_archive_t,
        replay_session_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop all replays matching a recording id.\n If recording_id is AERON_NULL_VALUE then match all replays.\n\n @param aeron_archive the archive client\n @param recording_id the id of the recording for which all replays will be stopped\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_all_replays(
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List active recording subscriptions in the Aeron Archive.\n These are the result of calling aeron_archive_start_recording or aeron_archive_extend_recording.\n The subscription id in the returned descriptor can be used when calling aeron_archive_stop_recording_subscription.\n\n @param count_p out param set to the count of matched subscriptions\n @param aeron_archive the archive client\n @param pseudo_index the index into the active list at which to begin listing\n @param subscription_count the limit of total descriptors to deliver\n @param channel_fragment for a 'contains' match on the original channel stored with the Aeron Archive\n @param stream_id the stream id of the recording\n @param apply_stream_id whether or not the stream id should be matched\n @param recording_subscription_descriptor_consumer to be called for each descriptor\n @param recording_subscription_descriptor_consumer_clientd to be passed for each descriptor\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_list_recording_subscriptions(
        count_p: *mut i32,
        aeron_archive: *mut aeron_archive_t,
        pseudo_index: i32,
        subscription_count: i32,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
        apply_stream_id: bool,
        recording_subscription_descriptor_consumer : aeron_archive_recording_subscription_descriptor_consumer_func_t,
        recording_subscription_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Purge a stopped recording.\n i.e. Mark the recording as INVALID at the Archive and delete the corresponding segment files.\n The space in the Catalog will be reclaimed upon compaction.\n\n @param deleted_segments_count_p out param set to the number of deleted segments\n @param aeron_archive the archive client\n @param recording_id the id of the stopped recording to be purged\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_purge_recording(
        deleted_segments_count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Extend an existing, non-active recording for a channel and stream pairing.\n <p>\n The channel must be configured with the initial position from which it will be extended.\n This can be done with aeron_uri_string_builder_set_initial_position.\n The details required to initialize can be found by calling aeron_archive_list_recording.\n\n @param subscription_id_p out param set to the subscription id of the recording\n @param aeron_archive the archive client\n @param recording_id the id of the existing recording\n @param recording_channel the channel of the publication to be recorded\n @param recording_stream_id the stream id of the publication to be recorded\n @param source_location the source location of the publication to be recorded\n @param auto_stop should the recording be automatically stopped when complete\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_extend_recording(
        subscription_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        recording_channel: *const ::std::os::raw::c_char,
        recording_stream_id: i32,
        source_location: aeron_archive_source_location_t,
        auto_stop: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Replicate a recording from a source Archive to a destination.\n This can be considered a backup for a primary Archive.\n The source recording will be replayed via the provided replay channel and use the original stream id.\n The behavior of the replication will be governed by the values specified in the aeron_archive_replication_params_t.\n <p>\n For a source recording that is still active, the replay can merge with the live stream and then follow it directly and no longer require the replay from the source.\n This would require a multicast live destination.\n <p>\n Errors will be reported asynchronously and can be checked for with aeron_archive_check_for_error_response and aeron_archive_poll_for_error_response.\n\n @param replication_id_p out param set to the replication id that can be used to stop the replication\n @param aeron_archive the archive client\n @param src_recording_id the recording id that must exist at the source Archive\n @param src_control_channel remote control channel for the source archive on which to instruct the replay\n @param src_control_stream_id remote control stream id for the source archive on which to instruct the replay\n @param params optional parameters to configure the behavior of the replication\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_replicate(
        replication_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        src_recording_id: i64,
        src_control_channel: *const ::std::os::raw::c_char,
        src_control_stream_id: i32,
        params: *mut aeron_archive_replication_params_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop a replication by the replication id.\n\n @param aeron_archive the archive client\n @param replication_id the replication id retrieved when calling aeron_archive_replicate\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_stop_replication(
        aeron_archive: *mut aeron_archive_t,
        replication_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Try to stop a replication by the replication id.\n\n @param stopped_p out param indicating true if stopped, or false if the recording is not currently active\n @param aeron_archive the archive client\n @param replication_id the replication id retrieved when calling aeron_archive_replicate\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_try_stop_replication(
        stopped_p: *mut bool,
        aeron_archive: *mut aeron_archive_t,
        replication_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Detach segments from the beginning of a recording up to the provided new start position.\n <p>\n The new start position must be the first byte position of a segment after the existing start position.\n <p>\n It is not possible to detach segments which are active for recording or being replayed.\n\n @param aeron_archive the archive client\n @param recording_id the id of an existing recording\n @param new_start_position the new starting position for the recording after the segments are detached\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_detach_segments(
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        new_start_position: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete segments which have been previously detached from a recording.\n\n @param count_p out param set to the number of segments deleted\n @param aeron_archive the archive client\n @param recording_id the id of an existing recording\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_delete_detached_segments(
        count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Purge (Detach and delete) segments from the beginning of a recording up to the provided new start position.\n <p>\n The new start position must be the first byte position of a segment after the existing start position.\n <p>\n It is not possible to detach segments which are active for recording or being replayed.\n\n @param count_p out param set to the number of segments deleted\n @param aeron_archive the archive client\n @param recording_id the id of an existing recording\n @param new_start_position the new starting position for the recording after the segments are detached\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_purge_segments(
        count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        new_start_position: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attach segments to the beginning of a recording to restore history that was previously detached.\n <p>\n Segment files must match the existing recording and join exactly to the start position of the recording they are being attached to.\n\n @param count_p out param set to the number of segments attached\n @param aeron_archive the archive client\n @param recording_id the id of an existing recording\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_attach_segments(
        count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Migrate segments from a source recording and attach them to the beginning of a destination recording.\n <p>\n The source recording must match the destination recording for segment length, term length, mtu length,\n stream id, plus the stop position and term id of the source must join with the start position of the destination\n and be on a segment boundary.\n <p>\n The source recording will be effectively truncated back to its start position after the migration.\n\n @param count_p out param set to the number of segments deleted\n @param aeron_archive the archive client\n @param src_recording_id the id of an existing recording from which segments will be migrated\n @param dst_recording_id the id of an existing recording to which segments will be migrated\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_migrate_segments(
        count_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        src_recording_id: i64,
        dst_recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update the channel for a recording, i.e. replace original and stripped channel information in the catalog.\n\n @param aeron_archive the archive client\n @param recording_id the id of the recording.\n @param new_channel to use in the catalogue.\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_update_channel(
        aeron_archive: *mut aeron_archive_t,
        recording_id: i64,
        new_channel: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Position of the recorded stream at the base of a segment file.\n <p>\n If a recording starts within a term then the base position can be before the recording started.\n\n @param start_position start position of the stream\n @param position position in the stream to calculate the segment base position from.\n @param term_buffer_length term buffer length of the stream\n @param segment_file_length segment file length, which is a multiple of term buffer length\n @return the position of the recorded stream at the beginning of a segment file"]
    pub fn aeron_archive_segment_file_base_position(
        start_position: i64,
        position: i64,
        term_buffer_length: i32,
        segment_file_length: i32,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Find the active counter id for a stream based on the recording id.\n\n @param counters_reader an aeron_counters_reader_t to search within\n @param recording_id the recording id of an active recording\n @return the counter id if found, otherwise AERON_NULL_COUNTER_ID"]
    pub fn aeron_archive_recording_pos_find_counter_id_by_recording_id(
        counters_reader: *mut aeron_counters_reader_t,
        recording_id: i64,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Find the active counter id for a stream based on the session id.\n\n @param counters_reader an aeron_counters_reader_t to search within\n @param session_id the session id of an active recording\n @return the counter id if found, otherwise AERON_NULL_COUNTER_ID"]
    pub fn aeron_archive_recording_pos_find_counter_id_by_session_id(
        counters_reader: *mut aeron_counters_reader_t,
        session_id: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Get the recording id for a given counter id.\n\n @param counters_reader an aeron_counters_reader_t to search within\n @param counter_id the counter id of an active recording\n @return the recording id if found, otherwise AERON_NULL_COUNTER_ID"]
    pub fn aeron_archive_recording_pos_get_recording_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the source identity for the recording.\n <p>\n See source_identity in aeron_image_constants_t.\n\n @param counters_reader an aeron_counters_reader_t to search within\n @param counter_id the counter id of an active recording\n @param dst a destination buffer into which the source identity will be written\n @param len_p a pointer to a size_t that initially indicates the length of the dst buffer.  After the function return successfully, len_p will be set to the length of the source identity string in dst\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_recording_pos_get_source_identity(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        dst: *const ::std::os::raw::c_char,
        len_p: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is the recording counter still active?\n\n @param is_active out param set to true if the counter is still active\n @param counters_reader an aeron_counters_reader_t to search within\n @param counter_id the counter id to search for\n @param recording_id the recording id to match against\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_recording_pos_is_active(
        is_active: *mut bool,
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        recording_id: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aeron_archive_replay_merge_stct {
    _unused: [u8; 0],
}
pub type aeron_archive_replay_merge_t = aeron_archive_replay_merge_stct;
unsafe extern "C" {
    #[doc = " Create an aeron_archive_replay_merge_t to manage the merging of a replayed stream into a live stream.\n\n @param replay_merge the aeron_archive_replay_merge_t to create and initialize\n @param subscription the subscription to use for the replay and live stream.  Must be a multi-destination subscription\n @param aeron_archive the archive client\n @param replay_channel the channel to use for the replay\n @param replay_destination the replay channel to use for the destination added by the subscription\n @param live_destination the live stream channel to use for the destination added by the subscription\n @param recording_id the recording id of the archive to replay\n @param start_position the start position of the replay\n @param epoch_clock the clock to use for progress checks\n @param merge_progress_timeout_ms the timeout to use for progress checks\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_replay_merge_init(
        replay_merge: *mut *mut aeron_archive_replay_merge_t,
        subscription: *mut aeron_subscription_t,
        aeron_archive: *mut aeron_archive_t,
        replay_channel: *const ::std::os::raw::c_char,
        replay_destination: *const ::std::os::raw::c_char,
        live_destination: *const ::std::os::raw::c_char,
        recording_id: i64,
        start_position: i64,
        epoch_clock: ::std::os::raw::c_longlong,
        merge_progress_timeout_ms: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close and delete the aeron_archive_replay_merge_t struct.\n\n @param replay_merge the aeron_archive_replay_merge_t to close and delete\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_replay_merge_close(
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Process the operation of the merge.  Do not call the processing of fragments on the subscription.\n\n @param work_count_p an indicator of work done\n @param replay_merge the replay_merge to process\n @return 0 for success, -1 for failure"]
    pub fn aeron_archive_replay_merge_do_work(
        work_count_p: *mut ::std::os::raw::c_int,
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Poll the image used for the merging replay and live stream.\n The aeron_archive_replay_merge_do_work will be called before the poll so that processing of the merge can be done.\n\n @param replay_merge the replay_merge to process/poll\n @param handler the handler to call for incoming fragments\n @param clientd the clientd to provide to the handler\n @param fragment_limit the max number of fragments to process before returning\n @return >= 0 indicates the number of fragments processed, -1 for failure"]
    pub fn aeron_archive_replay_merge_poll(
        replay_merge: *mut aeron_archive_replay_merge_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The image used for the replay and live stream.\n\n @param replay_merge the replay_merge that owns the image.\n @return the aeron_image_t"]
    pub fn aeron_archive_replay_merge_image(
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> *mut aeron_image_t;
}
unsafe extern "C" {
    #[doc = " Is the live stream merged and the replay stopped?\n\n @param replay_merge the replay_merge to check\n @return true if merged, false otherwise"]
    pub fn aeron_archive_replay_merge_is_merged(
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Has the replay_merge failed due to an error?\n\n @param replay_merge the replay_merge to check\n @return true if an error occurred"]
    pub fn aeron_archive_replay_merge_has_failed(
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Is the live destination added to the subscription?\n\n @param replay_merge the replay_merge to check\n @return true if the live destination is added to the subscription"]
    pub fn aeron_archive_replay_merge_is_live_added(
        replay_merge: *mut aeron_archive_replay_merge_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_proxy_stct {
    pub ctx: *mut aeron_archive_context_t,
    pub exclusive_publication: *mut aeron_exclusive_publication_t,
    pub control_session_id: i64,
    pub retry_attempts: ::std::os::raw::c_int,
    pub buffer: [u8; 8192usize],
    pub client_info: [::std::os::raw::c_char; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_proxy_stct"]
        [::std::mem::size_of::<aeron_archive_proxy_stct>() - 8424usize];
    ["Alignment of aeron_archive_proxy_stct"]
        [::std::mem::align_of::<aeron_archive_proxy_stct>() - 8usize];
    ["Offset of field: aeron_archive_proxy_stct::ctx"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, ctx) - 0usize];
    ["Offset of field: aeron_archive_proxy_stct::exclusive_publication"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, exclusive_publication) - 8usize];
    ["Offset of field: aeron_archive_proxy_stct::control_session_id"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, control_session_id) - 16usize];
    ["Offset of field: aeron_archive_proxy_stct::retry_attempts"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, retry_attempts) - 24usize];
    ["Offset of field: aeron_archive_proxy_stct::buffer"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, buffer) - 28usize];
    ["Offset of field: aeron_archive_proxy_stct::client_info"]
        [::std::mem::offset_of!(aeron_archive_proxy_stct, client_info) - 8220usize];
};
impl Default for aeron_archive_proxy_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_archive_proxy_t = aeron_archive_proxy_stct;
unsafe extern "C" {
    pub fn aeron_archive_proxy_create(
        archive_proxy: *mut *mut aeron_archive_proxy_t,
        ctx: *mut aeron_archive_context_t,
        exclusive_publication: *mut aeron_exclusive_publication_t,
        retry_attempts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_init(
        archive_proxy: *mut aeron_archive_proxy_t,
        ctx: *mut aeron_archive_context_t,
        exclusive_publication: *mut aeron_exclusive_publication_t,
        retry_attempts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_set_control_esssion_id(
        archive_proxy: *mut aeron_archive_proxy_t,
        control_session_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_close(
        archive_proxy: *mut aeron_archive_proxy_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_delete(
        archive_proxy: *mut aeron_archive_proxy_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_try_connect(
        archive_proxy: *mut aeron_archive_proxy_t,
        control_response_channel: *const ::std::os::raw::c_char,
        control_response_stream_id: i32,
        encoded_credentials: *mut aeron_archive_encoded_credentials_t,
        correlation_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_archive_id(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_challenge_response(
        archive_proxy: *mut aeron_archive_proxy_t,
        encoded_credentials: *mut aeron_archive_encoded_credentials_t,
        correlation_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_close_session(archive_proxy: *mut aeron_archive_proxy_t) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_start_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        recording_channel: *const ::std::os::raw::c_char,
        recording_stream_id: i32,
        local_source: bool,
        auto_stop: bool,
        correlation_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_get_recording_position(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_get_start_position(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_get_stop_position(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_get_max_recorded_position(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_recording_subscription(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        subscription_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_recording_by_identity(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_find_last_matching_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        min_recording_id: i64,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
        session_id: i32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_list_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_list_recordings(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        from_recording_id: i64,
        record_count: i32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_list_recordings_for_uri(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        from_recording_id: i64,
        record_count: i32,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_replay(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
        replay_channel: *const ::std::os::raw::c_char,
        replay_stream_id: i32,
        params: *mut aeron_archive_replay_params_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_truncate_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
        position: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_replay(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        replay_session_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_all_replays(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_list_recording_subscriptions(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        pseudo_index: i32,
        subscription_count: i32,
        channel_fragment: *const ::std::os::raw::c_char,
        stream_id: i32,
        apply_stream_id: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_purge_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_extend_recording(
        archive_proxy: *mut aeron_archive_proxy_t,
        recording_id: i64,
        recording_channel: *const ::std::os::raw::c_char,
        recording_stream_id: i32,
        local_source: bool,
        auto_stop: bool,
        correlation_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_replicate(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        src_recording_id: i64,
        src_control_stream_id: i32,
        src_control_channel: *const ::std::os::raw::c_char,
        params: *mut aeron_archive_replication_params_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_stop_replication(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        replication_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_request_replay_token(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_detach_segments(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
        new_start_position: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_delete_detached_segments(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_purge_segments(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
        new_start_position: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_attach_segments(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_migrate_segments(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        src_recording_id: i64,
        dst_recording_id: i64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy_update_channel(
        archive_proxy: *mut aeron_archive_proxy_t,
        correlation_id: i64,
        recording_id: i64,
        new_channel: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_control_response_poller_stct {
    pub subscription: *mut aeron_subscription_t,
    pub fragment_limit: ::std::os::raw::c_int,
    pub fragment_assembler: *mut aeron_controlled_fragment_assembler_t,
    pub error_on_fragment: bool,
    pub control_session_id: i64,
    pub correlation_id: i64,
    pub relevant_id: i64,
    pub recording_id: i64,
    pub subscription_id: i64,
    pub position: i64,
    pub recording_signal_code: i32,
    pub version: i32,
    pub error_message: *mut ::std::os::raw::c_char,
    pub error_message_malloced_len: u32,
    pub encoded_challenge_buffer: *mut ::std::os::raw::c_char,
    pub encoded_challenge_buffer_malloced_len: u32,
    pub encoded_challenge: aeron_archive_encoded_credentials_t,
    pub code_value: ::std::os::raw::c_int,
    pub is_poll_complete: bool,
    pub is_code_ok: bool,
    pub is_code_error: bool,
    pub is_control_response: bool,
    pub was_challenged: bool,
    pub is_recording_signal: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_control_response_poller_stct"]
        [::std::mem::size_of::<aeron_archive_control_response_poller_stct>() - 152usize];
    ["Alignment of aeron_archive_control_response_poller_stct"]
        [::std::mem::align_of::<aeron_archive_control_response_poller_stct>() - 8usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::subscription"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, subscription) - 0usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::fragment_limit"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        fragment_limit
    ) - 8usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::fragment_assembler"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        fragment_assembler
    )
        - 16usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::error_on_fragment"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        error_on_fragment
    ) - 24usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::control_session_id"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        control_session_id
    )
        - 32usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::correlation_id"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        correlation_id
    ) - 40usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::relevant_id"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, relevant_id) - 48usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::recording_id"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        recording_id
    ) - 56usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::subscription_id"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        subscription_id
    ) - 64usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::position"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, position) - 72usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::recording_signal_code"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        recording_signal_code
    )
        - 80usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::version"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, version) - 84usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::error_message"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        error_message
    ) - 88usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::error_message_malloced_len"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        error_message_malloced_len
    )
        - 96usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::encoded_challenge_buffer"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        encoded_challenge_buffer
    )
        - 104usize];
    [
        "Offset of field: aeron_archive_control_response_poller_stct::encoded_challenge_buffer_malloced_len",
    ][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        encoded_challenge_buffer_malloced_len
    ) - 112usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::encoded_challenge"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        encoded_challenge
    )
        - 120usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::code_value"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, code_value) - 136usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::is_poll_complete"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        is_poll_complete
    ) - 140usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::is_code_ok"]
        [::std::mem::offset_of!(aeron_archive_control_response_poller_stct, is_code_ok) - 141usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::is_code_error"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        is_code_error
    ) - 142usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::is_control_response"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        is_control_response
    )
        - 143usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::was_challenged"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        was_challenged
    ) - 144usize];
    ["Offset of field: aeron_archive_control_response_poller_stct::is_recording_signal"][::std::mem::offset_of!(
        aeron_archive_control_response_poller_stct,
        is_recording_signal
    )
        - 145usize];
};
impl Default for aeron_archive_control_response_poller_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_archive_control_response_poller_t = aeron_archive_control_response_poller_stct;
unsafe extern "C" {
    pub fn aeron_archive_control_response_poller_create(
        poller: *mut *mut aeron_archive_control_response_poller_t,
        subscription: *mut aeron_subscription_t,
        fragment_limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_control_response_poller_close(
        poller: *mut aeron_archive_control_response_poller_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_control_response_poller_poll(
        poller: *mut aeron_archive_control_response_poller_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_recording_descriptor_poller_stct {
    pub ctx: *mut aeron_archive_context_t,
    pub subscription: *mut aeron_subscription_t,
    pub control_session_id: i64,
    pub fragment_limit: ::std::os::raw::c_int,
    pub fragment_assembler: *mut aeron_controlled_fragment_assembler_t,
    pub error_on_fragment: bool,
    pub correlation_id: i64,
    pub remaining_record_count: i32,
    pub recording_descriptor_consumer: aeron_archive_recording_descriptor_consumer_func_t,
    pub recording_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    pub is_dispatch_complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_recording_descriptor_poller_stct"]
        [::std::mem::size_of::<aeron_archive_recording_descriptor_poller_stct>() - 88usize];
    ["Alignment of aeron_archive_recording_descriptor_poller_stct"]
        [::std::mem::align_of::<aeron_archive_recording_descriptor_poller_stct>() - 8usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::ctx"]
        [::std::mem::offset_of!(aeron_archive_recording_descriptor_poller_stct, ctx) - 0usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::subscription"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        subscription
    ) - 8usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::control_session_id"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        control_session_id
    )
        - 16usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::fragment_limit"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        fragment_limit
    )
        - 24usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::fragment_assembler"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        fragment_assembler
    )
        - 32usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::error_on_fragment"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        error_on_fragment
    )
        - 40usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::correlation_id"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        correlation_id
    )
        - 48usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::remaining_record_count"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        remaining_record_count
    )
        - 56usize];
    [
        "Offset of field: aeron_archive_recording_descriptor_poller_stct::recording_descriptor_consumer",
    ][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        recording_descriptor_consumer
    ) - 64usize];
    [
        "Offset of field: aeron_archive_recording_descriptor_poller_stct::recording_descriptor_consumer_clientd",
    ][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        recording_descriptor_consumer_clientd
    ) - 72usize];
    ["Offset of field: aeron_archive_recording_descriptor_poller_stct::is_dispatch_complete"][::std::mem::offset_of!(
        aeron_archive_recording_descriptor_poller_stct,
        is_dispatch_complete
    )
        - 80usize];
};
impl Default for aeron_archive_recording_descriptor_poller_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_archive_recording_descriptor_poller_t =
    aeron_archive_recording_descriptor_poller_stct;
unsafe extern "C" {
    pub fn aeron_archive_recording_descriptor_poller_create(
        poller: *mut *mut aeron_archive_recording_descriptor_poller_t,
        ctx: *mut aeron_archive_context_t,
        subscription: *mut aeron_subscription_t,
        control_session_id: i64,
        fragment_limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_recording_descriptor_poller_close(
        poller: *mut aeron_archive_recording_descriptor_poller_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_recording_descriptor_poller_reset(
        poller: *mut aeron_archive_recording_descriptor_poller_t,
        correlation_id: i64,
        record_count: i32,
        recording_descriptor_consumer: aeron_archive_recording_descriptor_consumer_func_t,
        recording_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn aeron_archive_recording_descriptor_poller_poll(
        poller: *mut aeron_archive_recording_descriptor_poller_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_recording_subscription_descriptor_poller_stct {
    pub ctx: *mut aeron_archive_context_t,
    pub subscription: *mut aeron_subscription_t,
    pub control_session_id: i64,
    pub fragment_limit: ::std::os::raw::c_int,
    pub fragment_assembler: *mut aeron_controlled_fragment_assembler_t,
    pub error_on_fragment: bool,
    pub correlation_id: i64,
    pub remaining_subscription_count: i32,
    pub recording_subscription_descriptor_consumer:
        aeron_archive_recording_subscription_descriptor_consumer_func_t,
    pub recording_subscription_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    pub is_dispatch_complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_recording_subscription_descriptor_poller_stct"][::std::mem::size_of::<
        aeron_archive_recording_subscription_descriptor_poller_stct,
    >() - 88usize];
    ["Alignment of aeron_archive_recording_subscription_descriptor_poller_stct"]
        [::std::mem::align_of::<aeron_archive_recording_subscription_descriptor_poller_stct>()
            - 8usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::ctx"][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        ctx
    )
        - 0usize];
    ["Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::subscription"]
        [::std::mem::offset_of!(
            aeron_archive_recording_subscription_descriptor_poller_stct,
            subscription
        ) - 8usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::control_session_id",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        control_session_id
    ) - 16usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::fragment_limit",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        fragment_limit
    ) - 24usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::fragment_assembler",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        fragment_assembler
    ) - 32usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::error_on_fragment",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        error_on_fragment
    ) - 40usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::correlation_id",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        correlation_id
    ) - 48usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::remaining_subscription_count",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        remaining_subscription_count
    ) - 56usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::recording_subscription_descriptor_consumer",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        recording_subscription_descriptor_consumer
    ) - 64usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::recording_subscription_descriptor_consumer_clientd",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        recording_subscription_descriptor_consumer_clientd
    ) - 72usize];
    [
        "Offset of field: aeron_archive_recording_subscription_descriptor_poller_stct::is_dispatch_complete",
    ][::std::mem::offset_of!(
        aeron_archive_recording_subscription_descriptor_poller_stct,
        is_dispatch_complete
    ) - 80usize];
};
impl Default for aeron_archive_recording_subscription_descriptor_poller_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_archive_recording_subscription_descriptor_poller_t =
    aeron_archive_recording_subscription_descriptor_poller_stct;
unsafe extern "C" {
    pub fn aeron_archive_recording_subscription_descriptor_poller_create(
        poller: *mut *mut aeron_archive_recording_subscription_descriptor_poller_t,
        ctx: *mut aeron_archive_context_t,
        subscription: *mut aeron_subscription_t,
        control_session_id: i64,
        fragment_limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_recording_subscription_descriptor_poller_close(
        poller: *mut aeron_archive_recording_subscription_descriptor_poller_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_recording_subscription_descriptor_poller_reset(
        poller: *mut aeron_archive_recording_subscription_descriptor_poller_t,
        correlation_id: i64,
        subscription_count: i32,
        recording_subscription_descriptor_consumer : aeron_archive_recording_subscription_descriptor_consumer_func_t,
        recording_subscription_descriptor_consumer_clientd: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn aeron_archive_recording_subscription_descriptor_poller_poll(
        poller: *mut aeron_archive_recording_subscription_descriptor_poller_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_thread_set_name(role_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn aeron_nano_sleep(nanoseconds: u64);
}
unsafe extern "C" {
    pub fn aeron_micro_sleep(microseconds: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn aeron_thread_set_affinity(
        role_name: *const ::std::os::raw::c_char,
        cpu_affinity_no: u8,
    ) -> ::std::os::raw::c_int;
}
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_t = __darwin_pthread_t;
pub type aeron_mutex_t = pthread_mutex_t;
pub type aeron_thread_t = pthread_t;
pub type aeron_thread_attr_t = pthread_attr_t;
pub type aeron_cond_t = pthread_cond_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_archive_stct {
    pub owns_ctx: bool,
    pub ctx: *mut aeron_archive_context_t,
    pub lock: aeron_mutex_t,
    pub archive_proxy: *mut aeron_archive_proxy_t,
    pub owns_control_response_subscription: bool,
    pub subscription: *mut aeron_subscription_t,
    pub control_response_poller: *mut aeron_archive_control_response_poller_t,
    pub recording_descriptor_poller: *mut aeron_archive_recording_descriptor_poller_t,
    pub recording_subscription_descriptor_poller:
        *mut aeron_archive_recording_subscription_descriptor_poller_t,
    pub control_session_id: i64,
    pub archive_id: i64,
    pub is_in_callback: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_archive_stct"][::std::mem::size_of::<aeron_archive_stct>() - 152usize];
    ["Alignment of aeron_archive_stct"][::std::mem::align_of::<aeron_archive_stct>() - 8usize];
    ["Offset of field: aeron_archive_stct::owns_ctx"]
        [::std::mem::offset_of!(aeron_archive_stct, owns_ctx) - 0usize];
    ["Offset of field: aeron_archive_stct::ctx"]
        [::std::mem::offset_of!(aeron_archive_stct, ctx) - 8usize];
    ["Offset of field: aeron_archive_stct::lock"]
        [::std::mem::offset_of!(aeron_archive_stct, lock) - 16usize];
    ["Offset of field: aeron_archive_stct::archive_proxy"]
        [::std::mem::offset_of!(aeron_archive_stct, archive_proxy) - 80usize];
    ["Offset of field: aeron_archive_stct::owns_control_response_subscription"]
        [::std::mem::offset_of!(aeron_archive_stct, owns_control_response_subscription) - 88usize];
    ["Offset of field: aeron_archive_stct::subscription"]
        [::std::mem::offset_of!(aeron_archive_stct, subscription) - 96usize];
    ["Offset of field: aeron_archive_stct::control_response_poller"]
        [::std::mem::offset_of!(aeron_archive_stct, control_response_poller) - 104usize];
    ["Offset of field: aeron_archive_stct::recording_descriptor_poller"]
        [::std::mem::offset_of!(aeron_archive_stct, recording_descriptor_poller) - 112usize];
    ["Offset of field: aeron_archive_stct::recording_subscription_descriptor_poller"][::std::mem::offset_of!(
        aeron_archive_stct,
        recording_subscription_descriptor_poller
    ) - 120usize];
    ["Offset of field: aeron_archive_stct::control_session_id"]
        [::std::mem::offset_of!(aeron_archive_stct, control_session_id) - 128usize];
    ["Offset of field: aeron_archive_stct::archive_id"]
        [::std::mem::offset_of!(aeron_archive_stct, archive_id) - 136usize];
    ["Offset of field: aeron_archive_stct::is_in_callback"]
        [::std::mem::offset_of!(aeron_archive_stct, is_in_callback) - 144usize];
};
impl Default for aeron_archive_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn aeron_archive_create(
        aeron_archive: *mut *mut aeron_archive_t,
        ctx: *mut aeron_archive_context_t,
        archive_proxy: *mut aeron_archive_proxy_t,
        subscription: *mut aeron_subscription_t,
        control_response_poller: *mut aeron_archive_control_response_poller_t,
        recording_descriptor_poller: *mut aeron_archive_recording_descriptor_poller_t,
        recording_subscription_descriptor_poller : * mut aeron_archive_recording_subscription_descriptor_poller_t,
        control_session_id: i64,
        archive_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_archive_idle(aeron_archive: *mut aeron_archive_t);
}
unsafe extern "C" {
    pub fn aeron_archive_control_response_poller(
        aeron_archive: *mut aeron_archive_t,
    ) -> *mut aeron_archive_control_response_poller_t;
}
unsafe extern "C" {
    pub fn aeron_archive_proxy(aeron_archive: *mut aeron_archive_t) -> *mut aeron_archive_proxy_t;
}
unsafe extern "C" {
    pub fn aeron_archive_next_correlation_id(aeron_archive: *mut aeron_archive_t) -> i64;
}
unsafe extern "C" {
    pub fn aeron_archive_poll_for_response(
        relevant_id_p: *mut i64,
        aeron_archive: *mut aeron_archive_t,
        operation_name: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_uri_param_stct {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_uri_param_stct"][::std::mem::size_of::<aeron_uri_param_stct>() - 16usize];
    ["Alignment of aeron_uri_param_stct"][::std::mem::align_of::<aeron_uri_param_stct>() - 8usize];
    ["Offset of field: aeron_uri_param_stct::key"]
        [::std::mem::offset_of!(aeron_uri_param_stct, key) - 0usize];
    ["Offset of field: aeron_uri_param_stct::value"]
        [::std::mem::offset_of!(aeron_uri_param_stct, value) - 8usize];
};
impl Default for aeron_uri_param_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_uri_param_t = aeron_uri_param_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_uri_params_stct {
    pub length: usize,
    pub array: *mut aeron_uri_param_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_uri_params_stct"][::std::mem::size_of::<aeron_uri_params_stct>() - 16usize];
    ["Alignment of aeron_uri_params_stct"]
        [::std::mem::align_of::<aeron_uri_params_stct>() - 8usize];
    ["Offset of field: aeron_uri_params_stct::length"]
        [::std::mem::offset_of!(aeron_uri_params_stct, length) - 0usize];
    ["Offset of field: aeron_uri_params_stct::array"]
        [::std::mem::offset_of!(aeron_uri_params_stct, array) - 8usize];
};
impl Default for aeron_uri_params_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_uri_params_t = aeron_uri_params_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_udp_channel_params_stct {
    pub endpoint: *const ::std::os::raw::c_char,
    pub bind_interface: *const ::std::os::raw::c_char,
    pub control: *const ::std::os::raw::c_char,
    pub control_mode: *const ::std::os::raw::c_char,
    pub channel_tag: *const ::std::os::raw::c_char,
    pub entity_tag: *const ::std::os::raw::c_char,
    pub ttl: *const ::std::os::raw::c_char,
    pub additional_params: aeron_uri_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_udp_channel_params_stct"]
        [::std::mem::size_of::<aeron_udp_channel_params_stct>() - 72usize];
    ["Alignment of aeron_udp_channel_params_stct"]
        [::std::mem::align_of::<aeron_udp_channel_params_stct>() - 8usize];
    ["Offset of field: aeron_udp_channel_params_stct::endpoint"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, endpoint) - 0usize];
    ["Offset of field: aeron_udp_channel_params_stct::bind_interface"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, bind_interface) - 8usize];
    ["Offset of field: aeron_udp_channel_params_stct::control"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, control) - 16usize];
    ["Offset of field: aeron_udp_channel_params_stct::control_mode"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, control_mode) - 24usize];
    ["Offset of field: aeron_udp_channel_params_stct::channel_tag"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, channel_tag) - 32usize];
    ["Offset of field: aeron_udp_channel_params_stct::entity_tag"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, entity_tag) - 40usize];
    ["Offset of field: aeron_udp_channel_params_stct::ttl"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, ttl) - 48usize];
    ["Offset of field: aeron_udp_channel_params_stct::additional_params"]
        [::std::mem::offset_of!(aeron_udp_channel_params_stct, additional_params) - 56usize];
};
impl Default for aeron_udp_channel_params_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_udp_channel_params_t = aeron_udp_channel_params_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_ipc_channel_params_stct {
    pub channel_tag: *const ::std::os::raw::c_char,
    pub entity_tag: *const ::std::os::raw::c_char,
    pub control_mode: *const ::std::os::raw::c_char,
    pub additional_params: aeron_uri_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_ipc_channel_params_stct"]
        [::std::mem::size_of::<aeron_ipc_channel_params_stct>() - 40usize];
    ["Alignment of aeron_ipc_channel_params_stct"]
        [::std::mem::align_of::<aeron_ipc_channel_params_stct>() - 8usize];
    ["Offset of field: aeron_ipc_channel_params_stct::channel_tag"]
        [::std::mem::offset_of!(aeron_ipc_channel_params_stct, channel_tag) - 0usize];
    ["Offset of field: aeron_ipc_channel_params_stct::entity_tag"]
        [::std::mem::offset_of!(aeron_ipc_channel_params_stct, entity_tag) - 8usize];
    ["Offset of field: aeron_ipc_channel_params_stct::control_mode"]
        [::std::mem::offset_of!(aeron_ipc_channel_params_stct, control_mode) - 16usize];
    ["Offset of field: aeron_ipc_channel_params_stct::additional_params"]
        [::std::mem::offset_of!(aeron_ipc_channel_params_stct, additional_params) - 24usize];
};
impl Default for aeron_ipc_channel_params_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_ipc_channel_params_t = aeron_ipc_channel_params_stct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_uri_type_enum {
    AERON_URI_UDP = 0,
    AERON_URI_IPC = 1,
    AERON_URI_UNKNOWN = 2,
}
pub use self::aeron_uri_type_enum as aeron_uri_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_uri_stct {
    pub mutable_uri: [::std::os::raw::c_char; 4096usize],
    pub type_: aeron_uri_type_t,
    pub params: aeron_uri_stct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aeron_uri_stct__bindgen_ty_1 {
    pub udp: aeron_udp_channel_params_t,
    pub ipc: aeron_ipc_channel_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_uri_stct__bindgen_ty_1"]
        [::std::mem::size_of::<aeron_uri_stct__bindgen_ty_1>() - 72usize];
    ["Alignment of aeron_uri_stct__bindgen_ty_1"]
        [::std::mem::align_of::<aeron_uri_stct__bindgen_ty_1>() - 8usize];
    ["Offset of field: aeron_uri_stct__bindgen_ty_1::udp"]
        [::std::mem::offset_of!(aeron_uri_stct__bindgen_ty_1, udp) - 0usize];
    ["Offset of field: aeron_uri_stct__bindgen_ty_1::ipc"]
        [::std::mem::offset_of!(aeron_uri_stct__bindgen_ty_1, ipc) - 0usize];
};
impl Default for aeron_uri_stct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_uri_stct"][::std::mem::size_of::<aeron_uri_stct>() - 4176usize];
    ["Alignment of aeron_uri_stct"][::std::mem::align_of::<aeron_uri_stct>() - 8usize];
    ["Offset of field: aeron_uri_stct::mutable_uri"]
        [::std::mem::offset_of!(aeron_uri_stct, mutable_uri) - 0usize];
    ["Offset of field: aeron_uri_stct::type_"]
        [::std::mem::offset_of!(aeron_uri_stct, type_) - 4096usize];
    ["Offset of field: aeron_uri_stct::params"]
        [::std::mem::offset_of!(aeron_uri_stct, params) - 4104usize];
};
impl Default for aeron_uri_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_uri_t = aeron_uri_stct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_uri_ats_status_en {
    AERON_URI_ATS_STATUS_DEFAULT = 0,
    AERON_URI_ATS_STATUS_ENABLED = 1,
    AERON_URI_ATS_STATUS_DISABLED = 2,
}
pub use self::aeron_uri_ats_status_en as aeron_uri_ats_status_t;
pub type aeron_uri_parse_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn aeron_uri_parse_params(
        uri: *mut ::std::os::raw::c_char,
        param_func: aeron_uri_parse_callback_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_parse(
        uri_length: usize,
        uri: *const ::std::os::raw::c_char,
        params: *mut aeron_uri_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_close(params: *mut aeron_uri_t);
}
unsafe extern "C" {
    pub fn aeron_uri_multicast_ttl(uri: *mut aeron_uri_t) -> u8;
}
unsafe extern "C" {
    pub fn aeron_uri_find_param_value(
        uri_params: *const aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn aeron_uri_get_int32(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        retval: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_int64(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        default_val: i64,
        retval: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_bool(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        retval: *mut bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_ats(
        uri_params: *mut aeron_uri_params_t,
        uri_ats_status: *mut aeron_uri_ats_status_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_timeout(
        uri_params: *mut aeron_uri_params_t,
        param_name: *const ::std::os::raw::c_char,
        timeout_ns: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_sprint(
        uri: *mut aeron_uri_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_socket_buf_lengths(
        uri_params: *mut aeron_uri_params_t,
        socket_sndbuf_length: *mut usize,
        socket_rcvbuf_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_get_receiver_window_length(
        uri_params: *mut aeron_uri_params_t,
        receiver_window_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_parse_tag(tag_str: *const ::std::os::raw::c_char) -> i64;
}
unsafe extern "C" {
    pub fn aeron_randomised_int32() -> i32;
}
unsafe extern "C" {
    pub fn aeron_format_date(str_: *mut ::std::os::raw::c_char, count: usize, timestamp: i64);
}
unsafe extern "C" {
    pub fn aeron_format_number_to_locale(
        value: ::std::os::raw::c_longlong,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn aeron_format_to_hex(
        str_: *mut ::std::os::raw::c_char,
        str_length: usize,
        data: *const u8,
        data_len: usize,
    );
}
unsafe extern "C" {
    pub fn aeron_tokenise(
        input: *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_per_thread_error_stct {
    pub errcode: ::std::os::raw::c_int,
    pub offset: usize,
    pub errmsg: [::std::os::raw::c_char; 8192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_per_thread_error_stct"]
        [::std::mem::size_of::<aeron_per_thread_error_stct>() - 8208usize];
    ["Alignment of aeron_per_thread_error_stct"]
        [::std::mem::align_of::<aeron_per_thread_error_stct>() - 8usize];
    ["Offset of field: aeron_per_thread_error_stct::errcode"]
        [::std::mem::offset_of!(aeron_per_thread_error_stct, errcode) - 0usize];
    ["Offset of field: aeron_per_thread_error_stct::offset"]
        [::std::mem::offset_of!(aeron_per_thread_error_stct, offset) - 8usize];
    ["Offset of field: aeron_per_thread_error_stct::errmsg"]
        [::std::mem::offset_of!(aeron_per_thread_error_stct, errmsg) - 16usize];
};
impl Default for aeron_per_thread_error_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_per_thread_error_t = aeron_per_thread_error_stct;
unsafe extern "C" {
    pub fn aeron_set_errno(errcode: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn aeron_error_code_str(errcode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn aeron_err_set(
        errcode: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        line_number: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn aeron_err_append(
        function: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        line_number: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn aeron_err_clear();
}
unsafe extern "C" {
    pub fn aeron_alloc_no_err(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_alloc(ptr: *mut *mut ::std::os::raw::c_void, size: usize)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_alloc_aligned(
        ptr: *mut *mut ::std::os::raw::c_void,
        offset: *mut usize,
        size: usize,
        alignment: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_reallocf(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_free(ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_str_to_ptr_hash_map_key_stct {
    pub str_: *const ::std::os::raw::c_char,
    pub hash_code: u64,
    pub str_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_str_to_ptr_hash_map_key_stct"]
        [::std::mem::size_of::<aeron_str_to_ptr_hash_map_key_stct>() - 24usize];
    ["Alignment of aeron_str_to_ptr_hash_map_key_stct"]
        [::std::mem::align_of::<aeron_str_to_ptr_hash_map_key_stct>() - 8usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_key_stct::str_"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_key_stct, str_) - 0usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_key_stct::hash_code"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_key_stct, hash_code) - 8usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_key_stct::str_length"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_key_stct, str_length) - 16usize];
};
impl Default for aeron_str_to_ptr_hash_map_key_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_str_to_ptr_hash_map_key_t = aeron_str_to_ptr_hash_map_key_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aeron_str_to_ptr_hash_map_stct {
    pub keys: *mut aeron_str_to_ptr_hash_map_key_t,
    pub values: *mut *mut ::std::os::raw::c_void,
    pub load_factor: f32,
    pub capacity: usize,
    pub size: usize,
    pub resize_threshold: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_str_to_ptr_hash_map_stct"]
        [::std::mem::size_of::<aeron_str_to_ptr_hash_map_stct>() - 48usize];
    ["Alignment of aeron_str_to_ptr_hash_map_stct"]
        [::std::mem::align_of::<aeron_str_to_ptr_hash_map_stct>() - 8usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::keys"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, keys) - 0usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::values"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, values) - 8usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::load_factor"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, load_factor) - 16usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::capacity"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, capacity) - 24usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::size"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, size) - 32usize];
    ["Offset of field: aeron_str_to_ptr_hash_map_stct::resize_threshold"]
        [::std::mem::offset_of!(aeron_str_to_ptr_hash_map_stct, resize_threshold) - 40usize];
};
impl Default for aeron_str_to_ptr_hash_map_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_str_to_ptr_hash_map_t = aeron_str_to_ptr_hash_map_stct;
pub type aeron_str_to_ptr_hash_map_for_each_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
        value: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aeron_uri_string_builder_stct {
    pub params: aeron_str_to_ptr_hash_map_t,
    pub closed: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_uri_string_builder_stct"]
        [::std::mem::size_of::<aeron_uri_string_builder_stct>() - 56usize];
    ["Alignment of aeron_uri_string_builder_stct"]
        [::std::mem::align_of::<aeron_uri_string_builder_stct>() - 8usize];
    ["Offset of field: aeron_uri_string_builder_stct::params"]
        [::std::mem::offset_of!(aeron_uri_string_builder_stct, params) - 0usize];
    ["Offset of field: aeron_uri_string_builder_stct::closed"]
        [::std::mem::offset_of!(aeron_uri_string_builder_stct, closed) - 48usize];
};
impl Default for aeron_uri_string_builder_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_uri_string_builder_t = aeron_uri_string_builder_stct;
unsafe extern "C" {
    pub fn aeron_uri_string_builder_init_new(
        builder: *mut aeron_uri_string_builder_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_init_on_string(
        builder: *mut aeron_uri_string_builder_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_close(
        builder: *mut aeron_uri_string_builder_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_put(
        builder: *mut aeron_uri_string_builder_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_put_int32(
        builder: *mut aeron_uri_string_builder_t,
        key: *const ::std::os::raw::c_char,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_put_int64(
        builder: *mut aeron_uri_string_builder_t,
        key: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_get(
        builder: *mut aeron_uri_string_builder_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_sprint(
        builder: *mut aeron_uri_string_builder_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_uri_string_builder_set_initial_position(
        builder: *mut aeron_uri_string_builder_t,
        position: i64,
        initial_term_id: i32,
        term_length: i32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_frame_header_stct {
    pub frame_length: i32,
    pub version: i8,
    pub flags: u8,
    pub type_: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_frame_header_stct"][::std::mem::size_of::<aeron_frame_header_stct>() - 8usize];
    ["Alignment of aeron_frame_header_stct"]
        [::std::mem::align_of::<aeron_frame_header_stct>() - 4usize];
    ["Offset of field: aeron_frame_header_stct::frame_length"]
        [::std::mem::offset_of!(aeron_frame_header_stct, frame_length) - 0usize];
    ["Offset of field: aeron_frame_header_stct::version"]
        [::std::mem::offset_of!(aeron_frame_header_stct, version) - 4usize];
    ["Offset of field: aeron_frame_header_stct::flags"]
        [::std::mem::offset_of!(aeron_frame_header_stct, flags) - 5usize];
    ["Offset of field: aeron_frame_header_stct::type_"]
        [::std::mem::offset_of!(aeron_frame_header_stct, type_) - 6usize];
};
pub type aeron_frame_header_t = aeron_frame_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_data_header_as_longs_stct {
    pub hdr: [u64; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_data_header_as_longs_stct"]
        [::std::mem::size_of::<aeron_data_header_as_longs_stct>() - 32usize];
    ["Alignment of aeron_data_header_as_longs_stct"]
        [::std::mem::align_of::<aeron_data_header_as_longs_stct>() - 4usize];
    ["Offset of field: aeron_data_header_as_longs_stct::hdr"]
        [::std::mem::offset_of!(aeron_data_header_as_longs_stct, hdr) - 0usize];
};
pub type aeron_data_header_as_longs_t = aeron_data_header_as_longs_stct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_setup_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub initial_term_id: i32,
    pub active_term_id: i32,
    pub term_length: i32,
    pub mtu: i32,
    pub ttl: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_setup_header_stct"][::std::mem::size_of::<aeron_setup_header_stct>() - 40usize];
    ["Alignment of aeron_setup_header_stct"]
        [::std::mem::align_of::<aeron_setup_header_stct>() - 4usize];
    ["Offset of field: aeron_setup_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_setup_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_setup_header_stct::term_offset"]
        [::std::mem::offset_of!(aeron_setup_header_stct, term_offset) - 8usize];
    ["Offset of field: aeron_setup_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_setup_header_stct, session_id) - 12usize];
    ["Offset of field: aeron_setup_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_setup_header_stct, stream_id) - 16usize];
    ["Offset of field: aeron_setup_header_stct::initial_term_id"]
        [::std::mem::offset_of!(aeron_setup_header_stct, initial_term_id) - 20usize];
    ["Offset of field: aeron_setup_header_stct::active_term_id"]
        [::std::mem::offset_of!(aeron_setup_header_stct, active_term_id) - 24usize];
    ["Offset of field: aeron_setup_header_stct::term_length"]
        [::std::mem::offset_of!(aeron_setup_header_stct, term_length) - 28usize];
    ["Offset of field: aeron_setup_header_stct::mtu"]
        [::std::mem::offset_of!(aeron_setup_header_stct, mtu) - 32usize];
    ["Offset of field: aeron_setup_header_stct::ttl"]
        [::std::mem::offset_of!(aeron_setup_header_stct, ttl) - 36usize];
};
pub type aeron_setup_header_t = aeron_setup_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_data_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub reserved_value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_data_header_stct"][::std::mem::size_of::<aeron_data_header_stct>() - 32usize];
    ["Alignment of aeron_data_header_stct"]
        [::std::mem::align_of::<aeron_data_header_stct>() - 4usize];
    ["Offset of field: aeron_data_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_data_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_data_header_stct::term_offset"]
        [::std::mem::offset_of!(aeron_data_header_stct, term_offset) - 8usize];
    ["Offset of field: aeron_data_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_data_header_stct, session_id) - 12usize];
    ["Offset of field: aeron_data_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_data_header_stct, stream_id) - 16usize];
    ["Offset of field: aeron_data_header_stct::term_id"]
        [::std::mem::offset_of!(aeron_data_header_stct, term_id) - 20usize];
    ["Offset of field: aeron_data_header_stct::reserved_value"]
        [::std::mem::offset_of!(aeron_data_header_stct, reserved_value) - 24usize];
};
pub type aeron_data_header_t = aeron_data_header_stct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_nak_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub term_offset: i32,
    pub length: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_nak_header_stct"][::std::mem::size_of::<aeron_nak_header_stct>() - 28usize];
    ["Alignment of aeron_nak_header_stct"]
        [::std::mem::align_of::<aeron_nak_header_stct>() - 4usize];
    ["Offset of field: aeron_nak_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_nak_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_nak_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_nak_header_stct, session_id) - 8usize];
    ["Offset of field: aeron_nak_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_nak_header_stct, stream_id) - 12usize];
    ["Offset of field: aeron_nak_header_stct::term_id"]
        [::std::mem::offset_of!(aeron_nak_header_stct, term_id) - 16usize];
    ["Offset of field: aeron_nak_header_stct::term_offset"]
        [::std::mem::offset_of!(aeron_nak_header_stct, term_offset) - 20usize];
    ["Offset of field: aeron_nak_header_stct::length"]
        [::std::mem::offset_of!(aeron_nak_header_stct, length) - 24usize];
};
pub type aeron_nak_header_t = aeron_nak_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_status_message_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub consumption_term_id: i32,
    pub consumption_term_offset: i32,
    pub receiver_window: i32,
    pub receiver_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_status_message_header_stct"]
        [::std::mem::size_of::<aeron_status_message_header_stct>() - 36usize];
    ["Alignment of aeron_status_message_header_stct"]
        [::std::mem::align_of::<aeron_status_message_header_stct>() - 4usize];
    ["Offset of field: aeron_status_message_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_status_message_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, session_id) - 8usize];
    ["Offset of field: aeron_status_message_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, stream_id) - 12usize];
    ["Offset of field: aeron_status_message_header_stct::consumption_term_id"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, consumption_term_id) - 16usize];
    ["Offset of field: aeron_status_message_header_stct::consumption_term_offset"][::std::mem::offset_of!(
        aeron_status_message_header_stct,
        consumption_term_offset
    ) - 20usize];
    ["Offset of field: aeron_status_message_header_stct::receiver_window"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, receiver_window) - 24usize];
    ["Offset of field: aeron_status_message_header_stct::receiver_id"]
        [::std::mem::offset_of!(aeron_status_message_header_stct, receiver_id) - 28usize];
};
pub type aeron_status_message_header_t = aeron_status_message_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_error_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub receiver_id: i64,
    pub group_tag: i64,
    pub error_code: i32,
    pub error_length: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_error_stct"][::std::mem::size_of::<aeron_error_stct>() - 40usize];
    ["Alignment of aeron_error_stct"][::std::mem::align_of::<aeron_error_stct>() - 4usize];
    ["Offset of field: aeron_error_stct::frame_header"]
        [::std::mem::offset_of!(aeron_error_stct, frame_header) - 0usize];
    ["Offset of field: aeron_error_stct::session_id"]
        [::std::mem::offset_of!(aeron_error_stct, session_id) - 8usize];
    ["Offset of field: aeron_error_stct::stream_id"]
        [::std::mem::offset_of!(aeron_error_stct, stream_id) - 12usize];
    ["Offset of field: aeron_error_stct::receiver_id"]
        [::std::mem::offset_of!(aeron_error_stct, receiver_id) - 16usize];
    ["Offset of field: aeron_error_stct::group_tag"]
        [::std::mem::offset_of!(aeron_error_stct, group_tag) - 24usize];
    ["Offset of field: aeron_error_stct::error_code"]
        [::std::mem::offset_of!(aeron_error_stct, error_code) - 32usize];
    ["Offset of field: aeron_error_stct::error_length"]
        [::std::mem::offset_of!(aeron_error_stct, error_length) - 36usize];
};
pub type aeron_error_t = aeron_error_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_status_message_optional_header_stct {
    pub group_tag: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_status_message_optional_header_stct"]
        [::std::mem::size_of::<aeron_status_message_optional_header_stct>() - 8usize];
    ["Alignment of aeron_status_message_optional_header_stct"]
        [::std::mem::align_of::<aeron_status_message_optional_header_stct>() - 4usize];
    ["Offset of field: aeron_status_message_optional_header_stct::group_tag"]
        [::std::mem::offset_of!(aeron_status_message_optional_header_stct, group_tag) - 0usize];
};
pub type aeron_status_message_optional_header_t = aeron_status_message_optional_header_stct;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_rttm_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub echo_timestamp: i64,
    pub reception_delta: i64,
    pub receiver_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_rttm_header_stct"][::std::mem::size_of::<aeron_rttm_header_stct>() - 40usize];
    ["Alignment of aeron_rttm_header_stct"]
        [::std::mem::align_of::<aeron_rttm_header_stct>() - 4usize];
    ["Offset of field: aeron_rttm_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_rttm_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, session_id) - 8usize];
    ["Offset of field: aeron_rttm_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, stream_id) - 12usize];
    ["Offset of field: aeron_rttm_header_stct::echo_timestamp"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, echo_timestamp) - 16usize];
    ["Offset of field: aeron_rttm_header_stct::reception_delta"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, reception_delta) - 24usize];
    ["Offset of field: aeron_rttm_header_stct::receiver_id"]
        [::std::mem::offset_of!(aeron_rttm_header_stct, receiver_id) - 32usize];
};
pub type aeron_rttm_header_t = aeron_rttm_header_stct;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_resolution_header_stct {
    pub res_type: i8,
    pub res_flags: u8,
    pub udp_port: u16,
    pub age_in_ms: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_resolution_header_stct"]
        [::std::mem::size_of::<aeron_resolution_header_stct>() - 8usize];
    ["Alignment of aeron_resolution_header_stct"]
        [::std::mem::align_of::<aeron_resolution_header_stct>() - 1usize];
    ["Offset of field: aeron_resolution_header_stct::res_type"]
        [::std::mem::offset_of!(aeron_resolution_header_stct, res_type) - 0usize];
    ["Offset of field: aeron_resolution_header_stct::res_flags"]
        [::std::mem::offset_of!(aeron_resolution_header_stct, res_flags) - 1usize];
    ["Offset of field: aeron_resolution_header_stct::udp_port"]
        [::std::mem::offset_of!(aeron_resolution_header_stct, udp_port) - 2usize];
    ["Offset of field: aeron_resolution_header_stct::age_in_ms"]
        [::std::mem::offset_of!(aeron_resolution_header_stct, age_in_ms) - 4usize];
};
pub type aeron_resolution_header_t = aeron_resolution_header_stct;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_resolution_header_ipv4_stct {
    pub resolution_header: aeron_resolution_header_t,
    pub addr: [u8; 4usize],
    pub name_length: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_resolution_header_ipv4_stct"]
        [::std::mem::size_of::<aeron_resolution_header_ipv4_stct>() - 14usize];
    ["Alignment of aeron_resolution_header_ipv4_stct"]
        [::std::mem::align_of::<aeron_resolution_header_ipv4_stct>() - 1usize];
    ["Offset of field: aeron_resolution_header_ipv4_stct::resolution_header"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv4_stct, resolution_header) - 0usize];
    ["Offset of field: aeron_resolution_header_ipv4_stct::addr"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv4_stct, addr) - 8usize];
    ["Offset of field: aeron_resolution_header_ipv4_stct::name_length"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv4_stct, name_length) - 12usize];
};
pub type aeron_resolution_header_ipv4_t = aeron_resolution_header_ipv4_stct;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_resolution_header_ipv6_stct {
    pub resolution_header: aeron_resolution_header_t,
    pub addr: [u8; 16usize],
    pub name_length: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_resolution_header_ipv6_stct"]
        [::std::mem::size_of::<aeron_resolution_header_ipv6_stct>() - 26usize];
    ["Alignment of aeron_resolution_header_ipv6_stct"]
        [::std::mem::align_of::<aeron_resolution_header_ipv6_stct>() - 1usize];
    ["Offset of field: aeron_resolution_header_ipv6_stct::resolution_header"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv6_stct, resolution_header) - 0usize];
    ["Offset of field: aeron_resolution_header_ipv6_stct::addr"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv6_stct, addr) - 8usize];
    ["Offset of field: aeron_resolution_header_ipv6_stct::name_length"]
        [::std::mem::offset_of!(aeron_resolution_header_ipv6_stct, name_length) - 24usize];
};
pub type aeron_resolution_header_ipv6_t = aeron_resolution_header_ipv6_stct;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_option_header_stct {
    pub option_length: u16,
    pub type_: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_option_header_stct"]
        [::std::mem::size_of::<aeron_option_header_stct>() - 4usize];
    ["Alignment of aeron_option_header_stct"]
        [::std::mem::align_of::<aeron_option_header_stct>() - 1usize];
    ["Offset of field: aeron_option_header_stct::option_length"]
        [::std::mem::offset_of!(aeron_option_header_stct, option_length) - 0usize];
    ["Offset of field: aeron_option_header_stct::type_"]
        [::std::mem::offset_of!(aeron_option_header_stct, type_) - 2usize];
};
pub type aeron_option_header_t = aeron_option_header_stct;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_response_setup_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub response_session_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_response_setup_header_stct"]
        [::std::mem::size_of::<aeron_response_setup_header_stct>() - 20usize];
    ["Alignment of aeron_response_setup_header_stct"]
        [::std::mem::align_of::<aeron_response_setup_header_stct>() - 1usize];
    ["Offset of field: aeron_response_setup_header_stct::frame_header"]
        [::std::mem::offset_of!(aeron_response_setup_header_stct, frame_header) - 0usize];
    ["Offset of field: aeron_response_setup_header_stct::session_id"]
        [::std::mem::offset_of!(aeron_response_setup_header_stct, session_id) - 8usize];
    ["Offset of field: aeron_response_setup_header_stct::stream_id"]
        [::std::mem::offset_of!(aeron_response_setup_header_stct, stream_id) - 12usize];
    ["Offset of field: aeron_response_setup_header_stct::response_session_id"]
        [::std::mem::offset_of!(aeron_response_setup_header_stct, response_session_id) - 16usize];
};
pub type aeron_response_setup_header_t = aeron_response_setup_header_stct;
unsafe extern "C" {
    pub fn aeron_udp_protocol_group_tag(
        sm: *mut aeron_status_message_header_t,
        group_tag: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_res_header_entry_length_ipv4(header: *mut aeron_resolution_header_ipv4_t)
    -> usize;
}
unsafe extern "C" {
    pub fn aeron_res_header_entry_length_ipv6(header: *mut aeron_resolution_header_ipv6_t)
    -> usize;
}
unsafe extern "C" {
    pub fn aeron_res_header_entry_length(
        res: *mut ::std::os::raw::c_void,
        remaining: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_logbuffer_metadata_stct {
    pub term_tail_counters: [i64; 3usize],
    pub active_term_count: i32,
    pub pad1: [u8; 100usize],
    pub end_of_stream_position: i64,
    pub is_connected: i32,
    pub active_transport_count: i32,
    pub pad2: [u8; 112usize],
    pub correlation_id: i64,
    pub initial_term_id: i32,
    pub default_frame_header_length: i32,
    pub mtu_length: i32,
    pub term_length: i32,
    pub page_size: i32,
    pub publication_window_length: i32,
    pub receiver_window_length: i32,
    pub socket_sndbuf_length: i32,
    pub os_default_socket_sndbuf_length: i32,
    pub os_max_socket_sndbuf_length: i32,
    pub socket_rcvbuf_length: i32,
    pub os_default_socket_rcvbuf_length: i32,
    pub os_max_socket_rcvbuf_length: i32,
    pub max_resend: i32,
    pub default_header: [u8; 128usize],
    pub entity_tag: i64,
    pub response_correlation_id: i64,
    pub linger_timeout_ns: i64,
    pub untethered_window_limit_timeout_ns: i64,
    pub untethered_resting_timeout_ns: i64,
    pub group: u8,
    pub is_response: u8,
    pub rejoin: u8,
    pub reliable: u8,
    pub sparse: u8,
    pub signal_eos: u8,
    pub spies_simulate_connection: u8,
    pub tether: u8,
    pub is_publication_revoked: u8,
    pub pad3: [u8; 3usize],
    pub untethered_linger_timeout_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_logbuffer_metadata_stct"]
        [::std::mem::size_of::<aeron_logbuffer_metadata_stct>() - 508usize];
    ["Alignment of aeron_logbuffer_metadata_stct"]
        [::std::mem::align_of::<aeron_logbuffer_metadata_stct>() - 4usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::term_tail_counters"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, term_tail_counters) - 0usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::active_term_count"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, active_term_count) - 24usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::pad1"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, pad1) - 28usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::end_of_stream_position"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, end_of_stream_position) - 128usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::is_connected"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, is_connected) - 136usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::active_transport_count"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, active_transport_count) - 140usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::pad2"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, pad2) - 144usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::correlation_id"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, correlation_id) - 256usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::initial_term_id"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, initial_term_id) - 264usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::default_frame_header_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        default_frame_header_length
    ) - 268usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::mtu_length"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, mtu_length) - 272usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::term_length"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, term_length) - 276usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::page_size"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, page_size) - 280usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::publication_window_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        publication_window_length
    ) - 284usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::receiver_window_length"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, receiver_window_length) - 288usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::socket_sndbuf_length"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, socket_sndbuf_length) - 292usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::os_default_socket_sndbuf_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        os_default_socket_sndbuf_length
    )
        - 296usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::os_max_socket_sndbuf_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        os_max_socket_sndbuf_length
    ) - 300usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::socket_rcvbuf_length"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, socket_rcvbuf_length) - 304usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::os_default_socket_rcvbuf_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        os_default_socket_rcvbuf_length
    )
        - 308usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::os_max_socket_rcvbuf_length"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        os_max_socket_rcvbuf_length
    ) - 312usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::max_resend"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, max_resend) - 316usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::default_header"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, default_header) - 320usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::entity_tag"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, entity_tag) - 448usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::response_correlation_id"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, response_correlation_id) - 456usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::linger_timeout_ns"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, linger_timeout_ns) - 464usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::untethered_window_limit_timeout_ns"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        untethered_window_limit_timeout_ns
    )
        - 472usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::untethered_resting_timeout_ns"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        untethered_resting_timeout_ns
    ) - 480usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::group"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, group) - 488usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::is_response"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, is_response) - 489usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::rejoin"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, rejoin) - 490usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::reliable"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, reliable) - 491usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::sparse"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, sparse) - 492usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::signal_eos"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, signal_eos) - 493usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::spies_simulate_connection"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        spies_simulate_connection
    ) - 494usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::tether"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, tether) - 495usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::is_publication_revoked"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, is_publication_revoked) - 496usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::pad3"]
        [::std::mem::offset_of!(aeron_logbuffer_metadata_stct, pad3) - 497usize];
    ["Offset of field: aeron_logbuffer_metadata_stct::untethered_linger_timeout_ns"][::std::mem::offset_of!(
        aeron_logbuffer_metadata_stct,
        untethered_linger_timeout_ns
    ) - 500usize];
};
impl Default for aeron_logbuffer_metadata_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_logbuffer_metadata_t = aeron_logbuffer_metadata_stct;
unsafe extern "C" {
    pub fn aeron_logbuffer_check_term_length(term_length: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_logbuffer_check_page_size(page_size: u64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_mapped_file_stct {
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_mapped_file_stct"][::std::mem::size_of::<aeron_mapped_file_stct>() - 16usize];
    ["Alignment of aeron_mapped_file_stct"]
        [::std::mem::align_of::<aeron_mapped_file_stct>() - 8usize];
    ["Offset of field: aeron_mapped_file_stct::addr"]
        [::std::mem::offset_of!(aeron_mapped_file_stct, addr) - 0usize];
    ["Offset of field: aeron_mapped_file_stct::length"]
        [::std::mem::offset_of!(aeron_mapped_file_stct, length) - 8usize];
};
impl Default for aeron_mapped_file_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_mapped_file_t = aeron_mapped_file_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_mapped_buffer_stct {
    pub addr: *mut u8,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_mapped_buffer_stct"]
        [::std::mem::size_of::<aeron_mapped_buffer_stct>() - 16usize];
    ["Alignment of aeron_mapped_buffer_stct"]
        [::std::mem::align_of::<aeron_mapped_buffer_stct>() - 8usize];
    ["Offset of field: aeron_mapped_buffer_stct::addr"]
        [::std::mem::offset_of!(aeron_mapped_buffer_stct, addr) - 0usize];
    ["Offset of field: aeron_mapped_buffer_stct::length"]
        [::std::mem::offset_of!(aeron_mapped_buffer_stct, length) - 8usize];
};
impl Default for aeron_mapped_buffer_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_mapped_buffer_t = aeron_mapped_buffer_stct;
unsafe extern "C" {
    pub fn aeron_is_directory(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_delete_directory(
        directory: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_mkdir_recursive(
        pathname: *const ::std::os::raw::c_char,
        permission: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_map_new_file(
        mapped_file: *mut aeron_mapped_file_t,
        path: *const ::std::os::raw::c_char,
        fill_with_zeroes: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_map_existing_file(
        mapped_file: *mut aeron_mapped_file_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_unmap(mapped_file: *mut aeron_mapped_file_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_msync(addr: *mut ::std::os::raw::c_void, length: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_delete_file(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type aeron_usable_fs_space_func_t =
    ::std::option::Option<unsafe extern "C" fn(path: *const ::std::os::raw::c_char) -> u64>;
unsafe extern "C" {
    pub fn aeron_file_length(path: *const ::std::os::raw::c_char) -> i64;
}
unsafe extern "C" {
    pub fn aeron_usable_fs_space(path: *const ::std::os::raw::c_char) -> u64;
}
unsafe extern "C" {
    pub fn aeron_usable_fs_space_disabled(path: *const ::std::os::raw::c_char) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_mapped_raw_log_stct {
    pub term_buffers: [aeron_mapped_buffer_t; 3usize],
    pub log_meta_data: aeron_mapped_buffer_t,
    pub mapped_file: aeron_mapped_file_t,
    pub term_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_mapped_raw_log_stct"]
        [::std::mem::size_of::<aeron_mapped_raw_log_stct>() - 88usize];
    ["Alignment of aeron_mapped_raw_log_stct"]
        [::std::mem::align_of::<aeron_mapped_raw_log_stct>() - 8usize];
    ["Offset of field: aeron_mapped_raw_log_stct::term_buffers"]
        [::std::mem::offset_of!(aeron_mapped_raw_log_stct, term_buffers) - 0usize];
    ["Offset of field: aeron_mapped_raw_log_stct::log_meta_data"]
        [::std::mem::offset_of!(aeron_mapped_raw_log_stct, log_meta_data) - 48usize];
    ["Offset of field: aeron_mapped_raw_log_stct::mapped_file"]
        [::std::mem::offset_of!(aeron_mapped_raw_log_stct, mapped_file) - 64usize];
    ["Offset of field: aeron_mapped_raw_log_stct::term_length"]
        [::std::mem::offset_of!(aeron_mapped_raw_log_stct, term_length) - 80usize];
};
impl Default for aeron_mapped_raw_log_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_mapped_raw_log_t = aeron_mapped_raw_log_stct;
unsafe extern "C" {
    pub fn aeron_ipc_publication_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_network_publication_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_publication_image_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_temp_filename(filename: *mut ::std::os::raw::c_char, length: usize) -> usize;
}
pub type aeron_raw_log_map_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
        arg4: u64,
        arg5: u64,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_raw_log_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_raw_log_free_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn aeron_raw_log_map(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        path: *const ::std::os::raw::c_char,
        use_sparse_files: bool,
        term_length: u64,
        page_size: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_raw_log_map_existing(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        path: *const ::std::os::raw::c_char,
        pre_touch: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_raw_log_close(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_raw_log_free(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn aeron_file_resolve(
        parent: *const ::std::os::raw::c_char,
        child: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_cnc_metadata_stct {
    pub cnc_version: i32,
    pub to_driver_buffer_length: i32,
    pub to_clients_buffer_length: i32,
    pub counter_metadata_buffer_length: i32,
    pub counter_values_buffer_length: i32,
    pub error_log_buffer_length: i32,
    pub client_liveness_timeout: i64,
    pub start_timestamp: i64,
    pub pid: i64,
    pub file_page_size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_cnc_metadata_stct"][::std::mem::size_of::<aeron_cnc_metadata_stct>() - 52usize];
    ["Alignment of aeron_cnc_metadata_stct"]
        [::std::mem::align_of::<aeron_cnc_metadata_stct>() - 4usize];
    ["Offset of field: aeron_cnc_metadata_stct::cnc_version"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, cnc_version) - 0usize];
    ["Offset of field: aeron_cnc_metadata_stct::to_driver_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, to_driver_buffer_length) - 4usize];
    ["Offset of field: aeron_cnc_metadata_stct::to_clients_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, to_clients_buffer_length) - 8usize];
    ["Offset of field: aeron_cnc_metadata_stct::counter_metadata_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, counter_metadata_buffer_length) - 12usize];
    ["Offset of field: aeron_cnc_metadata_stct::counter_values_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, counter_values_buffer_length) - 16usize];
    ["Offset of field: aeron_cnc_metadata_stct::error_log_buffer_length"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, error_log_buffer_length) - 20usize];
    ["Offset of field: aeron_cnc_metadata_stct::client_liveness_timeout"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, client_liveness_timeout) - 24usize];
    ["Offset of field: aeron_cnc_metadata_stct::start_timestamp"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, start_timestamp) - 32usize];
    ["Offset of field: aeron_cnc_metadata_stct::pid"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, pid) - 40usize];
    ["Offset of field: aeron_cnc_metadata_stct::file_page_size"]
        [::std::mem::offset_of!(aeron_cnc_metadata_stct, file_page_size) - 48usize];
};
pub type aeron_cnc_metadata_t = aeron_cnc_metadata_stct;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aeron_cnc_load_result_stct {
    AERON_CNC_LOAD_FAILED = -1,
    AERON_CNC_LOAD_SUCCESS = 0,
    AERON_CNC_LOAD_AWAIT_FILE = 1,
    AERON_CNC_LOAD_AWAIT_MMAP = 2,
    AERON_CNC_LOAD_AWAIT_VERSION = 3,
    AERON_CNC_LOAD_AWAIT_CNC_DATA = 4,
}
pub use self::aeron_cnc_load_result_stct as aeron_cnc_load_result_t;
unsafe extern "C" {
    pub fn aeron_cnc_version_volatile(metadata: *mut aeron_cnc_metadata_t) -> i32;
}
unsafe extern "C" {
    pub fn aeron_cnc_map_file_and_load_metadata(
        dir: *const ::std::os::raw::c_char,
        mapped_file: *mut aeron_mapped_file_t,
        metadata: *mut *mut aeron_cnc_metadata_t,
    ) -> aeron_cnc_load_result_t;
}
unsafe extern "C" {
    pub fn aeron_cnc_resolve_filename(
        directory: *const ::std::os::raw::c_char,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_loss_reporter_entry_stct {
    pub observation_count: i64,
    pub total_bytes_lost: i64,
    pub first_observation_timestamp: i64,
    pub last_observation_timestamp: i64,
    pub session_id: i32,
    pub stream_id: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_loss_reporter_entry_stct"]
        [::std::mem::size_of::<aeron_loss_reporter_entry_stct>() - 40usize];
    ["Alignment of aeron_loss_reporter_entry_stct"]
        [::std::mem::align_of::<aeron_loss_reporter_entry_stct>() - 4usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::observation_count"]
        [::std::mem::offset_of!(aeron_loss_reporter_entry_stct, observation_count) - 0usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::total_bytes_lost"]
        [::std::mem::offset_of!(aeron_loss_reporter_entry_stct, total_bytes_lost) - 8usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::first_observation_timestamp"][::std::mem::offset_of!(
        aeron_loss_reporter_entry_stct,
        first_observation_timestamp
    ) - 16usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::last_observation_timestamp"][::std::mem::offset_of!(
        aeron_loss_reporter_entry_stct,
        last_observation_timestamp
    ) - 24usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::session_id"]
        [::std::mem::offset_of!(aeron_loss_reporter_entry_stct, session_id) - 32usize];
    ["Offset of field: aeron_loss_reporter_entry_stct::stream_id"]
        [::std::mem::offset_of!(aeron_loss_reporter_entry_stct, stream_id) - 36usize];
};
pub type aeron_loss_reporter_entry_t = aeron_loss_reporter_entry_stct;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aeron_loss_reporter_stct {
    pub buffer: *mut u8,
    pub next_record_offset: usize,
    pub capacity: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aeron_loss_reporter_stct"]
        [::std::mem::size_of::<aeron_loss_reporter_stct>() - 24usize];
    ["Alignment of aeron_loss_reporter_stct"]
        [::std::mem::align_of::<aeron_loss_reporter_stct>() - 8usize];
    ["Offset of field: aeron_loss_reporter_stct::buffer"]
        [::std::mem::offset_of!(aeron_loss_reporter_stct, buffer) - 0usize];
    ["Offset of field: aeron_loss_reporter_stct::next_record_offset"]
        [::std::mem::offset_of!(aeron_loss_reporter_stct, next_record_offset) - 8usize];
    ["Offset of field: aeron_loss_reporter_stct::capacity"]
        [::std::mem::offset_of!(aeron_loss_reporter_stct, capacity) - 16usize];
};
impl Default for aeron_loss_reporter_stct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type aeron_loss_reporter_t = aeron_loss_reporter_stct;
pub type aeron_loss_reporter_entry_offset_t = i64;
unsafe extern "C" {
    pub fn aeron_loss_reporter_init(
        reporter: *mut aeron_loss_reporter_t,
        buffer: *mut u8,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_loss_reporter_create_entry(
        reporter: *mut aeron_loss_reporter_t,
        initial_bytes_lost: i64,
        timestamp_ms: i64,
        session_id: i32,
        stream_id: i32,
        channel: *const ::std::os::raw::c_char,
        channel_length: usize,
        source: *const ::std::os::raw::c_char,
        source_length: usize,
    ) -> aeron_loss_reporter_entry_offset_t;
}
unsafe extern "C" {
    pub fn aeron_loss_reporter_record_observation(
        reporter: *mut aeron_loss_reporter_t,
        offset: aeron_loss_reporter_entry_offset_t,
        bytes_lost: i64,
        timestamp_ms: i64,
    );
}
unsafe extern "C" {
    pub fn aeron_loss_reporter_resolve_filename(
        directory: *const ::std::os::raw::c_char,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aeron_loss_reporter_read(
        buffer: *const u8,
        capacity: usize,
        entry_func: aeron_loss_reporter_read_entry_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> usize;
}
